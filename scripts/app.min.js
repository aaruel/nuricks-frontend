webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var platform_browser_dynamic_1 = __webpack_require__(2);
	var main_module_1 = __webpack_require__(24);
	platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(main_module_1.MainModule);


/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var http_1 = __webpack_require__(25);
	var forms_1 = __webpack_require__(26);
	var platform_browser_1 = __webpack_require__(22);
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	// Custom Imports
	var custom_component_1 = __webpack_require__(60);
	var adminlogin_component_1 = __webpack_require__(73);
	var adminpanel_component_1 = __webpack_require__(371);
	var nav_component_1 = __webpack_require__(373);
	var user_component_1 = __webpack_require__(375);
	var main_component_1 = __webpack_require__(550);
	var angular2_markdown_1 = __webpack_require__(552);
	var backend_service_1 = __webpack_require__(74);
	var main_component_2 = __webpack_require__(553);
	var musician_component_1 = __webpack_require__(554);
	var main_global_ts_1 = __webpack_require__(369);
	var musician_component_2 = __webpack_require__(554);
	var adminlogin_component_2 = __webpack_require__(73);
	var adminpanel_component_2 = __webpack_require__(371);
	var musicianuser_component_1 = __webpack_require__(556);
	var publicmusician_component_1 = __webpack_require__(558);
	var publicmusician_component_2 = __webpack_require__(558);
	var MusicianGuard = (function () {
	    function MusicianGuard(ps, router) {
	        this.ps = ps;
	        this.router = router;
	    }
	    MusicianGuard.prototype.canActivate = function () {
	        if (this.ps.musicianObject.fbid != '') {
	            return true;
	        }
	        this.router.navigate(['/']);
	        return false;
	    };
	    MusicianGuard = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_ts_1.PersistentService !== 'undefined' && main_global_ts_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _b) || Object])
	    ], MusicianGuard);
	    return MusicianGuard;
	    var _a, _b;
	}());
	var UserGuard = (function () {
	    function UserGuard(ps, router) {
	        this.ps = ps;
	        this.router = router;
	    }
	    UserGuard.prototype.canActivate = function () {
	        if (this.ps.userObject.fbid != '' || this.ps.musicianObject.fbid != '') {
	            return true;
	        }
	        this.router.navigate(['/']);
	        return false;
	    };
	    UserGuard = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_ts_1.PersistentService !== 'undefined' && main_global_ts_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _b) || Object])
	    ], UserGuard);
	    return UserGuard;
	    var _a, _b;
	}());
	var appRoutes = [
	    { path: "", component: main_component_1.MainComponent, resolve: { pers: main_global_ts_1.PersistentService } },
	    { path: "dashboard", component: musician_component_1.MusicianComponent, canActivate: [MusicianGuard] },
	    { path: "musician/:id", component: publicmusician_component_2.PublicMusicianComponent, resolve: { pers: main_global_ts_1.PersistentService, mus: publicmusician_component_1.PublicMusicianService } },
	    { path: "adminlogin", component: adminlogin_component_2.AdminLoginComponent },
	    { path: "adminpanel", component: adminpanel_component_2.AdminPanelComponent, canActivate: [adminlogin_component_1.AdminGuard] },
	    { path: "user", component: user_component_1.UserComponent, canActivate: [UserGuard] },
	    { path: "musicianuser", component: musicianuser_component_1.MusicianUserComponent, canActivate: [UserGuard] }
	];
	var MainModule = (function () {
	    function MainModule() {
	    }
	    MainModule = __decorate([
	        core_1.NgModule({
	            imports: [
	                router_1.RouterModule,
	                http_1.HttpModule,
	                forms_1.FormsModule,
	                platform_browser_1.BrowserModule,
	                custom_component_1.MainPipe,
	                router_1.RouterModule.forRoot(appRoutes),
	                angular2_markdown_1.MarkdownModule.forRoot()
	            ],
	            declarations: [
	                main_component_2.OutletComponent,
	                nav_component_1.NavComponent,
	                main_component_1.MainComponent,
	                musician_component_1.MusicianComponent,
	                publicmusician_component_2.PublicMusicianComponent,
	                adminlogin_component_2.AdminLoginComponent,
	                adminpanel_component_2.AdminPanelComponent,
	                user_component_1.UserComponent,
	                musicianuser_component_1.MusicianUserComponent
	            ],
	            bootstrap: [
	                nav_component_1.NavComponent,
	                main_component_2.OutletComponent
	            ],
	            providers: [
	                backend_service_1.BackendService,
	                main_global_ts_1.PersistentService,
	                MusicianGuard,
	                publicmusician_component_1.PublicMusicianService,
	                musician_component_2.EventViewerService,
	                adminpanel_component_1.AdminService,
	                adminlogin_component_1.AdminGuard,
	                UserGuard
	            ]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], MainModule);
	    return MainModule;
	}());
	exports.MainModule = MainModule;


/***/ },
/* 25 */,
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.10
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(4), __webpack_require__(27), __webpack_require__(7), __webpack_require__(8), __webpack_require__(28)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));
	}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Base class for control directives.
	     *
	     * Only used internally in the forms module.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControlDirective = (function () {
	        function AbstractControlDirective() {
	        }
	        Object.defineProperty(AbstractControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('unimplemented'); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "value", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.value : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "invalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.invalid : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pending : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.errors : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.pristine : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.dirty : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.touched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.untouched : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "disabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.disabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "enabled", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.enabled : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "statusChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.statusChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "valueChanges", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.control ? this.control.valueChanges : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.reset = function (value) {
	            if (value === void 0) { value = undefined; }
	            if (this.control)
	                this.control.reset(value);
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.hasError(errorCode, path) : false;
	        };
	        /**
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControlDirective.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return this.control ? this.control.getError(errorCode, path) : null;
	        };
	        return AbstractControlDirective;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * A directive that contains multiple {\@link NgControl}s.
	     *
	     * Only used by the forms module.
	     *
	     * \@stable
	     */
	    var ControlContainer = (function (_super) {
	        __extends$1(ControlContainer, _super);
	        function ControlContainer() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(ControlContainer.prototype, "formDirective", {
	            /**
	             * Get the form to which this container belongs.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ControlContainer.prototype, "path", {
	            /**
	             * Get the path to this container.
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        return ControlContainer;
	    }(AbstractControlDirective));
	
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }
	
	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	
	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;
	    var /** @type {?} */ isObservable = _angular_core.__core_private__.isObservable;
	
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function isEmptyInputValue(value) {
	        // we don't check for string here so it also works with arrays
	        return value == null || value.length === 0;
	    }
	    /**
	     * Providers for validators to be used for {@link FormControl}s in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * ### Example
	     *
	     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	     * @stable
	     */
	    var /** @type {?} */ NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');
	    /**
	     * Providers for asynchronous validators to be used for {@link FormControl}s
	     * in a form.
	     *
	     * Provide this using `multi: true` to add validators.
	     *
	     * See {@link NG_VALIDATORS} for more details.
	     *
	     * @stable
	     */
	    var /** @type {?} */ NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');
	    /**
	     * Provides a set of validators used by form controls.
	     *
	     * A validator is a function that processes a {\@link FormControl} or collection of
	     * controls and returns a map of errors. A null map means that validation has passed.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var loginControl = new FormControl("", Validators.required)
	     * ```
	     *
	     * \@stable
	     */
	    var Validators = (function () {
	        function Validators() {
	        }
	        /**
	         * Validator that requires controls to have a non-empty value.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.required = function (control) {
	            return isEmptyInputValue(control.value) ? { 'required': true } : null;
	        };
	        /**
	         * Validator that requires control value to be true.
	         * @param {?} control
	         * @return {?}
	         */
	        Validators.requiredTrue = function (control) {
	            return control.value === true ? null : { 'required': true };
	        };
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         * @param {?} minLength
	         * @return {?}
	         */
	        Validators.minLength = function (minLength) {
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length < minLength ?
	                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         * @param {?} maxLength
	         * @return {?}
	         */
	        Validators.maxLength = function (maxLength) {
	            return function (control) {
	                var /** @type {?} */ length = control.value ? control.value.length : 0;
	                return length > maxLength ?
	                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :
	                    null;
	            };
	        };
	        /**
	         * Validator that requires a control to match a regex to its value.
	         * @param {?} pattern
	         * @return {?}
	         */
	        Validators.pattern = function (pattern) {
	            if (!pattern)
	                return Validators.nullValidator;
	            var /** @type {?} */ regex;
	            var /** @type {?} */ regexStr;
	            if (typeof pattern === 'string') {
	                regexStr = "^" + pattern + "$";
	                regex = new RegExp(regexStr);
	            }
	            else {
	                regexStr = pattern.toString();
	                regex = pattern;
	            }
	            return function (control) {
	                if (isEmptyInputValue(control.value)) {
	                    return null; // don't validate empty values to allow optional controls
	                }
	                var /** @type {?} */ value = control.value;
	                return regex.test(value) ? null :
	                    { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
	            };
	        };
	        /**
	         * No-op validator.
	         * @param {?} c
	         * @return {?}
	         */
	        Validators.nullValidator = function (c) { return null; };
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.compose = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        };
	        /**
	         * @param {?} validators
	         * @return {?}
	         */
	        Validators.composeAsync = function (validators) {
	            if (!validators)
	                return null;
	            var /** @type {?} */ presentValidators = validators.filter(isPresent);
	            if (presentValidators.length == 0)
	                return null;
	            return function (control) {
	                var /** @type {?} */ promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return Promise.all(promises).then(_mergeErrors);
	            };
	        };
	        return Validators;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function _convertToPromise(obj) {
	        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} control
	     * @param {?} validators
	     * @return {?}
	     */
	    function _executeAsyncValidators(control, validators) {
	        return validators.map(function (v) { return v(control); });
	    }
	    /**
	     * @param {?} arrayOfErrors
	     * @return {?}
	     */
	    function _mergeErrors(arrayOfErrors) {
	        var /** @type {?} */ res = arrayOfErrors.reduce(function (res, errors) {
	            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
	        }, {});
	        return Object.keys(res).length === 0 ? null : res;
	    }
	
	    /**
	     * Used to provide a {@link ControlValueAccessor} for form controls.
	     *
	     * See {@link DefaultValueAccessor} for how to implement one.
	     * @stable
	     */
	    var /** @type {?} */ NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');
	
	    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),
	        multi: true,
	    };
	    /**
	     * The accessor for writing a value and listening to changes on a checkbox input element.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="checkbox" name="rememberLogin" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var CheckboxControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function CheckboxControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        CheckboxControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	                        providers: [CHECKBOX_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return CheckboxControlValueAccessor;
	    }());
	
	    var /** @type {?} */ DEFAULT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The default accessor for writing a value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="text" name="searchQuery" ngModel>
	     *  ```
	     *
	     *  \@stable
	     */
	    var DefaultValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function DefaultValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.writeValue = function (value) {
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        DefaultValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	                        // TODO: vsavkin replace the above selector with the one below it once
	                        // https://github.com/angular/angular/issues/3011 is implemented
	                        // selector: '[ngControl],[ngModel],[ngFormControl]',
	                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [DEFAULT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        DefaultValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return DefaultValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function normalizeAsyncValidator(validator) {
	        if (((validator)).validate) {
	            return function (c) { return ((validator)).validate(c); };
	        }
	        else {
	            return (validator);
	        }
	    }
	
	    var /** @type {?} */ NUMBER_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a number value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="number" [(ngModel)]="age">
	     *  ```
	     */
	    var NumberValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function NumberValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.writeValue = function (value) {
	            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
	            var /** @type {?} */ normalizedValue = value == null ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        NumberValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [NUMBER_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        NumberValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return NumberValueAccessor;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @return {?}
	     */
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * A base class that all control directive extend.
	     * It binds a {\@link FormControl} object to a DOM element.
	     *
	     * Used internally by Angular forms.
	     *
	     * \@stable
	     * @abstract
	     */
	    var NgControl = (function (_super) {
	        __extends$2(NgControl, _super);
	        function NgControl() {
	            _super.apply(this, arguments);
	            /** @internal */
	            this._parent = null;
	            this.name = null;
	            this.valueAccessor = null;
	            /** @internal */
	            this._rawValidators = [];
	            /** @internal */
	            this._rawAsyncValidators = [];
	        }
	        Object.defineProperty(NgControl.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgControl.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgControl.prototype.viewToModelUpdate = function (newValue) { };
	        return NgControl;
	    }(AbstractControlDirective));
	
	    var /** @type {?} */ RADIO_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * Internal class used by Angular to uncheck radio buttons with the matching name.
	     */
	    var RadioControlRegistry = (function () {
	        function RadioControlRegistry() {
	            this._accessors = [];
	        }
	        /**
	         * @param {?} control
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.add = function (control, accessor) {
	            this._accessors.push([control, accessor]);
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.remove = function (accessor) {
	            for (var /** @type {?} */ i = this._accessors.length - 1; i >= 0; --i) {
	                if (this._accessors[i][1] === accessor) {
	                    this._accessors.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        /**
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype.select = function (accessor) {
	            var _this = this;
	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        };
	        /**
	         * @param {?} controlPair
	         * @param {?} accessor
	         * @return {?}
	         */
	        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {
	            if (!controlPair[0].control)
	                return false;
	            return controlPair[0]._parent === accessor._control._parent &&
	                controlPair[1].name === accessor.name;
	        };
	        RadioControlRegistry.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        RadioControlRegistry.ctorParameters = function () { return []; };
	        return RadioControlRegistry;
	    }());
	    /**
	     * \@whatItDoes Writes radio control values and listens to radio control changes.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any radio control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use radio buttons with form directives
	     *
	     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons
	     * in the same group have the same `name` attribute.  Radio buttons with different `name`
	     * attributes do not affect each other.
	     *
	     * {\@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}
	     *
	     * When using radio buttons in a reactive form, radio buttons in the same group should have the
	     * same `formControlName`. You can also add a `name` attribute, but it's optional.
	     *
	     * {\@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  \@stable
	     */
	    var RadioControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         * @param {?} _registry
	         * @param {?} _injector
	         */
	        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this._registry = _registry;
	            this._injector = _injector;
	            this.onChange = function () { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnInit = function () {
	            this._control = this._injector.get(NgControl);
	            this._checkName();
	            this._registry.add(this._control, this);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.writeValue = function (value) {
	            this._state = value === this.value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this.value);
	                _this._registry.select(_this);
	            };
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._checkName = function () {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName)
	                this.name = this.formControlName;
	        };
	        /**
	         * @return {?}
	         */
	        RadioControlValueAccessor.prototype._throwNameError = function () {
	            throw new Error("\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    ");
	        };
	        RadioControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	                        providers: [RADIO_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RadioControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	            { type: RadioControlRegistry, },
	            { type: _angular_core.Injector, },
	        ]; };
	        RadioControlValueAccessor.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'formControlName': [{ type: _angular_core.Input },],
	            'value': [{ type: _angular_core.Input },],
	        };
	        return RadioControlValueAccessor;
	    }());
	
	    var /** @type {?} */ RANGE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return RangeValueAccessor; }),
	        multi: true
	    };
	    /**
	     * The accessor for writing a range value and listening to changes that is used by the
	     * {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName} directives.
	     *
	     *  ### Example
	     *  ```
	     *  <input type="range" [(ngModel)]="age" >
	     *  ```
	     */
	    var RangeValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function RangeValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.writeValue = function (value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', parseFloat(value));
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnChange = function (fn) {
	            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        RangeValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        RangeValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
	                        host: {
	                            '(change)': 'onChange($event.target.value)',
	                            '(input)': 'onChange($event.target.value)',
	                            '(blur)': 'onTouched()'
	                        },
	                        providers: [RANGE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        RangeValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return RangeValueAccessor;
	    }());
	
	    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString(id, value) {
	        if (id == null)
	            return "" + value;
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * \@whatItDoes Writes values and listens to changes on a select element.
	     *
	     * Used by {\@link NgModel}, {\@link FormControlDirective}, and {\@link FormControlName}
	     * to keep the view synced with the {\@link FormControl} model.
	     *
	     * \@howToUse
	     *
	     * If you have imported the {\@link FormsModule} or the {\@link ReactiveFormsModule}, this
	     * value accessor will be active on any select control that has a form directive. You do
	     * **not** need to add a special selector to activate it.
	     *
	     * ### How to use select controls with form directives
	     *
	     * To use a select in a template-driven form, simply add an `ngModel` and a `name`
	     * attribute to the main `<select>` tag.
	     *
	     * If your option values are simple strings, you can bind to the normal `value` property
	     * on the option.  If your option values happen to be objects (and you'd like to save the
	     * selection in your form as an object), use `ngValue` instead:
	     *
	     * {\@example forms/ts/selectControl/select_control_example.ts region='Component'}
	     *
	     * In reactive forms, you'll also want to add your form directive (`formControlName` or
	     * `formControl`) on the main `<select>` tag. Like in the former example, you have the
	     * choice of binding to the  `value` or `ngValue` property on the select's options.
	     *
	     * {\@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
	     *
	     * Note: We listen to the 'change' event because 'input' events aren't fired
	     * for selects in Firefox and IE:
	     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350
	     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var SelectControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.writeValue = function (value) {
	            this.value = value;
	            var /** @type {?} */ id = this._getOptionId(value);
	            if (id == null) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'selectedIndex', -1);
	            }
	            var /** @type {?} */ valueString = _buildValueString(id, value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id), value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
	        };
	        SelectControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectControlValueAccessor;
	    }());
	    /**
	     * \@whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * \@howToUse
	     *
	     * See docs for {\@link SelectControlValueAccessor} for usage examples.
	     *
	     * \@stable
	     */
	    var NgSelectOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select)
	                this.id = this._select._registerOption();
	        }
	        Object.defineProperty(NgSelectOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._select._optionMap.set(this.id, value);
	                this._setElementValue(_buildValueString(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._setElementValue(value);
	                if (this._select)
	                    this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectOption;
	    }());
	
	    var /** @type {?} */ SELECT_MULTIPLE_VALUE_ACCESSOR = {
	        provide: NG_VALUE_ACCESSOR,
	        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),
	        multi: true
	    };
	    /**
	     * @param {?} id
	     * @param {?} value
	     * @return {?}
	     */
	    function _buildValueString$1(id, value) {
	        if (id == null)
	            return "" + value;
	        if (typeof value === 'string')
	            value = "'" + value + "'";
	        if (!isPrimitive(value))
	            value = 'Object';
	        return (id + ": " + value).slice(0, 50);
	    }
	    /**
	     * @param {?} valueString
	     * @return {?}
	     */
	    function _extractId$1(valueString) {
	        return valueString.split(':')[0];
	    }
	    /**
	     * The accessor for writing a value and listening to changes on a select element.
	     *
	     * \@stable
	     */
	    var SelectMultipleControlValueAccessor = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} _elementRef
	         */
	        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
	            this._renderer = _renderer;
	            this._elementRef = _elementRef;
	            /** @internal */
	            this._optionMap = new Map();
	            /** @internal */
	            this._idCounter = 0;
	            this.onChange = function (_) { };
	            this.onTouched = function () { };
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
	            var _this = this;
	            this.value = value;
	            var /** @type {?} */ optionSelectedStateSetter;
	            if (Array.isArray(value)) {
	                // convert values to ids
	                var /** @type {?} */ ids_1 = value.map(function (v) { return _this._getOptionId(v); });
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(ids_1.indexOf(o.toString()) > -1); };
	            }
	            else {
	                optionSelectedStateSetter = function (opt, o) { opt._setSelected(false); };
	            }
	            this._optionMap.forEach(optionSelectedStateSetter);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
	            var _this = this;
	            this.onChange = function (_) {
	                var /** @type {?} */ selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var /** @type {?} */ options = _.selectedOptions;
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                }
	                else {
	                    var /** @type {?} */ options = (_.options);
	                    for (var /** @type {?} */ i = 0; i < options.length; i++) {
	                        var /** @type {?} */ opt = options.item(i);
	                        if (opt.selected) {
	                            var /** @type {?} */ val = _this._getOptionValue(opt.value);
	                            selected.push(val);
	                        }
	                    }
	                }
	                _this.value = selected;
	                fn(selected);
	            };
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	        /**
	         * @param {?} isDisabled
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
	            var /** @type {?} */ id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
	            for (var _i = 0, _a = Array.from(this._optionMap.keys()); _i < _a.length; _i++) {
	                var id = _a[_i];
	                if (looseIdentical(this._optionMap.get(id)._value, value))
	                    return id;
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} valueString
	         * @return {?}
	         */
	        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
	            var /** @type {?} */ id = _extractId$1(valueString);
	            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
	        };
	        SelectMultipleControlValueAccessor.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	                    },] },
	        ];
	        /** @nocollapse */
	        SelectMultipleControlValueAccessor.ctorParameters = function () { return [
	            { type: _angular_core.Renderer, },
	            { type: _angular_core.ElementRef, },
	        ]; };
	        return SelectMultipleControlValueAccessor;
	    }());
	    /**
	     * Marks `<option>` as dynamic, so Angular can be notified when options change.
	     *
	     * ### Example
	     *
	     * ```
	     * <select multiple name="city" ngModel>
	     *   <option *ngFor="let c of cities" [value]="c"></option>
	     * </select>
	     * ```
	     */
	    var NgSelectMultipleOption = (function () {
	        /**
	         * @param {?} _element
	         * @param {?} _renderer
	         * @param {?} _select
	         */
	        function NgSelectMultipleOption(_element, _renderer, _select) {
	            this._element = _element;
	            this._renderer = _renderer;
	            this._select = _select;
	            if (this._select) {
	                this.id = this._select._registerOption(this);
	            }
	        }
	        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select == null)
	                    return;
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (this._select) {
	                    this._value = value;
	                    this._setElementValue(_buildValueString$1(this.id, value));
	                    this._select.writeValue(this._select.value);
	                }
	                else {
	                    this._setElementValue(value);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setElementValue = function (value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        };
	        /**
	         * \@internal
	         * @param {?} selected
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype._setSelected = function (selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        };
	        /**
	         * @return {?}
	         */
	        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
	            if (this._select) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        };
	        NgSelectMultipleOption.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: 'option' },] },
	        ];
	        /** @nocollapse */
	        NgSelectMultipleOption.ctorParameters = function () { return [
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	        ]; };
	        NgSelectMultipleOption.propDecorators = {
	            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],
	            'value': [{ type: _angular_core.Input, args: ['value',] },],
	        };
	        return NgSelectMultipleOption;
	    }());
	
	    /**
	     * @param {?} name
	     * @param {?} parent
	     * @return {?}
	     */
	    function controlPath(name, parent) {
	        return parent.path.concat([name]);
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpControl(control, dir) {
	        if (!control)
	            _throwError(dir, 'Cannot find control with');
	        if (!dir.valueAccessor)
	            _throwError(dir, 'No value accessor for form control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	        dir.valueAccessor.writeValue(control.value);
	        // view -> model
	        dir.valueAccessor.registerOnChange(function (newValue) {
	            dir.viewToModelUpdate(newValue);
	            control.markAsDirty();
	            control.setValue(newValue, { emitModelToViewChange: false });
	        });
	        // touched
	        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });
	        control.registerOnChange(function (newValue, emitModelEvent) {
	            // control -> view
	            dir.valueAccessor.writeValue(newValue);
	            // control -> ngModel
	            if (emitModelEvent)
	                dir.viewToModelUpdate(newValue);
	        });
	        if (dir.valueAccessor.setDisabledState) {
	            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });
	        }
	        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
	        dir._rawValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (((validator)).registerOnValidatorChange)
	                ((validator)).registerOnValidatorChange(function () { return control.updateValueAndValidity(); });
	        });
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function cleanUpControl(control, dir) {
	        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });
	        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });
	        dir._rawValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        dir._rawAsyncValidators.forEach(function (validator) {
	            if (validator.registerOnValidatorChange) {
	                validator.registerOnValidatorChange(null);
	            }
	        });
	        if (control)
	            control._clearChangeFns();
	    }
	    /**
	     * @param {?} control
	     * @param {?} dir
	     * @return {?}
	     */
	    function setUpFormContainer(control, dir) {
	        if (isBlank(control))
	            _throwError(dir, 'Cannot find control with');
	        control.validator = Validators.compose([control.validator, dir.validator]);
	        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    }
	    /**
	     * @param {?} dir
	     * @return {?}
	     */
	    function _noControlError(dir) {
	        return _throwError(dir, 'There is no FormControl instance attached to form control element with');
	    }
	    /**
	     * @param {?} dir
	     * @param {?} message
	     * @return {?}
	     */
	    function _throwError(dir, message) {
	        var /** @type {?} */ messageEnd;
	        if (dir.path.length > 1) {
	            messageEnd = "path: '" + dir.path.join(' -> ') + "'";
	        }
	        else if (dir.path[0]) {
	            messageEnd = "name: '" + dir.path + "'";
	        }
	        else {
	            messageEnd = 'unspecified name attribute';
	        }
	        throw new Error(message + " " + messageEnd);
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeValidators(validators) {
	        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	    }
	    /**
	     * @param {?} validators
	     * @return {?}
	     */
	    function composeAsyncValidators(validators) {
	        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :
	            null;
	    }
	    /**
	     * @param {?} changes
	     * @param {?} viewModel
	     * @return {?}
	     */
	    function isPropertyUpdated(changes, viewModel) {
	        if (!changes.hasOwnProperty('model'))
	            return false;
	        var /** @type {?} */ change = changes['model'];
	        if (change.isFirstChange())
	            return true;
	        return !looseIdentical(viewModel, change.currentValue);
	    }
	    var /** @type {?} */ BUILTIN_ACCESSORS = [
	        CheckboxControlValueAccessor,
	        RangeValueAccessor,
	        NumberValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	    ];
	    /**
	     * @param {?} valueAccessor
	     * @return {?}
	     */
	    function isBuiltInAccessor(valueAccessor) {
	        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });
	    }
	    /**
	     * @param {?} dir
	     * @param {?} valueAccessors
	     * @return {?}
	     */
	    function selectValueAccessor(dir, valueAccessors) {
	        if (!valueAccessors)
	            return null;
	        var /** @type {?} */ defaultAccessor;
	        var /** @type {?} */ builtinAccessor;
	        var /** @type {?} */ customAccessor;
	        valueAccessors.forEach(function (v) {
	            if (v.constructor === DefaultValueAccessor) {
	                defaultAccessor = v;
	            }
	            else if (isBuiltInAccessor(v)) {
	                if (builtinAccessor)
	                    _throwError(dir, 'More than one built-in value accessor matches form control with');
	                builtinAccessor = v;
	            }
	            else {
	                if (customAccessor)
	                    _throwError(dir, 'More than one custom value accessor matches form control with');
	                customAccessor = v;
	            }
	        });
	        if (customAccessor)
	            return customAccessor;
	        if (builtinAccessor)
	            return builtinAccessor;
	        if (defaultAccessor)
	            return defaultAccessor;
	        _throwError(dir, 'No valid value accessor for form control with');
	        return null;
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * This is a base class for code shared between {\@link NgModelGroup} and {\@link FormGroupName}.
	     *
	     * \@stable
	     */
	    var AbstractFormGroupDirective = (function (_super) {
	        __extends(AbstractFormGroupDirective, _super);
	        function AbstractFormGroupDirective() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormGroup(this);
	        };
	        /**
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormGroup(this);
	            }
	        };
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "control", {
	            /**
	             * Get the {\@link FormGroup} backing this binding.
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormGroup(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "path", {
	            /**
	             * Get the path to this control group.
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "formDirective", {
	            /**
	             * Get the {\@link Form} to which this group belongs.
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractFormGroupDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractFormGroupDirective.prototype._checkParentType = function () { };
	        return AbstractFormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var AbstractControlStatus = (function () {
	        /**
	         * @param {?} cd
	         */
	        function AbstractControlStatus(cd) {
	            this._cd = cd;
	        }
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassUntouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.untouched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassTouched", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.touched : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPristine", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pristine : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.dirty : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassValid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.valid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassInvalid", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.invalid : false; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControlStatus.prototype, "ngClassPending", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._cd.control ? this._cd.control.pending : false; },
	            enumerable: true,
	            configurable: true
	        });
	        return AbstractControlStatus;
	    }());
	    var /** @type {?} */ ngControlStatusHost = {
	        '[class.ng-untouched]': 'ngClassUntouched',
	        '[class.ng-touched]': 'ngClassTouched',
	        '[class.ng-pristine]': 'ngClassPristine',
	        '[class.ng-dirty]': 'ngClassDirty',
	        '[class.ng-valid]': 'ngClassValid',
	        '[class.ng-invalid]': 'ngClassInvalid',
	        '[class.ng-pending]': 'ngClassPending',
	    };
	    /**
	     * Directive automatically applied to Angular form controls that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatus = (function (_super) {
	        __extends$3(NgControlStatus, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatus(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatus.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },
	        ];
	        /** @nocollapse */
	        NgControlStatus.ctorParameters = function () { return [
	            { type: NgControl, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatus;
	    }(AbstractControlStatus));
	    /**
	     * Directive automatically applied to Angular form groups that sets CSS classes
	     * based on control status (valid/invalid/dirty/etc).
	     *
	     * \@stable
	     */
	    var NgControlStatusGroup = (function (_super) {
	        __extends$3(NgControlStatusGroup, _super);
	        /**
	         * @param {?} cd
	         */
	        function NgControlStatusGroup(cd) {
	            _super.call(this, cd);
	        }
	        NgControlStatusGroup.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
	                        host: ngControlStatusHost
	                    },] },
	        ];
	        /** @nocollapse */
	        NgControlStatusGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },
	        ]; };
	        return NgControlStatusGroup;
	    }(AbstractControlStatus));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * \@Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   \@Output() open: EventEmitter<any> = new EventEmitter();
	     *   \@Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * \@stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$5(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         * @param {?=} isAsync
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        /**
	         * @param {?=} generatorOrNext
	         * @param {?=} error
	         * @param {?=} complete
	         * @return {?}
	         */
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var /** @type {?} */ schedulerFn;
	            var /** @type {?} */ errorFn = function (err) { return null; };
	            var /** @type {?} */ completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	     */
	    var /** @type {?} */ VALID = 'VALID';
	    /**
	     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	     */
	    var /** @type {?} */ INVALID = 'INVALID';
	    /**
	     * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	     * errors are not yet available for the input value.
	     */
	    var /** @type {?} */ PENDING = 'PENDING';
	    /**
	     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor
	     * calculations of validity or value.
	     */
	    var /** @type {?} */ DISABLED = 'DISABLED';
	    /**
	     * @param {?} control
	     * @param {?} path
	     * @param {?} delimiter
	     * @return {?}
	     */
	    function _find(control, path, delimiter) {
	        if (path == null)
	            return null;
	        if (!(path instanceof Array)) {
	            path = ((path)).split(delimiter);
	        }
	        if (path instanceof Array && (path.length === 0))
	            return null;
	        return ((path)).reduce(function (v, name) {
	            if (v instanceof FormGroup) {
	                return v.controls[name] || null;
	            }
	            if (v instanceof FormArray) {
	                return v.at(/** @type {?} */ (name)) || null;
	            }
	            return null;
	        }, control);
	    }
	    /**
	     * @param {?} r
	     * @return {?}
	     */
	    function toObservable(r) {
	        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;
	    }
	    /**
	     * @param {?} validator
	     * @return {?}
	     */
	    function coerceToValidator(validator) {
	        return Array.isArray(validator) ? composeValidators(validator) : validator;
	    }
	    /**
	     * @param {?} asyncValidator
	     * @return {?}
	     */
	    function coerceToAsyncValidator(asyncValidator) {
	        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;
	    }
	    /**
	     * \@whatItDoes This is the base class for {\@link FormControl}, {\@link FormGroup}, and
	     * {\@link FormArray}.
	     *
	     * It provides some of the shared behavior that all controls and groups of controls have, like
	     * running validators, calculating status, and resetting state. It also defines the properties
	     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
	     * instantiated directly.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AbstractControl = (function () {
	        /**
	         * @param {?} validator
	         * @param {?} asyncValidator
	         */
	        function AbstractControl(validator, asyncValidator) {
	            this.validator = validator;
	            this.asyncValidator = asyncValidator;
	            /** @internal */
	            this._onCollectionChange = function () { };
	            this._pristine = true;
	            this._touched = false;
	            /** @internal */
	            this._onDisabledChange = [];
	        }
	        Object.defineProperty(AbstractControl.prototype, "value", {
	            /**
	             * The value of the control.
	             * @return {?}
	             */
	            get: function () { return this._value; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "parent", {
	            /**
	             * The parent control.
	             * @return {?}
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "status", {
	            /**
	             * The validation status of the control. There are four possible
	             * validation statuses:
	             *
	             * * **VALID**:  control has passed all validation checks
	             * * **INVALID**: control has failed at least one validation check
	             * * **PENDING**: control is in the midst of conducting a validation check
	             * * **DISABLED**: control is exempt from validation checks
	             *
	             * These statuses are mutually exclusive, so a control cannot be
	             * both valid AND invalid or invalid AND disabled.
	             * @return {?}
	             */
	            get: function () { return this._status; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valid", {
	            /**
	             * A control is `valid` when its `status === VALID`.
	             *
	             * In order to have this status, the control must have passed all its
	             * validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === VALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "invalid", {
	            /**
	             * A control is `invalid` when its `status === INVALID`.
	             *
	             * In order to have this status, the control must have failed
	             * at least one of its validation checks.
	             * @return {?}
	             */
	            get: function () { return this._status === INVALID; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pending", {
	            /**
	             * A control is `pending` when its `status === PENDING`.
	             *
	             * In order to have this status, the control must be in the
	             * middle of conducting a validation check.
	             * @return {?}
	             */
	            get: function () { return this._status == PENDING; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "disabled", {
	            /**
	             * A control is `disabled` when its `status === DISABLED`.
	             *
	             * Disabled controls are exempt from validation checks and
	             * are not included in the aggregate value of their ancestor
	             * controls.
	             * @return {?}
	             */
	            get: function () { return this._status === DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "enabled", {
	            /**
	             * A control is `enabled` as long as its `status !== DISABLED`.
	             *
	             * In other words, it has a status of `VALID`, `INVALID`, or
	             * `PENDING`.
	             * @return {?}
	             */
	            get: function () { return this._status !== DISABLED; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "errors", {
	            /**
	             * Returns any errors generated by failing validation. If there
	             * are no errors, it will return null.
	             * @return {?}
	             */
	            get: function () { return this._errors; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "pristine", {
	            /**
	             * A control is `pristine` if the user has not yet changed
	             * the value in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return this._pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "dirty", {
	            /**
	             * A control is `dirty` if the user has changed the value
	             * in the UI.
	             *
	             * Note that programmatic changes to a control's value will
	             * *not* mark it dirty.
	             * @return {?}
	             */
	            get: function () { return !this.pristine; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "touched", {
	            /**
	             * A control is marked `touched` once the user has triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "untouched", {
	            /**
	             * A control is `untouched` if the user has not yet triggered
	             * a `blur` event on it.
	             * @return {?}
	             */
	            get: function () { return !this._touched; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	            /**
	             * Emits an event every time the value of the control changes, in
	             * the UI or programmatically.
	             * @return {?}
	             */
	            get: function () { return this._valueChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AbstractControl.prototype, "statusChanges", {
	            /**
	             * Emits an event every time the validation status of the control
	             * is re-calculated.
	             * @return {?}
	             */
	            get: function () { return this._statusChanges; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Sets the synchronous validators that are active on this control.  Calling
	         * this will overwrite any existing sync validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setValidators = function (newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        };
	        /**
	         * Sets the async validators that are active on this control. Calling this
	         * will overwrite any existing async validators.
	         * @param {?} newValidator
	         * @return {?}
	         */
	        AbstractControl.prototype.setAsyncValidators = function (newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        };
	        /**
	         * Empties out the sync validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearValidators = function () { this.validator = null; };
	        /**
	         * Empties out the async validator list.
	         * @return {?}
	         */
	        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };
	        /**
	         * Marks the control as `touched`.
	         *
	         * This will also mark all direct ancestors as `touched` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = true;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `untouched`.
	         *
	         * If the control has any children, it will also mark all children as `untouched`
	         * to maintain the model, and re-calculate the `touched` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsUntouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = false;
	            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `dirty`.
	         *
	         * This will also mark all direct ancestors as `dirty` to maintain
	         * the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsDirty = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = false;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pristine`.
	         *
	         * If the control has any children, it will also mark all children as `pristine`
	         * to maintain the model, and re-calculate the `pristine` status of all parent
	         * controls.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = true;
	            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Marks the control as `pending`.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.markAsPending = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._status = PENDING;
	            if (this._parent && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * Disables the control. This means the control will be exempt from validation checks and
	         * excluded from the aggregate value of any parent. Its status is `DISABLED`.
	         *
	         * If the control has children, all children will be disabled to maintain the model.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.disable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = DISABLED;
	            this._errors = null;
	            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });
	            this._updateValue();
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });
	        };
	        /**
	         * Enables the control. This means the control will be included in validation checks and
	         * the aggregate value of its parent. Its status is re-calculated based on its value and
	         * its validators.
	         *
	         * If the control has children, all children will be enabled.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.enable = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._status = VALID;
	            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	            this._updateAncestors(onlySelf);
	            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });
	        };
	        /**
	         * @param {?} onlySelf
	         * @return {?}
	         */
	        AbstractControl.prototype._updateAncestors = function (onlySelf) {
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity();
	                this._parent._updatePristine();
	                this._parent._updateTouched();
	            }
	        };
	        /**
	         * @param {?} parent
	         * @return {?}
	         */
	        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	        /**
	         * Sets the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.setValue = function (value, options) { };
	        /**
	         * Patches the value of the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.patchValue = function (value, options) { };
	        /**
	         * Resets the control. Abstract method (implemented in sub-classes).
	         * @abstract
	         * @param {?=} value
	         * @param {?=} options
	         * @return {?}
	         */
	        AbstractControl.prototype.reset = function (value, options) { };
	        /**
	         * Re-calculates the value and validation status of the control.
	         *
	         * By default, it will also update the value and validity of its ancestors.
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype.updateValueAndValidity = function (_a) {
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._setInitialStatus();
	            this._updateValue();
	            if (this.enabled) {
	                this._errors = this._runValidator();
	                this._status = this._calculateStatus();
	                if (this._status === VALID || this._status === PENDING) {
	                    this._runAsyncValidator(emitEvent);
	                }
	            }
	            if (emitEvent !== false) {
	                this._valueChanges.emit(this._value);
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTreeValidity = function (_a) {
	            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;
	            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._runValidator = function () {
	            return this.validator ? this.validator(this) : null;
	        };
	        /**
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {
	            var _this = this;
	            if (this.asyncValidator) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var /** @type {?} */ obs = toObservable(this.asyncValidator(this));
	                if (!(isObservable(obs))) {
	                    throw new Error("expected the following validator to return Promise or Observable: " + this.asyncValidator + ". If you are using FormBuilder; did you forget to brace your validators in an array?");
	                }
	                this._asyncValidationSubscription =
	                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._cancelExistingSubscription = function () {
	            if (this._asyncValidationSubscription) {
	                this._asyncValidationSubscription.unsubscribe();
	            }
	        };
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run manually by the user, rather than automatically.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ### Example
	         *
	         * ```
	         * const login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.setValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         * @param {?} errors
	         * @param {?=} __1
	         * @return {?}
	         */
	        AbstractControl.prototype.setErrors = function (errors, _a) {
	            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent !== false);
	        };
	        /**
	         * Retrieves a child control given the control's name or path.
	         *
	         * Paths can be passed in as an array or a string delimited by a dot.
	         *
	         * To get a control nested within a `person` sub-group:
	         *
	         * * `this.form.get('person.name');`
	         *
	         * -OR-
	         *
	         * * `this.form.get(['person', 'name']);`
	         * @param {?} path
	         * @return {?}
	         */
	        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns null or undefined.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.getError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            var /** @type {?} */ control = path ? this.get(path) : this;
	            return control && control._errors ? control._errors[errorCode] : null;
	        };
	        /**
	         * Returns true if the control with the given path has the error specified. Otherwise
	         * returns false.
	         *
	         * If no path is given, it checks for the error on the present control.
	         * @param {?} errorCode
	         * @param {?=} path
	         * @return {?}
	         */
	        AbstractControl.prototype.hasError = function (errorCode, path) {
	            if (path === void 0) { path = null; }
	            return !!this.getError(errorCode, path);
	        };
	        Object.defineProperty(AbstractControl.prototype, "root", {
	            /**
	             * Retrieves the top-level ancestor of this control.
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ x = this;
	                while (x._parent) {
	                    x = x._parent;
	                }
	                return x;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @param {?} emitEvent
	         * @return {?}
	         */
	        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                this._statusChanges.emit(this._status);
	            }
	            if (this._parent) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._initObservables = function () {
	            this._valueChanges = new EventEmitter();
	            this._statusChanges = new EventEmitter();
	        };
	        /**
	         * @return {?}
	         */
	        AbstractControl.prototype._calculateStatus = function () {
	            if (this._allControlsDisabled())
	                return DISABLED;
	            if (this._errors)
	                return INVALID;
	            if (this._anyControlsHaveStatus(PENDING))
	                return PENDING;
	            if (this._anyControlsHaveStatus(INVALID))
	                return INVALID;
	            return VALID;
	        };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} cb
	         * @return {?}
	         */
	        AbstractControl.prototype._forEachChild = function (cb) { };
	        /**
	         * \@internal
	         * @abstract
	         * @param {?} condition
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControls = function (condition) { };
	        /**
	         * \@internal
	         * @abstract
	         * @return {?}
	         */
	        AbstractControl.prototype._allControlsDisabled = function () { };
	        /**
	         * \@internal
	         * @param {?} status
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsHaveStatus = function (status) {
	            return this._anyControls(function (control) { return control.status === status; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsDirty = function () {
	            return this._anyControls(function (control) { return control.dirty; });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        AbstractControl.prototype._anyControlsTouched = function () {
	            return this._anyControls(function (control) { return control.touched; });
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updatePristine = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._pristine = !this._anyControlsDirty();
	            if (this._parent && !onlySelf) {
	                this._parent._updatePristine({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?=} __0
	         * @return {?}
	         */
	        AbstractControl.prototype._updateTouched = function (_a) {
	            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	            this._touched = this._anyControlsTouched();
	            if (this._parent && !onlySelf) {
	                this._parent._updateTouched({ onlySelf: onlySelf });
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} formState
	         * @return {?}
	         */
	        AbstractControl.prototype._isBoxedValue = function (formState) {
	            return typeof formState === 'object' && formState !== null &&
	                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
	        };
	        /**
	         * \@internal
	         * @param {?} fn
	         * @return {?}
	         */
	        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };
	        return AbstractControl;
	    }());
	    /**
	     * \@whatItDoes Tracks the value and validation status of an individual form control.
	     *
	     * It is one of the three fundamental building blocks of Angular forms, along with
	     * {\@link FormGroup} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormControl}, you can pass in an initial value as the
	     * first argument. Example:
	     *
	     * ```ts
	     * const ctrl = new FormControl('some value');
	     * console.log(ctrl.value);     // 'some value'
	     * ```
	     *
	     * You can also initialize the control with a form state object on instantiation,
	     * which includes both the value and whether or not the control is disabled.
	     * You can't use the value key without the disabled key; both are required
	     * to use this way of initialization.
	     *
	     * ```ts
	     * const ctrl = new FormControl({value: 'n/a', disabled: true});
	     * console.log(ctrl.value);     // 'n/a'
	     * console.log(ctrl.status);   // 'DISABLED'
	     * ```
	     *
	     * To include a sync validator (or an array of sync validators) with the control,
	     * pass it in as the second argument. Async validators are also supported, but
	     * have to be passed in separately as the third arg.
	     *
	     * ```ts
	     * const ctrl = new FormControl('', Validators.required);
	     * console.log(ctrl.value);     // ''
	     * console.log(ctrl.status);   // 'INVALID'
	     * ```
	     *
	     * See its superclass, {\@link AbstractControl}, for more properties and methods.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormControl = (function (_super) {
	        __extends$6(FormControl, _super);
	        /**
	         * @param {?=} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormControl(formState, validator, asyncValidator) {
	            if (formState === void 0) { formState = null; }
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));
	            /** @internal */
	            this._onChange = [];
	            this._applyFormState(formState);
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            this._initObservables();
	        }
	        /**
	         * Set the value of the form control to `value`.
	         *
	         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	         * and not its parent component. This defaults to false.
	         *
	         * If `emitEvent` is `true`, this
	         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults
	         * to true (as it falls through to `updateValueAndValidity`).
	         *
	         * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	         * specified.
	         *
	         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the
	         * model.  This is the default behavior if `emitViewToModelChange` is not specified.
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange !== false) {
	                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Patches the value of a control.
	         *
	         * This function is functionally the same as {\@link FormControl.setValue} at this level.
	         * It exists for symmetry with {\@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,
	         * where it does behave differently.
	         * @param {?} value
	         * @param {?=} options
	         * @return {?}
	         */
	        FormControl.prototype.patchValue = function (value, options) {
	            if (options === void 0) { options = {}; }
	            this.setValue(value, options);
	        };
	        /**
	         * Resets the form control. This means by default:
	         *
	         * * it is marked as `pristine`
	         * * it is marked as `untouched`
	         * * value is set to null
	         *
	         * You can also reset to a specific form state by passing through a standalone
	         * value or a form state object that contains both a value and a disabled state
	         * (these are the only two properties that cannot be calculated).
	         *
	         * Ex:
	         *
	         * ```ts
	         * this.control.reset('Nancy');
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * ```
	         *
	         * OR
	         *
	         * ```
	         * this.control.reset({value: 'Nancy', disabled: true});
	         *
	         * console.log(this.control.value);  // 'Nancy'
	         * console.log(this.control.status);  // 'DISABLED'
	         * ```
	         * @param {?=} formState
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormControl.prototype.reset = function (formState, _a) {
	            if (formState === void 0) { formState = null; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._applyFormState(formState);
	            this.markAsPristine({ onlySelf: onlySelf });
	            this.markAsUntouched({ onlySelf: onlySelf });
	            this.setValue(this._value, { onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._updateValue = function () { };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormControl.prototype._anyControls = function (condition) { return false; };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };
	        /**
	         * Register a listener for change events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormControl.prototype._clearChangeFns = function () {
	            this._onChange = [];
	            this._onDisabledChange = [];
	            this._onCollectionChange = function () { };
	        };
	        /**
	         * Register a listener for disabled events.
	         * @param {?} fn
	         * @return {?}
	         */
	        FormControl.prototype.registerOnDisabledChange = function (fn) {
	            this._onDisabledChange.push(fn);
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormControl.prototype._forEachChild = function (cb) { };
	        /**
	         * @param {?} formState
	         * @return {?}
	         */
	        FormControl.prototype._applyFormState = function (formState) {
	            if (this._isBoxedValue(formState)) {
	                this._value = formState.value;
	                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
	                    this.enable({ onlySelf: true, emitEvent: false });
	            }
	            else {
	                this._value = formState;
	            }
	        };
	        return FormControl;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of a group of {\@link FormControl}
	     * instances.
	     *
	     * A `FormGroup` aggregates the values of each child {\@link FormControl} into one object,
	     * with each control name as the key.  It calculates its status by reducing the statuses
	     * of its children. For example, if one of the controls in a group is invalid, the entire
	     * group becomes invalid.
	     *
	     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormArray}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormGroup}, pass in a collection of child controls as the first
	     * argument. The key for each child will be the name under which it is registered.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   first: new FormControl('Nancy', Validators.minLength(2)),
	     *   last: new FormControl('Drew'),
	     * });
	     *
	     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
	     * console.log(form.status);  // 'VALID'
	     * ```
	     *
	     * You can also include group-level validators as the second arg, or group-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Example
	     *
	     * ```
	     * const form = new FormGroup({
	     *   password: new FormControl('', Validators.minLength(2)),
	     *   passwordConfirm: new FormControl('', Validators.minLength(2)),
	     * }, passwordMatchValidator);
	     *
	     *
	     * function passwordMatchValidator(g: FormGroup) {
	     *    return g.get('password').value === g.get('passwordConfirm').value
	     *       ? null : {'mismatch': true};
	     * }
	     * ```
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormGroup = (function (_super) {
	        __extends$6(FormGroup, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormGroup(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Registers a control with the group's list of controls.
	         *
	         * This method does not update value or validity of the control, so for
	         * most cases you'll want to use {\@link FormGroup.addControl} instead.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.registerControl = function (name, control) {
	            if (this.controls[name])
	                return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	            return control;
	        };
	        /**
	         * Add a control to this group.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.addControl = function (name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove a control from this group.
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype.removeControl = function (name) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} name
	         * @param {?} control
	         * @return {?}
	         */
	        FormGroup.prototype.setControl = function (name, control) {
	            if (this.controls[name])
	                this.controls[name]._registerOnCollectionChange(function () { });
	            delete (this.controls[name]);
	            if (control)
	                this.registerControl(name, control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Check whether there is an enabled control with the given name in the group.
	         *
	         * It will return false for disabled controls. If you'd like to check for
	         * existence in the group only, use {\@link AbstractControl.get} instead.
	         * @param {?} controlName
	         * @return {?}
	         */
	        FormGroup.prototype.contains = function (controlName) {
	            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
	        };
	        /**
	         *  Sets the value of the {\@link FormGroup}. It accepts an object that matches
	         *  the structure of the group, with control names as keys.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.setValue({first: 'Nancy', last: 'Drew'});
	         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            Object.keys(value).forEach(function (name) {
	                _this._throwIfControlMissing(name);
	                _this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormGroup}. It accepts an object with control
	         *  names as keys, and will do its best to match the values to the correct controls
	         *  in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the group without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const form = new FormGroup({
	         *     first: new FormControl(),
	         *     last: new FormControl()
	         *  });
	         *  console.log(form.value);   // {first: null, last: null}
	         *
	         *  form.patchValue({first: 'Nancy'});
	         *  console.log(form.value);   // {first: 'Nancy', last: null}
	         *
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            Object.keys(value).forEach(function (name) {
	                if (_this.controls[name]) {
	                    _this.controls[name].patchValue(value[name], { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormGroup}. This means by default:
	         *
	         * * The group and all descendants are marked `pristine`
	         * * The group and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in a map of states
	         * that matches the structure of your form, with control names as keys. The state
	         * can be a standalone value or a form state object with both a value and a disabled
	         * status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.form.reset({first: 'name', last: 'last name'});
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.form.reset({
	         *   first: {value: 'name', disabled: true},
	         *   last: 'last'
	         * });
	         *
	         * console.log(this.form.value);  // {first: 'name', last: 'last name'}
	         * console.log(this.form.get('first').status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormGroup.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = {}; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, name) {
	                control.reset(value[name], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the {\@link FormGroup}, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the group.
	         * @return {?}
	         */
	        FormGroup.prototype.getRawValue = function () {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control instanceof FormControl ? control.value : ((control)).getRawValue();
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} name
	         * @return {?}
	         */
	        FormGroup.prototype._throwIfControlMissing = function (name) {
	            if (!Object.keys(this.controls).length) {
	                throw new Error("\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.controls[name]) {
	                throw new Error("Cannot find form control with name: " + name + ".");
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormGroup.prototype._forEachChild = function (cb) {
	            var _this = this;
	            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) {
	                control.setParent(_this);
	                control._registerOnCollectionChange(_this._onCollectionChange);
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormGroup.prototype._anyControls = function (condition) {
	            var _this = this;
	            var /** @type {?} */ res = false;
	            this._forEachChild(function (control, name) {
	                res = res || (_this.contains(name) && condition(control));
	            });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._reduceValue = function () {
	            var _this = this;
	            return this._reduceChildren({}, function (acc, control, name) {
	                if (control.enabled || _this.disabled) {
	                    acc[name] = control.value;
	                }
	                return acc;
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} initValue
	         * @param {?} fn
	         * @return {?}
	         */
	        FormGroup.prototype._reduceChildren = function (initValue, fn) {
	            var /** @type {?} */ res = initValue;
	            this._forEachChild(function (control, name) { res = fn(res, control, name); });
	            return res;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroup.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {
	                var controlName = _a[_i];
	                if (this.controls[controlName].enabled) {
	                    return false;
	                }
	            }
	            return Object.keys(this.controls).length > 0 || this.disabled;
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroup.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, name) {
	                if (value[name] === undefined) {
	                    throw new Error("Must supply a value for form control with name: '" + name + "'.");
	                }
	            });
	        };
	        return FormGroup;
	    }(AbstractControl));
	    /**
	     * \@whatItDoes Tracks the value and validity state of an array of {\@link FormControl},
	     * {\@link FormGroup} or {\@link FormArray} instances.
	     *
	     * A `FormArray` aggregates the values of each child {\@link FormControl} into an array.
	     * It calculates its status by reducing the statuses of its children. For example, if one of
	     * the controls in a `FormArray` is invalid, the entire array becomes invalid.
	     *
	     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	     * along with {\@link FormControl} and {\@link FormGroup}.
	     *
	     * \@howToUse
	     *
	     * When instantiating a {\@link FormArray}, pass in an array of child controls as the first
	     * argument.
	     *
	     * ### Example
	     *
	     * ```
	     * const arr = new FormArray([
	     *   new FormControl('Nancy', Validators.minLength(2)),
	     *   new FormControl('Drew'),
	     * ]);
	     *
	     * console.log(arr.value);   // ['Nancy', 'Drew']
	     * console.log(arr.status);  // 'VALID'
	     * ```
	     *
	     * You can also include array-level validators as the second arg, or array-level async
	     * validators as the third arg. These come in handy when you want to perform validation
	     * that considers the value of more than one child control.
	     *
	     * ### Adding or removing controls
	     *
	     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	     * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	     * the `FormArray` directly, as that will result in strange and unexpected behavior such
	     * as broken change detection.
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * \@stable
	     */
	    var FormArray = (function (_super) {
	        __extends$6(FormArray, _super);
	        /**
	         * @param {?} controls
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         */
	        function FormArray(controls, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            _super.call(this, validator, asyncValidator);
	            this.controls = controls;
	            this._initObservables();
	            this._setUpControls();
	            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        }
	        /**
	         * Get the {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.at = function (index) { return this.controls[index]; };
	        /**
	         * Insert a new {\@link AbstractControl} at the end of the array.
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.push = function (control) {
	            this.controls.push(control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Insert a new {\@link AbstractControl} at the given `index` in the array.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.insert = function (index, control) {
	            this.controls.splice(index, 0, control);
	            this._registerControl(control);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Remove the control at the given `index` in the array.
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype.removeAt = function (index) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        /**
	         * Replace an existing control.
	         * @param {?} index
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype.setControl = function (index, control) {
	            if (this.controls[index])
	                this.controls[index]._registerOnCollectionChange(function () { });
	            this.controls.splice(index, 1);
	            if (control) {
	                this.controls.splice(index, 0, control);
	                this._registerControl(control);
	            }
	            this.updateValueAndValidity();
	            this._onCollectionChange();
	        };
	        Object.defineProperty(FormArray.prototype, "length", {
	            /**
	             * Length of the control array.
	             * @return {?}
	             */
	            get: function () { return this.controls.length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         *  Sets the value of the {\@link FormArray}. It accepts an array that matches
	         *  the structure of the control.
	         *
	         * This method performs strict checks, so it will throw an error if you try
	         * to set the value of a control that doesn't exist or if you exclude the
	         * value of a control.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.setValue(['Nancy', 'Drew']);
	         *  console.log(arr.value);   // ['Nancy', 'Drew']
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.setValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._checkAllValuesPresent(value);
	            value.forEach(function (newValue, index) {
	                _this._throwIfControlMissing(index);
	                _this.at(index).setValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         *  Patches the value of the {\@link FormArray}. It accepts an array that matches the
	         *  structure of the control, and will do its best to match the values to the correct
	         *  controls in the group.
	         *
	         *  It accepts both super-sets and sub-sets of the array without throwing an error.
	         *
	         *  ### Example
	         *
	         *  ```
	         *  const arr = new FormArray([
	         *     new FormControl(),
	         *     new FormControl()
	         *  ]);
	         *  console.log(arr.value);   // [null, null]
	         *
	         *  arr.patchValue(['Nancy']);
	         *  console.log(arr.value);   // ['Nancy', null]
	         *  ```
	         * @param {?} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.patchValue = function (value, _a) {
	            var _this = this;
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            value.forEach(function (newValue, index) {
	                if (_this.at(index)) {
	                    _this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: emitEvent });
	                }
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        };
	        /**
	         * Resets the {\@link FormArray}. This means by default:
	         *
	         * * The array and all descendants are marked `pristine`
	         * * The array and all descendants are marked `untouched`
	         * * The value of all descendants will be null or null maps
	         *
	         * You can also reset to a specific form state by passing in an array of states
	         * that matches the structure of the control. The state can be a standalone value
	         * or a form state object with both a value and a disabled status.
	         *
	         * ### Example
	         *
	         * ```ts
	         * this.arr.reset(['name', 'last name']);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * ```
	         *
	         * - OR -
	         *
	         * ```
	         * this.arr.reset([
	         *   {value: 'name', disabled: true},
	         *   'last'
	         * ]);
	         *
	         * console.log(this.arr.value);  // ['name', 'last name']
	         * console.log(this.arr.get(0).status);  // 'DISABLED'
	         * ```
	         * @param {?=} value
	         * @param {?=} __1
	         * @return {?}
	         */
	        FormArray.prototype.reset = function (value, _a) {
	            if (value === void 0) { value = []; }
	            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	            this._forEachChild(function (control, index) {
	                control.reset(value[index], { onlySelf: true, emitEvent: emitEvent });
	            });
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            this._updatePristine({ onlySelf: onlySelf });
	            this._updateTouched({ onlySelf: onlySelf });
	        };
	        /**
	         * The aggregate value of the array, including any disabled controls.
	         *
	         * If you'd like to include all values regardless of disabled status, use this method.
	         * Otherwise, the `value` property is the best way to get the value of the array.
	         * @return {?}
	         */
	        FormArray.prototype.getRawValue = function () {
	            return this.controls.map(function (control) {
	                return control instanceof FormControl ? control.value : ((control)).getRawValue();
	            });
	        };
	        /**
	         * \@internal
	         * @param {?} index
	         * @return {?}
	         */
	        FormArray.prototype._throwIfControlMissing = function (index) {
	            if (!this.controls.length) {
	                throw new Error("\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
	            }
	            if (!this.at(index)) {
	                throw new Error("Cannot find form control at index " + index);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} cb
	         * @return {?}
	         */
	        FormArray.prototype._forEachChild = function (cb) {
	            this.controls.forEach(function (control, index) { cb(control, index); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._updateValue = function () {
	            var _this = this;
	            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })
	                .map(function (control) { return control.value; });
	        };
	        /**
	         * \@internal
	         * @param {?} condition
	         * @return {?}
	         */
	        FormArray.prototype._anyControls = function (condition) {
	            return this.controls.some(function (control) { return control.enabled && condition(control); });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._setUpControls = function () {
	            var _this = this;
	            this._forEachChild(function (control) { return _this._registerControl(control); });
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        FormArray.prototype._checkAllValuesPresent = function (value) {
	            this._forEachChild(function (control, i) {
	                if (value[i] === undefined) {
	                    throw new Error("Must supply a value for form control at index: " + i + ".");
	                }
	            });
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormArray.prototype._allControlsDisabled = function () {
	            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {
	                var control = _a[_i];
	                if (control.enabled)
	                    return false;
	            }
	            return this.controls.length > 0 || this.disabled;
	        };
	        /**
	         * @param {?} control
	         * @return {?}
	         */
	        FormArray.prototype._registerControl = function (control) {
	            control.setParent(this);
	            control._registerOnCollectionChange(this._onCollectionChange);
	        };
	        return FormArray;
	    }(AbstractControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgForm; })
	    };
	    var /** @type {?} */ resolvedPromise = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a top-level {\@link FormGroup} instance and binds it to a form
	     * to track aggregate form value and validation status.
	     *
	     * \@howToUse
	     *
	     * As soon as you import the `FormsModule`, this directive becomes active by default on
	     * all `<form>` tags.  You don't need to add a special selector.
	     *
	     * You can export the directive into a local template variable using `ngForm` as the key
	     * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
	     * {\@link FormGroup} instance are duplicated on the directive itself, so a reference to it
	     * will give you access to the aggregate value and validity status of the form, as well as
	     * user interaction properties like `dirty` and `touched`.
	     *
	     * To register child controls with the form, you'll want to use {\@link NgModel} with a
	     * `name` attribute.  You can also use {\@link NgModelGroup} if you'd like to create
	     * sub-groups within the form.
	     *
	     * You can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgForm = (function (_super) {
	        __extends$4(NgForm, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgForm(validators, asyncValidators) {
	            _super.call(this);
	            this._submitted = false;
	            this.ngSubmit = new EventEmitter();
	            this.form =
	                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        }
	        Object.defineProperty(NgForm.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForm.prototype, "controls", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form.controls; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                dir._control = (container.registerControl(dir.name, dir.control));
	                setUpControl(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeControl = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.addFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                var /** @type {?} */ group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.removeFormGroup = function (dir) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ container = _this._findContainer(dir.path);
	                if (container) {
	                    container.removeControl(dir.name);
	                }
	            });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        NgForm.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.updateModel = function (dir, value) {
	            var _this = this;
	            resolvedPromise.then(function () {
	                var /** @type {?} */ ctrl = (_this.form.get(dir.path));
	                ctrl.setValue(value);
	            });
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        NgForm.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        NgForm.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        NgForm.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @param {?} path
	         * @return {?}
	         */
	        NgForm.prototype._findContainer = function (path) {
	            path.pop();
	            return path.length ? (this.form.get(path)) : this.form;
	        };
	        NgForm.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	                        providers: [formDirectiveProvider],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        outputs: ['ngSubmit'],
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgForm.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        return NgForm;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ Examples = {
	        formControlName: "\n    <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       firstName: new FormControl()\n    });",
	        formGroupName: "\n    <div [formGroup]=\"myGroup\">\n       <div formGroupName=\"person\">\n          <input formControlName=\"firstName\">\n       </div>\n    </div>\n\n    In your class:\n\n    this.myGroup = new FormGroup({\n       person: new FormGroup({ firstName: new FormControl() })\n    });",
	        formArrayName: "\n    <div [formGroup]=\"myGroup\">\n      <div formArrayName=\"cities\">\n        <div *ngFor=\"let city of cityArray.controls; let i=index\">\n          <input [formControlName]=\"i\">\n        </div>\n      </div>\n    </div>\n\n    In your class:\n\n    this.cityArray = new FormArray([new FormControl('SF')]);\n    this.myGroup = new FormGroup({\n      cities: this.cityArray\n    });",
	        ngModelGroup: "\n    <form>\n       <div ngModelGroup=\"person\">\n          <input [(ngModel)]=\"person.name\" name=\"firstName\">\n       </div>\n    </form>",
	        ngModelWithFormGroup: "\n    <div [formGroup]=\"myGroup\">\n       <input formControlName=\"firstName\">\n       <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n    </div>\n  "
	    };
	
	    var TemplateDrivenErrors = (function () {
	        function TemplateDrivenErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelParentException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n      formGroup's partner directive \"formControlName\" instead.  Example:\n\n      " + Examples.formControlName + "\n\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n      Example:\n\n      " + Examples.ngModelWithFormGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.formGroupNameException = function () {
	            throw new Error("\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.missingNameException = function () {
	            throw new Error("If ngModel is used within a form tag, either the name attribute must be set or the form\n      control must be defined as 'standalone' in ngModelOptions.\n\n      Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n      Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">");
	        };
	        /**
	         * @return {?}
	         */
	        TemplateDrivenErrors.modelGroupParentException = function () {
	            throw new Error("\n      ngModelGroup cannot be used with a parent formGroup directive.\n\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n      " + Examples.formGroupName + "\n\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n      " + Examples.ngModelGroup);
	        };
	        return TemplateDrivenErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ modelGroupProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })
	    };
	    /**
	     * \@whatItDoes Creates and binds a {\@link FormGroup} instance to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used as a child of {\@link NgForm} (or in other words,
	     * within `<form>` tags).
	     *
	     * Use this directive if you'd like to create a sub-group within a form. This can
	     * come in handy if you want to validate a sub-group of your form separately from
	     * the rest of your form, or if some values in your domain model make more sense to
	     * consume together in a nested object.
	     *
	     * Pass in the name you'd like this sub-group to have and it will become the key
	     * for the sub-group in the form's full value. You can also export the directive into
	     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
	     *
	     * {\@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `FormsModule`
	     *
	     * \@stable
	     */
	    var NgModelGroup = (function (_super) {
	        __extends$8(NgModelGroup, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function NgModelGroup(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NgModelGroup.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelGroupParentException();
	            }
	        };
	        NgModelGroup.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },
	        ];
	        /** @nocollapse */
	        NgModelGroup.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        NgModelGroup.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],
	        };
	        return NgModelGroup;
	    }(AbstractFormGroupDirective));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return NgModel; })
	    };
	    /**
	     * `ngModel` forces an additional change detection run when its inputs change:
	     * E.g.:
	     * ```
	     * <div>{{myModel.valid}}</div>
	     * <input [(ngModel)]="myValue" #myModel="ngModel">
	     * ```
	     * I.e. `ngModel` can export itself on the element and then be used in the template.
	     * Normally, this would result in expressions before the `input` that use the exported directive
	     * to have and old value as they have been
	     * dirty checked before. As this is a very common case for `ngModel`, we added this second change
	     * detection run.
	     *
	     * Notes:
	     * - this is just one extra run no matter how many `ngModel` have been changed.
	     * - this is a general problem when using `exportAs` for directives!
	     */
	    var /** @type {?} */ resolvedPromise$1 = Promise.resolve(null);
	    /**
	     * \@whatItDoes Creates a {\@link FormControl} instance from a domain model and binds it
	     * to a form control element.
	     *
	     * The {\@link FormControl} instance will track the value, user interaction, and
	     * validation status of the control and keep the view synced with the model. If used
	     * within a parent form, the directive will also register itself with the form as a child
	     * control.
	     *
	     * \@howToUse
	     *
	     * This directive can be used by itself or as part of a larger form. All you need is the
	     * `ngModel` selector to activate it.
	     *
	     * It accepts a domain model as an optional {\@link \@Input}. If you have a one-way binding
	     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component
	     * class will set the value in the view. If you have a two-way binding with `[()]` syntax
	     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to
	     * the domain model in your class as well.
	     *
	     * If you wish to inspect the properties of the associated {\@link FormControl} (like
	     * validity state), you can also export the directive into a local template variable using
	     * `ngModel` as the key (ex: `#myVar="ngModel"`). You can then access the control using the
	     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)
	     * will fall through to the control anyway, so you can access them directly. You can see a
	     * full list of properties directly available in {\@link AbstractControlDirective}.
	     *
	     * The following is an example of a simple standalone control using `ngModel`:
	     *
	     * {\@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
	     *
	     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
	     * so that the control can be registered with the parent form under that name.
	     *
	     * It's worth noting that in the context of a parent form, you often can skip one-way or
	     * two-way binding because the parent form will sync the value for you. You can access
	     * its properties by exporting it into a local template variable using `ngForm` (ex:
	     * `#f="ngForm"`). Then you can pass it where it needs to go on submit.
	     *
	     * If you do need to populate initial values into your form, using a one-way binding for
	     * `ngModel` tends to be sufficient as long as you use the exported form's value rather
	     * than the domain model's value on submit.
	     *
	     * Take a look at an example of using `ngModel` within a form:
	     *
	     * {\@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
	     *
	     * To see `ngModel` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: `FormsModule`
	     *
	     *  \@stable
	     */
	    var NgModel = (function (_super) {
	        __extends$7(NgModel, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function NgModel(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            /** @internal */
	            this._control = new FormControl();
	            /** @internal */
	            this._registered = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype.ngOnChanges = function (changes) {
	            this._checkForErrors();
	            if (!this._registered)
	                this._setUpControl();
	            if ('isDisabled' in changes) {
	                this._updateDisabled(changes);
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };
	        Object.defineProperty(NgModel.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? controlPath(this.name, this._parent) : [this.name];
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModel.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        NgModel.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpControl = function () {
	            this._isStandalone() ? this._setUpStandalone() :
	                this.formDirective.addControl(this);
	            this._registered = true;
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._isStandalone = function () {
	            return !this._parent || (this.options && this.options.standalone);
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._setUpStandalone = function () {
	            setUpControl(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkForErrors = function () {
	            if (!this._isStandalone()) {
	                this._checkParentType();
	            }
	            this._checkName();
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkParentType = function () {
	            if (!(this._parent instanceof NgModelGroup) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                TemplateDrivenErrors.formGroupNameException();
	            }
	            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
	                TemplateDrivenErrors.modelParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgModel.prototype._checkName = function () {
	            if (this.options && this.options.name)
	                this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                TemplateDrivenErrors.missingNameException();
	            }
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgModel.prototype._updateValue = function (value) {
	            var _this = this;
	            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgModel.prototype._updateDisabled = function (changes) {
	            var _this = this;
	            var /** @type {?} */ disabledValue = changes['isDisabled'].currentValue;
	            var /** @type {?} */ isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');
	            resolvedPromise$1.then(function () {
	                if (isDisabled && !_this.control.disabled) {
	                    _this.control.disable();
	                }
	                else if (!isDisabled && _this.control.disabled) {
	                    _this.control.enable();
	                }
	            });
	        };
	        NgModel.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[ngModel]:not([formControlName]):not([formControl])',
	                        providers: [formControlBinding],
	                        exportAs: 'ngModel'
	                    },] },
	        ];
	        /** @nocollapse */
	        NgModel.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        NgModel.propDecorators = {
	            'name': [{ type: _angular_core.Input },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	        };
	        return NgModel;
	    }(NgControl));
	
	    var ReactiveErrors = (function () {
	        function ReactiveErrors() {
	        }
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.controlParentException = function () {
	            throw new Error("formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.ngModelGroupException = function () {
	            throw new Error("formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n       that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n        " + Examples.formGroupName + "\n\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n        " + Examples.ngModelGroup);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.missingFormException = function () {
	            throw new Error("formGroup expects a FormGroup instance. Please pass one in.\n\n       Example:\n\n       " + Examples.formControlName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.groupParentException = function () {
	            throw new Error("formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      " + Examples.formGroupName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.arrayParentException = function () {
	            throw new Error("formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n       directive and pass it an existing FormGroup instance (you can create one in your class).\n\n        Example:\n\n        " + Examples.formArrayName);
	        };
	        /**
	         * @return {?}
	         */
	        ReactiveErrors.disabledAttrWarning = function () {
	            console.warn("\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n      you. We recommend using this approach to avoid 'changed after checked' errors.\n       \n      Example: \n      form = new FormGroup({\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n        last: new FormControl('Drew', Validators.required)\n      });\n    ");
	        };
	        return ReactiveErrors;
	    }());
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formControlBinding$1 = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })
	    };
	    /**
	     * \@whatItDoes Syncs a standalone {\@link FormControl} instance to a form control element.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * Use this directive if you'd like to create and manage a {\@link FormControl} instance directly.
	     * Simply create a {\@link FormControl}, save it to your component class, and pass it into the
	     * {\@link FormControlDirective}.
	     *
	     * This directive is designed to be used as a standalone control.  Unlike {\@link FormControlName},
	     * it does not require that your {\@link FormControl} instance be part of any parent
	     * {\@link FormGroup}, and it won't be registered to any {\@link FormGroupDirective} that
	     * exists above it.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormControl} instance. See a full list of available properties in
	     * {\@link AbstractControl}.
	     *
	     * **Set the value**: You can pass in an initial value when instantiating the {\@link FormControl},
	     * or you can set it programmatically later using {\@link AbstractControl.setValue} or
	     * {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     *  \@stable
	     */
	    var FormControlDirective = (function (_super) {
	        __extends$9(FormControlDirective, _super);
	        /**
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlDirective(validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this.update = new EventEmitter();
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlDirective.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype.ngOnChanges = function (changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                    this.valueAccessor.setDisabledState(true);
	                }
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.setValue(this.model);
	                this.viewModel = this.model;
	            }
	        };
	        Object.defineProperty(FormControlDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlDirective.prototype._isControlChanged = function (changes) {
	            return changes.hasOwnProperty('form');
	        };
	        FormControlDirective.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },
	        ];
	        /** @nocollapse */
	        FormControlDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formControl',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlDirective;
	    }(NgControl));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formDirectiveProvider$1 = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })
	    };
	    /**
	     * \@whatItDoes Binds an existing {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive accepts an existing {\@link FormGroup} instance. It will then use this
	     * {\@link FormGroup} instance to match any child {\@link FormControl}, {\@link FormGroup},
	     * and {\@link FormArray} instances to child {\@link FormControlName}, {\@link FormGroupName},
	     * and {\@link FormArrayName} directives.
	     *
	     * **Set value**: You can set the form's initial value when instantiating the
	     * {\@link FormGroup}, or you can set it programmatically later using the {\@link FormGroup}'s
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue} methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe
	     * to the {\@link FormGroup}'s {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * its {\@link AbstractControl.statusChanges} event to be notified when the validation status is
	     * re-calculated.
	     *
	     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has
	     * triggered a form submission. The `ngSubmit` event will be emitted with the original form
	     * submission event.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormGroupDirective = (function (_super) {
	        __extends$11(FormGroupDirective, _super);
	        /**
	         * @param {?} _validators
	         * @param {?} _asyncValidators
	         */
	        function FormGroupDirective(_validators, _asyncValidators) {
	            _super.call(this);
	            this._validators = _validators;
	            this._asyncValidators = _asyncValidators;
	            this._submitted = false;
	            this.directives = [];
	            this.form = null;
	            this.ngSubmit = new EventEmitter();
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormGroupDirective.prototype.ngOnChanges = function (changes) {
	            this._checkFormPresent();
	            if (changes.hasOwnProperty('form')) {
	                this._updateValidators();
	                this._updateDomValue();
	                this._updateRegistrations();
	            }
	        };
	        Object.defineProperty(FormGroupDirective.prototype, "submitted", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._submitted; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.form; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormGroupDirective.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return []; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addControl = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	            return ctrl;
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getControl = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormGroup = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormGroup = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormGroup = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.addFormArray = function (dir) {
	            var /** @type {?} */ ctrl = this.form.get(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.removeFormArray = function (dir) { };
	        /**
	         * @param {?} dir
	         * @return {?}
	         */
	        FormGroupDirective.prototype.getFormArray = function (dir) { return (this.form.get(dir.path)); };
	        /**
	         * @param {?} dir
	         * @param {?} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.updateModel = function (dir, value) {
	            var /** @type {?} */ ctrl = (this.form.get(dir.path));
	            ctrl.setValue(value);
	        };
	        /**
	         * @param {?} $event
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onSubmit = function ($event) {
	            this._submitted = true;
	            this.ngSubmit.emit($event);
	            return false;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        FormGroupDirective.prototype.resetForm = function (value) {
	            if (value === void 0) { value = undefined; }
	            this.form.reset(value);
	            this._submitted = false;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateDomValue = function () {
	            var _this = this;
	            this.directives.forEach(function (dir) {
	                var /** @type {?} */ newCtrl = _this.form.get(dir.path);
	                if (dir._control !== newCtrl) {
	                    cleanUpControl(dir._control, dir);
	                    if (newCtrl)
	                        setUpControl(newCtrl, dir);
	                    dir._control = newCtrl;
	                }
	            });
	            this.form._updateTreeValidity({ emitEvent: false });
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateRegistrations = function () {
	            var _this = this;
	            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });
	            if (this._oldForm)
	                this._oldForm._registerOnCollectionChange(function () { });
	            this._oldForm = this.form;
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._updateValidators = function () {
	            var /** @type {?} */ sync = composeValidators(this._validators);
	            this.form.validator = Validators.compose([this.form.validator, sync]);
	            var /** @type {?} */ async = composeAsyncValidators(this._asyncValidators);
	            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	        };
	        /**
	         * @return {?}
	         */
	        FormGroupDirective.prototype._checkFormPresent = function () {
	            if (!this.form) {
	                ReactiveErrors.missingFormException();
	            }
	        };
	        FormGroupDirective.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[formGroup]',
	                        providers: [formDirectiveProvider$1],
	                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
	                        exportAs: 'ngForm'
	                    },] },
	        ];
	        /** @nocollapse */
	        FormGroupDirective.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupDirective.propDecorators = {
	            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],
	            'ngSubmit': [{ type: _angular_core.Output },],
	        };
	        return FormGroupDirective;
	    }(ControlContainer));
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ formGroupNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormGroup} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive can only be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormGroup} you want to link, and
	     * will look for a {\@link FormGroup} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form groups can come in handy when you want to validate a sub-group of a
	     * form separately from the rest or when you'd like to group the values of certain
	     * controls into their own nested object.
	     *
	     * **Access the group**: You can access the associated {\@link FormGroup} using the
	     * {\@link AbstractControl.get} method. Ex: `this.form.get('name')`.
	     *
	     * You can also access individual controls within the group using dot syntax.
	     * Ex: `this.form.get('name.first')`
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormGroup}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormGroup}, or you can set it programmatically later using
	     * {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the group, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormGroupName = (function (_super) {
	        __extends$12(FormGroupName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormGroupName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        FormGroupName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.groupParentException();
	            }
	        };
	        FormGroupName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormGroupName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormGroupName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],
	        };
	        return FormGroupName;
	    }(AbstractFormGroupDirective));
	    var /** @type {?} */ formArrayNameProvider = {
	        provide: ControlContainer,
	        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })
	    };
	    /**
	     * \@whatItDoes Syncs a nested {\@link FormArray} to a DOM element.
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the nested {\@link FormArray} you want to link, and
	     * will look for a {\@link FormArray} registered with that name in the parent
	     * {\@link FormGroup} instance you passed into {\@link FormGroupDirective}.
	     *
	     * Nested form arrays can come in handy when you have a group of form controls but
	     * you're not sure how many there will be. Form arrays allow you to create new
	     * form controls dynamically.
	     *
	     * **Access the array**: You can access the associated {\@link FormArray} using the
	     * {\@link AbstractControl.get} method on the parent {\@link FormGroup}.
	     * Ex: `this.form.get('cities')`.
	     *
	     * **Get the value**: the `value` property is always synced and available on the
	     * {\@link FormArray}. See a full list of available properties in {\@link AbstractControl}.
	     *
	     * **Set the value**: You can set an initial value for each child control when instantiating
	     * the {\@link FormArray}, or you can set the value programmatically later using the
	     * {\@link FormArray}'s {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}
	     * methods.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the array, you can
	     * subscribe to the {\@link FormArray}'s {\@link AbstractControl.valueChanges} event.  You can also
	     * listen to its {\@link AbstractControl.statusChanges} event to be notified when the validation
	     * status is re-calculated.
	     *
	     * **Add new controls**: You can add new controls to the {\@link FormArray} dynamically by
	     * calling its {\@link FormArray.push} method.
	     *  Ex: `this.form.get('cities').push(new FormControl());`
	     *
	     * ### Example
	     *
	     * {\@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
	     *
	     * * **npm package**: `\@angular/forms`
	     *
	     * * **NgModule**: `ReactiveFormsModule`
	     *
	     * \@stable
	     */
	    var FormArrayName = (function (_super) {
	        __extends$12(FormArrayName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         */
	        function FormArrayName(parent, validators, asyncValidators) {
	            _super.call(this);
	            this._parent = parent;
	            this._validators = validators;
	            this._asyncValidators = asyncValidators;
	        }
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnInit = function () {
	            this._checkParentType();
	            this.formDirective.addFormArray(this);
	        };
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeFormArray(this);
	            }
	        };
	        Object.defineProperty(FormArrayName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.formDirective.getFormArray(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._parent ? (this._parent.formDirective) : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._validators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormArrayName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeAsyncValidators(this._asyncValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormArrayName.prototype._checkParentType = function () {
	            if (_hasInvalidParent(this._parent)) {
	                ReactiveErrors.arrayParentException();
	            }
	        };
	        FormArrayName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },
	        ];
	        /** @nocollapse */
	        FormArrayName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	        ]; };
	        FormArrayName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],
	        };
	        return FormArrayName;
	    }(ControlContainer));
	    /**
	     * @param {?} parent
	     * @return {?}
	     */
	    function _hasInvalidParent(parent) {
	        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
	            !(parent instanceof FormArrayName);
	    }
	
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ controlNameBinding = {
	        provide: NgControl,
	        useExisting: _angular_core.forwardRef(function () { return FormControlName; })
	    };
	    /**
	     * \@whatItDoes Syncs a {\@link FormControl} in an existing {\@link FormGroup} to a form control
	     * element by name.
	     *
	     * In other words, this directive ensures that any values written to the {\@link FormControl}
	     * instance programmatically will be written to the DOM element (model -> view). Conversely,
	     * any values written to the DOM element through user input will be reflected in the
	     * {\@link FormControl} instance (view -> model).
	     *
	     * \@howToUse
	     *
	     * This directive is designed to be used with a parent {\@link FormGroupDirective} (selector:
	     * `[formGroup]`).
	     *
	     * It accepts the string name of the {\@link FormControl} instance you want to
	     * link, and will look for a {\@link FormControl} registered with that name in the
	     * closest {\@link FormGroup} or {\@link FormArray} above it.
	     *
	     * **Access the control**: You can access the {\@link FormControl} associated with
	     * this directive by using the {\@link AbstractControl.get} method.
	     * Ex: `this.form.get('first');`
	     *
	     * **Get value**: the `value` property is always synced and available on the {\@link FormControl}.
	     * See a full list of available properties in {\@link AbstractControl}.
	     *
	     *  **Set value**: You can set an initial value for the control when instantiating the
	     *  {\@link FormControl}, or you can set it programmatically later using
	     *  {\@link AbstractControl.setValue} or {\@link AbstractControl.patchValue}.
	     *
	     * **Listen to value**: If you want to listen to changes in the value of the control, you can
	     * subscribe to the {\@link AbstractControl.valueChanges} event.  You can also listen to
	     * {\@link AbstractControl.statusChanges} to be notified when the validation status is
	     * re-calculated.
	     *
	     * ### Example
	     *
	     * In this example, we create form controls for first name and last name.
	     *
	     * {\@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
	     *
	     * To see `formControlName` examples with different form control types, see:
	     *
	     * * Radio buttons: {\@link RadioControlValueAccessor}
	     * * Selects: {\@link SelectControlValueAccessor}
	     *
	     * **npm package**: `\@angular/forms`
	     *
	     * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     *  \@stable
	     */
	    var FormControlName = (function (_super) {
	        __extends$10(FormControlName, _super);
	        /**
	         * @param {?} parent
	         * @param {?} validators
	         * @param {?} asyncValidators
	         * @param {?} valueAccessors
	         */
	        function FormControlName(parent, validators, asyncValidators, valueAccessors) {
	            _super.call(this);
	            this._added = false;
	            this.update = new EventEmitter();
	            this._parent = parent;
	            this._rawValidators = validators || [];
	            this._rawAsyncValidators = asyncValidators || [];
	            this.valueAccessor = selectValueAccessor(this, valueAccessors);
	        }
	        Object.defineProperty(FormControlName.prototype, "isDisabled", {
	            /**
	             * @param {?} isDisabled
	             * @return {?}
	             */
	            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnChanges = function (changes) {
	            if (!this._added)
	                this._setUpControl();
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype.ngOnDestroy = function () {
	            if (this.formDirective) {
	                this.formDirective.removeControl(this);
	            }
	        };
	        /**
	         * @param {?} newValue
	         * @return {?}
	         */
	        FormControlName.prototype.viewToModelUpdate = function (newValue) {
	            this.viewModel = newValue;
	            this.update.emit(newValue);
	        };
	        Object.defineProperty(FormControlName.prototype, "path", {
	            /**
	             * @return {?}
	             */
	            get: function () { return controlPath(this.name, this._parent); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "formDirective", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent ? this._parent.formDirective : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "validator", {
	            /**
	             * @return {?}
	             */
	            get: function () { return composeValidators(this._rawValidators); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "asyncValidator", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return composeAsyncValidators(this._rawAsyncValidators);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(FormControlName.prototype, "control", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._control; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._checkParentType = function () {
	            if (!(this._parent instanceof FormGroupName) &&
	                this._parent instanceof AbstractFormGroupDirective) {
	                ReactiveErrors.ngModelGroupException();
	            }
	            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&
	                !(this._parent instanceof FormArrayName)) {
	                ReactiveErrors.controlParentException();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        FormControlName.prototype._setUpControl = function () {
	            this._checkParentType();
	            this._control = this.formDirective.addControl(this);
	            if (this.control.disabled && this.valueAccessor.setDisabledState) {
	                this.valueAccessor.setDisabledState(true);
	            }
	            this._added = true;
	        };
	        FormControlName.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },
	        ];
	        /** @nocollapse */
	        FormControlName.ctorParameters = function () { return [
	            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },
	            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },
	        ]; };
	        FormControlName.propDecorators = {
	            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],
	            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],
	            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],
	            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],
	        };
	        return FormControlName;
	    }(NgControl));
	
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),
	        multi: true
	    };
	    var /** @type {?} */ CHECKBOX_REQUIRED_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return CheckboxRequiredValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `required` validator to any controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input name="fullName" ngModel required>
	     * ```
	     *
	     * \@stable
	     */
	    var RequiredValidator = (function () {
	        function RequiredValidator() {
	        }
	        Object.defineProperty(RequiredValidator.prototype, "required", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._required; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._required = value != null && value !== false && "" + value !== 'false';
	                if (this._onChange)
	                    this._onChange();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        RequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.required(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        RequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
	                        providers: [REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        RequiredValidator.ctorParameters = function () { return []; };
	        RequiredValidator.propDecorators = {
	            'required': [{ type: _angular_core.Input },],
	        };
	        return RequiredValidator;
	    }());
	    /**
	     * A Directive that adds the `required` validator to checkbox controls marked with the
	     * `required` attribute, via the {\@link NG_VALIDATORS} binding.
	     *
	     * ### Example
	     *
	     * ```
	     * <input type="checkbox" name="active" ngModel required>
	     * ```
	     *
	     * \@experimental
	     */
	    var CheckboxRequiredValidator = (function (_super) {
	        __extends$13(CheckboxRequiredValidator, _super);
	        function CheckboxRequiredValidator() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        CheckboxRequiredValidator.prototype.validate = function (c) {
	            return this.required ? Validators.requiredTrue(c) : null;
	        };
	        CheckboxRequiredValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
	                        providers: [CHECKBOX_REQUIRED_VALIDATOR],
	                        host: { '[attr.required]': 'required ? "" : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        CheckboxRequiredValidator.ctorParameters = function () { return []; };
	        return CheckboxRequiredValidator;
	    }(RequiredValidator));
	    /**
	     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='min'}
	     */
	    var /** @type {?} */ MIN_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MinLengthValidator} for any `formControlName`,
	     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.
	     *
	     * \@stable
	     */
	    var MinLengthValidator = (function () {
	        function MinLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MinLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('minlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MinLengthValidator.prototype.validate = function (c) {
	            return this.minlength == null ? null : this._validator(c);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MinLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.minLength(parseInt(this.minlength, 10));
	        };
	        MinLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	                        providers: [MIN_LENGTH_VALIDATOR],
	                        host: { '[attr.minlength]': 'minlength ? minlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MinLengthValidator.ctorParameters = function () { return []; };
	        MinLengthValidator.propDecorators = {
	            'minlength': [{ type: _angular_core.Input },],
	        };
	        return MinLengthValidator;
	    }());
	    /**
	     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	     *
	     * ## Example:
	     *
	     * {@example common/forms/ts/validators/validators.ts region='max'}
	     */
	    var /** @type {?} */ MAX_LENGTH_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),
	        multi: true
	    };
	    /**
	     * A directive which installs the {\@link MaxLengthValidator} for any `formControlName,
	     * `formControl`,
	     * or control with `ngModel` that also has a `maxlength` attribute.
	     *
	     * \@stable
	     */
	    var MaxLengthValidator = (function () {
	        function MaxLengthValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.ngOnChanges = function (changes) {
	            if ('maxlength' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.validate = function (c) {
	            return this.maxlength != null ? this._validator(c) : null;
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        MaxLengthValidator.prototype._createValidator = function () {
	            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));
	        };
	        MaxLengthValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	                        providers: [MAX_LENGTH_VALIDATOR],
	                        host: { '[attr.maxlength]': 'maxlength ? maxlength : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        MaxLengthValidator.ctorParameters = function () { return []; };
	        MaxLengthValidator.propDecorators = {
	            'maxlength': [{ type: _angular_core.Input },],
	        };
	        return MaxLengthValidator;
	    }());
	    var /** @type {?} */ PATTERN_VALIDATOR = {
	        provide: NG_VALIDATORS,
	        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),
	        multi: true
	    };
	    /**
	     * A Directive that adds the `pattern` validator to any controls marked with the
	     * `pattern` attribute, via the {\@link NG_VALIDATORS} binding. Uses attribute value
	     * as the regex to validate Control value against.  Follows pattern attribute
	     * semantics; i.e. regex must match entire Control value.
	     *
	     * ### Example
	     *
	     * ```
	     * <input [name]="fullName" pattern="[a-zA-Z ]*" ngModel>
	     * ```
	     * \@stable
	     */
	    var PatternValidator = (function () {
	        function PatternValidator() {
	        }
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        PatternValidator.prototype.ngOnChanges = function (changes) {
	            if ('pattern' in changes) {
	                this._createValidator();
	                if (this._onChange)
	                    this._onChange();
	            }
	        };
	        /**
	         * @param {?} c
	         * @return {?}
	         */
	        PatternValidator.prototype.validate = function (c) { return this._validator(c); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };
	        /**
	         * @return {?}
	         */
	        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };
	        PatternValidator.decorators = [
	            { type: _angular_core.Directive, args: [{
	                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	                        providers: [PATTERN_VALIDATOR],
	                        host: { '[attr.pattern]': 'pattern ? pattern : null' }
	                    },] },
	        ];
	        /** @nocollapse */
	        PatternValidator.ctorParameters = function () { return []; };
	        PatternValidator.propDecorators = {
	            'pattern': [{ type: _angular_core.Input },],
	        };
	        return PatternValidator;
	    }());
	
	    /**
	     * \@whatItDoes Creates an {\@link AbstractControl} from a user-specified configuration.
	     *
	     * It is essentially syntactic sugar that shortens the `new FormGroup()`,
	     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger
	     * forms.
	     *
	     * \@howToUse
	     *
	     * To use, inject `FormBuilder` into your component class. You can then call its methods
	     * directly.
	     *
	     * {\@example forms/ts/formBuilder/form_builder_example.ts region='Component'}
	     *
	     *  * **npm package**: `\@angular/forms`
	     *
	     *  * **NgModule**: {\@link ReactiveFormsModule}
	     *
	     * \@stable
	     */
	    var FormBuilder = (function () {
	        function FormBuilder() {
	        }
	        /**
	         * Construct a new {\@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.
	         *
	         * See the {\@link FormGroup} constructor for more details.
	         * @param {?} controlsConfig
	         * @param {?=} extra
	         * @return {?}
	         */
	        FormBuilder.prototype.group = function (controlsConfig, extra) {
	            if (extra === void 0) { extra = null; }
	            var /** @type {?} */ controls = this._reduceControls(controlsConfig);
	            var /** @type {?} */ validator = isPresent(extra) ? extra['validator'] : null;
	            var /** @type {?} */ asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;
	            return new FormGroup(controls, validator, asyncValidator);
	        };
	        /**
	         * Construct a new {\@link FormControl} with the given `formState`,`validator`, and
	         * `asyncValidator`.
	         *
	         * `formState` can either be a standalone value for the form control or an object
	         * that contains both a value and a disabled status.
	         *
	         * @param {?} formState
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            return new FormControl(formState, validator, asyncValidator);
	        };
	        /**
	         * Construct a {\@link FormArray} from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         * @param {?} controlsConfig
	         * @param {?=} validator
	         * @param {?=} asyncValidator
	         * @return {?}
	         */
	        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {
	            var _this = this;
	            if (validator === void 0) { validator = null; }
	            if (asyncValidator === void 0) { asyncValidator = null; }
	            var /** @type {?} */ controls = controlsConfig.map(function (c) { return _this._createControl(c); });
	            return new FormArray(controls, validator, asyncValidator);
	        };
	        /**
	         * \@internal
	         * @param {?} controlsConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._reduceControls = function (controlsConfig) {
	            var _this = this;
	            var /** @type {?} */ controls = {};
	            Object.keys(controlsConfig).forEach(function (controlName) {
	                controls[controlName] = _this._createControl(controlsConfig[controlName]);
	            });
	            return controls;
	        };
	        /**
	         * \@internal
	         * @param {?} controlConfig
	         * @return {?}
	         */
	        FormBuilder.prototype._createControl = function (controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||
	                controlConfig instanceof FormArray) {
	                return controlConfig;
	            }
	            else if (Array.isArray(controlConfig)) {
	                var /** @type {?} */ value = controlConfig[0];
	                var /** @type {?} */ validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var /** @type {?} */ asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            }
	            else {
	                return this.control(controlConfig);
	            }
	        };
	        FormBuilder.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        FormBuilder.ctorParameters = function () { return []; };
	        return FormBuilder;
	    }());
	
	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.10');
	
	    var /** @type {?} */ SHARED_FORM_DIRECTIVES = [
	        NgSelectOption,
	        NgSelectMultipleOption,
	        DefaultValueAccessor,
	        NumberValueAccessor,
	        RangeValueAccessor,
	        CheckboxControlValueAccessor,
	        SelectControlValueAccessor,
	        SelectMultipleControlValueAccessor,
	        RadioControlValueAccessor,
	        NgControlStatus,
	        NgControlStatusGroup,
	        RequiredValidator,
	        MinLengthValidator,
	        MaxLengthValidator,
	        PatternValidator,
	        CheckboxRequiredValidator,
	    ];
	    var /** @type {?} */ TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
	    var /** @type {?} */ REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
	    /**
	     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
	     */
	    var InternalFormsSharedModule = (function () {
	        function InternalFormsSharedModule() {
	        }
	        InternalFormsSharedModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: SHARED_FORM_DIRECTIVES,
	                        exports: SHARED_FORM_DIRECTIVES,
	                    },] },
	        ];
	        /** @nocollapse */
	        InternalFormsSharedModule.ctorParameters = function () { return []; };
	        return InternalFormsSharedModule;
	    }());
	
	    /**
	     * The ng module for forms.
	     * \@stable
	     */
	    var FormsModule = (function () {
	        function FormsModule() {
	        }
	        FormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,
	                        providers: [RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        FormsModule.ctorParameters = function () { return []; };
	        return FormsModule;
	    }());
	    /**
	     * The ng module for reactive forms.
	     * \@stable
	     */
	    var ReactiveFormsModule = (function () {
	        function ReactiveFormsModule() {
	        }
	        ReactiveFormsModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],
	                        providers: [FormBuilder, RadioControlRegistry],
	                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
	                    },] },
	        ];
	        /** @nocollapse */
	        ReactiveFormsModule.ctorParameters = function () { return []; };
	        return ReactiveFormsModule;
	    }());
	
	    exports.AbstractControlDirective = AbstractControlDirective;
	    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;
	    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	    exports.ControlContainer = ControlContainer;
	    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;
	    exports.DefaultValueAccessor = DefaultValueAccessor;
	    exports.NgControl = NgControl;
	    exports.NgControlStatus = NgControlStatus;
	    exports.NgControlStatusGroup = NgControlStatusGroup;
	    exports.NgForm = NgForm;
	    exports.NgModel = NgModel;
	    exports.NgModelGroup = NgModelGroup;
	    exports.RadioControlValueAccessor = RadioControlValueAccessor;
	    exports.FormControlDirective = FormControlDirective;
	    exports.FormControlName = FormControlName;
	    exports.FormGroupDirective = FormGroupDirective;
	    exports.FormArrayName = FormArrayName;
	    exports.FormGroupName = FormGroupName;
	    exports.NgSelectOption = NgSelectOption;
	    exports.SelectControlValueAccessor = SelectControlValueAccessor;
	    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;
	    exports.CheckboxRequiredValidator = CheckboxRequiredValidator;
	    exports.MaxLengthValidator = MaxLengthValidator;
	    exports.MinLengthValidator = MinLengthValidator;
	    exports.PatternValidator = PatternValidator;
	    exports.RequiredValidator = RequiredValidator;
	    exports.FormBuilder = FormBuilder;
	    exports.AbstractControl = AbstractControl;
	    exports.FormArray = FormArray;
	    exports.FormControl = FormControl;
	    exports.FormGroup = FormGroup;
	    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
	    exports.NG_VALIDATORS = NG_VALIDATORS;
	    exports.Validators = Validators;
	    exports.VERSION = VERSION;
	    exports.FormsModule = FormsModule;
	    exports.ReactiveFormsModule = ReactiveFormsModule;
	
	}));

/***/ },
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var common_1 = __webpack_require__(23);
	var platform_browser_1 = __webpack_require__(22);
	var linkify = __webpack_require__(61);
	var linkifyStr = __webpack_require__(71);
	var EmbedPipe = (function () {
	    function EmbedPipe(sanitizer) {
	        this.sanitizer = sanitizer;
	    }
	    EmbedPipe.prototype.transform = function (content) {
	        var regex = new RegExp(/([\S]+)?(soundcloud\.com[^\s]+)/g);
	        var thot = this;
	        function recurse(capture) {
	            if (capture != null) {
	                if (capture[2]) {
	                    var soundcloudLink = "https://" + capture[2];
	                    return SC.oEmbed(soundcloudLink, { auto_play: false }).then(function (oEmbed) {
	                        recurse(regex.exec(content));
	                        return thot.sanitizer.bypassSecurityTrustHtml(linkifyStr(content, { target: '_blank' }) + " " + oEmbed.html);
	                    });
	                }
	            }
	            else {
	                return content;
	            }
	        }
	        return recurse(regex.exec(content));
	    };
	    EmbedPipe = __decorate([
	        core_1.Pipe({ name: 'embed' }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof platform_browser_1.DomSanitizer !== 'undefined' && platform_browser_1.DomSanitizer) === 'function' && _a) || Object])
	    ], EmbedPipe);
	    return EmbedPipe;
	    var _a;
	}());
	exports.EmbedPipe = EmbedPipe;
	var MainPipe = (function () {
	    function MainPipe() {
	    }
	    MainPipe = __decorate([
	        core_1.NgModule({
	            declarations: [EmbedPipe],
	            imports: [common_1.CommonModule],
	            exports: [EmbedPipe]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], MainPipe);
	    return MainPipe;
	}());
	exports.MainPipe = MainPipe;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(62);


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.tokenize = exports.test = exports.scanner = exports.parser = exports.options = exports.inherits = exports.find = undefined;
	
	var _class = __webpack_require__(63);
	
	var _options = __webpack_require__(64);
	
	var options = _interopRequireWildcard(_options);
	
	var _scanner = __webpack_require__(65);
	
	var scanner = _interopRequireWildcard(_scanner);
	
	var _parser = __webpack_require__(69);
	
	var parser = _interopRequireWildcard(_parser);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	if (!Array.isArray) {
		Array.isArray = function (arg) {
			return Object.prototype.toString.call(arg) === '[object Array]';
		};
	}
	
	/**
		Converts a string into tokens that represent linkable and non-linkable bits
		@method tokenize
		@param {String} str
		@return {Array} tokens
	*/
	var tokenize = function tokenize(str) {
		return parser.run(scanner.run(str));
	};
	
	/**
		Returns a list of linkable items in the given string.
	*/
	var find = function find(str) {
		var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
		var tokens = tokenize(str);
		var filtered = [];
	
		for (var i = 0; i < tokens.length; i++) {
			var token = tokens[i];
			if (token.isLink && (!type || token.type === type)) {
				filtered.push(token.toObject());
			}
		}
	
		return filtered;
	};
	
	/**
		Is the given string valid linkable text of some sort
		Note that this does not trim the text for you.
	
		Optionally pass in a second `type` param, which is the type of link to test
		for.
	
		For example,
	
			test(str, 'email');
	
		Will return `true` if str is a valid email.
	*/
	var test = function test(str) {
		var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
		var tokens = tokenize(str);
		return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].type === type);
	};
	
	// Scanner and parser provide states and tokens for the lexicographic stage
	// (will be used to add additional link types)
	exports.find = find;
	exports.inherits = _class.inherits;
	exports.options = options;
	exports.parser = parser;
	exports.scanner = scanner;
	exports.test = test;
	exports.tokenize = tokenize;

/***/ },
/* 63 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.inherits = inherits;
	function inherits(parent, child) {
		var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
		var extended = Object.create(parent.prototype);
		for (var p in props) {
			extended[p] = props[p];
		}
		extended.constructor = child;
		child.prototype = extended;
		return child;
	}

/***/ },
/* 64 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var defaults = {
		defaultProtocol: 'http',
		events: null,
		format: noop,
		formatHref: noop,
		nl2br: false,
		tagName: 'a',
		target: typeToTarget,
		validate: true,
		ignoreTags: [],
		attributes: null,
		className: 'linkified' };
	
	exports.defaults = defaults;
	exports.Options = Options;
	exports.contains = contains;
	
	
	function Options(opts) {
		opts = opts || {};
	
		this.defaultProtocol = opts.defaultProtocol || defaults.defaultProtocol;
		this.events = opts.events || defaults.events;
		this.format = opts.format || defaults.format;
		this.formatHref = opts.formatHref || defaults.formatHref;
		this.nl2br = opts.nl2br || defaults.nl2br;
		this.tagName = opts.tagName || defaults.tagName;
		this.target = opts.target || defaults.target;
		this.validate = opts.validate || defaults.validate;
		this.ignoreTags = [];
	
		// linkAttributes and linkClass is deprecated
		this.attributes = opts.attributes || opts.linkAttributes || defaults.attributes;
		this.className = opts.className || opts.linkClass || defaults.className;
	
		// Make all tags names upper case
	
		var ignoredTags = opts.ignoreTags || defaults.ignoreTags;
		for (var i = 0; i < ignoredTags.length; i++) {
			this.ignoreTags.push(ignoredTags[i].toUpperCase());
		}
	}
	
	Options.prototype = {
		/**
	  * Given the token, return all options for how it should be displayed
	  */
		resolve: function resolve(token) {
			var href = token.toHref(this.defaultProtocol);
			return {
				formatted: this.get('format', token.toString(), token),
				formattedHref: this.get('formatHref', href, token),
				tagName: this.get('tagName', href, token),
				className: this.get('className', href, token),
				target: this.get('target', href, token),
				events: this.getObject('events', href, token),
				attributes: this.getObject('attributes', href, token)
			};
		},
	
	
		/**
	  * Returns true or false based on whether a token should be displayed as a
	  * link based on the user options. By default,
	  */
		check: function check(token) {
			return this.get('validate', token.toString(), token);
		},
	
	
		// Private methods
	
		/**
	  * Resolve an option's value based on the value of the option and the given
	  * params.
	  * @param [String] key Name of option to use
	  * @param operator will be passed to the target option if it's method
	  * @param [MultiToken] token The token from linkify.tokenize
	  */
		get: function get(key, operator, token) {
			var option = this[key];
	
			if (!option) {
				return option;
			}
	
			switch (typeof option === 'undefined' ? 'undefined' : _typeof(option)) {
				case 'function':
					return option(operator, token.type);
				case 'object':
					var optionValue = option[token.type] || defaults[key];
					return typeof optionValue === 'function' ? optionValue(operator, token.type) : optionValue;
			}
	
			return option;
		},
		getObject: function getObject(key, operator, token) {
			var option = this[key];
			return typeof option === 'function' ? option(operator, token.type) : option;
		}
	};
	
	/**
	 * Quick indexOf replacement for checking the ignoreTags option
	 */
	function contains(arr, value) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] === value) {
				return true;
			}
		}
		return false;
	}
	
	function noop(val) {
		return val;
	}
	
	function typeToTarget(href, type) {
		return type === 'url' ? '_blank' : null;
	}

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.start = exports.run = exports.TOKENS = exports.State = undefined;
	
	var _state = __webpack_require__(66);
	
	var _text = __webpack_require__(67);
	
	var TOKENS = _interopRequireWildcard(_text);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var tlds = 'aaa|aarp|abb|abbott|abogado|ac|academy|accenture|accountant|accountants|aco|active|actor|ad|adac|ads|adult|ae|aeg|aero|af|afl|ag|agency|ai|aig|airforce|airtel|al|alibaba|alipay|allfinanz|alsace|am|amica|amsterdam|an|analytics|android|ao|apartments|app|apple|aq|aquarelle|ar|aramco|archi|army|arpa|arte|as|asia|associates|at|attorney|au|auction|audi|audio|author|auto|autos|avianca|aw|ax|axa|az|azure|ba|baidu|band|bank|bar|barcelona|barclaycard|barclays|bargains|bauhaus|bayern|bb|bbc|bbva|bcg|bcn|bd|be|beats|beer|bentley|berlin|best|bet|bf|bg|bh|bharti|bi|bible|bid|bike|bing|bingo|bio|biz|bj|black|blackfriday|bloomberg|blue|bm|bms|bmw|bn|bnl|bnpparibas|bo|boats|boehringer|bom|bond|boo|book|boots|bosch|bostik|bot|boutique|br|bradesco|bridgestone|broadway|broker|brother|brussels|bs|bt|budapest|bugatti|build|builders|business|buy|buzz|bv|bw|by|bz|bzh|ca|cab|cafe|cal|call|camera|camp|cancerresearch|canon|capetown|capital|car|caravan|cards|care|career|careers|cars|cartier|casa|cash|casino|cat|catering|cba|cbn|cc|cd|ceb|center|ceo|cern|cf|cfa|cfd|cg|ch|chanel|channel|chase|chat|cheap|chloe|christmas|chrome|church|ci|cipriani|circle|cisco|citic|city|cityeats|ck|cl|claims|cleaning|click|clinic|clinique|clothing|cloud|club|clubmed|cm|cn|co|coach|codes|coffee|college|cologne|com|commbank|community|company|compare|computer|comsec|condos|construction|consulting|contact|contractors|cooking|cool|coop|corsica|country|coupon|coupons|courses|cr|credit|creditcard|creditunion|cricket|crown|crs|cruises|csc|cu|cuisinella|cv|cw|cx|cy|cymru|cyou|cz|dabur|dad|dance|date|dating|datsun|day|dclk|de|dealer|deals|degree|delivery|dell|deloitte|delta|democrat|dental|dentist|desi|design|dev|diamonds|diet|digital|direct|directory|discount|dj|dk|dm|dnp|do|docs|dog|doha|domains|download|drive|dubai|durban|dvag|dz|earth|eat|ec|edeka|edu|education|ee|eg|email|emerck|energy|engineer|engineering|enterprises|epson|equipment|er|erni|es|esq|estate|et|eu|eurovision|eus|events|everbank|exchange|expert|exposed|express|fage|fail|fairwinds|faith|family|fan|fans|farm|fashion|fast|feedback|ferrero|fi|film|final|finance|financial|firestone|firmdale|fish|fishing|fit|fitness|fj|fk|flickr|flights|florist|flowers|flsmidth|fly|fm|fo|foo|football|ford|forex|forsale|forum|foundation|fox|fr|fresenius|frl|frogans|frontier|fund|furniture|futbol|fyi|ga|gal|gallery|gallup|game|garden|gb|gbiz|gd|gdn|ge|gea|gent|genting|gf|gg|ggee|gh|gi|gift|gifts|gives|giving|gl|glass|gle|global|globo|gm|gmail|gmbh|gmo|gmx|gn|gold|goldpoint|golf|goo|goog|google|gop|got|gov|gp|gq|gr|grainger|graphics|gratis|green|gripe|group|gs|gt|gu|gucci|guge|guide|guitars|guru|gw|gy|hamburg|hangout|haus|hdfcbank|health|healthcare|help|helsinki|here|hermes|hiphop|hitachi|hiv|hk|hm|hn|hockey|holdings|holiday|homedepot|homes|honda|horse|host|hosting|hoteles|hotmail|house|how|hr|hsbc|ht|hu|hyundai|ibm|icbc|ice|icu|id|ie|ifm|iinet|il|im|immo|immobilien|in|industries|infiniti|info|ing|ink|institute|insurance|insure|int|international|investments|io|ipiranga|iq|ir|irish|is|iselect|ist|istanbul|it|itau|iwc|jaguar|java|jcb|je|jetzt|jewelry|jlc|jll|jm|jmp|jo|jobs|joburg|jot|joy|jp|jpmorgan|jprs|juegos|kaufen|kddi|ke|kerryhotels|kerrylogistics|kerryproperties|kfh|kg|kh|ki|kia|kim|kinder|kitchen|kiwi|km|kn|koeln|komatsu|kp|kpn|kr|krd|kred|kuokgroup|kw|ky|kyoto|kz|la|lacaixa|lamborghini|lamer|lancaster|land|landrover|lanxess|lasalle|lat|latrobe|law|lawyer|lb|lc|lds|lease|leclerc|legal|lexus|lgbt|li|liaison|lidl|life|lifeinsurance|lifestyle|lighting|like|limited|limo|lincoln|linde|link|live|living|lixil|lk|loan|loans|local|locus|lol|london|lotte|lotto|love|lr|ls|lt|ltd|ltda|lu|lupin|luxe|luxury|lv|ly|ma|madrid|maif|maison|makeup|man|management|mango|market|marketing|markets|marriott|mba|mc|md|me|med|media|meet|melbourne|meme|memorial|men|menu|meo|mg|mh|miami|microsoft|mil|mini|mk|ml|mm|mma|mn|mo|mobi|mobily|moda|moe|moi|mom|monash|money|montblanc|mormon|mortgage|moscow|motorcycles|mov|movie|movistar|mp|mq|mr|ms|mt|mtn|mtpc|mtr|mu|museum|mutuelle|mv|mw|mx|my|mz|na|nadex|nagoya|name|natura|navy|nc|ne|nec|net|netbank|network|neustar|new|news|nexus|nf|ng|ngo|nhk|ni|nico|nikon|ninja|nissan|nl|no|nokia|norton|nowruz|np|nr|nra|nrw|ntt|nu|nyc|nz|obi|office|okinawa|om|omega|one|ong|onl|online|ooo|oracle|orange|org|organic|origins|osaka|otsuka|ovh|pa|page|pamperedchef|panerai|paris|pars|partners|parts|party|passagens|pe|pet|pf|pg|ph|pharmacy|philips|photo|photography|photos|physio|piaget|pics|pictet|pictures|pid|pin|ping|pink|pizza|pk|pl|place|play|playstation|plumbing|plus|pm|pn|pohl|poker|porn|post|pr|praxi|press|pro|prod|productions|prof|promo|properties|property|protection|ps|pt|pub|pw|pwc|py|qa|qpon|quebec|quest|racing|re|read|realtor|realty|recipes|red|redstone|redumbrella|rehab|reise|reisen|reit|ren|rent|rentals|repair|report|republican|rest|restaurant|review|reviews|rexroth|rich|ricoh|rio|rip|ro|rocher|rocks|rodeo|room|rs|rsvp|ru|ruhr|run|rw|rwe|ryukyu|sa|saarland|safe|safety|sakura|sale|salon|samsung|sandvik|sandvikcoromant|sanofi|sap|sapo|sarl|sas|saxo|sb|sbs|sc|sca|scb|schaeffler|schmidt|scholarships|school|schule|schwarz|science|scor|scot|sd|se|seat|security|seek|select|sener|services|seven|sew|sex|sexy|sfr|sg|sh|sharp|shell|shia|shiksha|shoes|show|shriram|si|singles|site|sj|sk|ski|skin|sky|skype|sl|sm|smile|sn|sncf|so|soccer|social|softbank|software|sohu|solar|solutions|song|sony|soy|space|spiegel|spot|spreadbetting|sr|srl|st|stada|star|starhub|statefarm|statoil|stc|stcgroup|stockholm|storage|store|studio|study|style|su|sucks|supplies|supply|support|surf|surgery|suzuki|sv|swatch|swiss|sx|sy|sydney|symantec|systems|sz|tab|taipei|taobao|tatamotors|tatar|tattoo|tax|taxi|tc|tci|td|team|tech|technology|tel|telecity|telefonica|temasek|tennis|tf|tg|th|thd|theater|theatre|tickets|tienda|tiffany|tips|tires|tirol|tj|tk|tl|tm|tmall|tn|to|today|tokyo|tools|top|toray|toshiba|total|tours|town|toyota|toys|tp|tr|trade|trading|training|travel|travelers|travelersinsurance|trust|trv|tt|tube|tui|tunes|tushu|tv|tvs|tw|tz|ua|ubs|ug|uk|unicom|university|uno|uol|us|uy|uz|va|vacations|vana|vc|ve|vegas|ventures|verisign|versicherung|vet|vg|vi|viajes|video|viking|villas|vin|vip|virgin|vision|vista|vistaprint|viva|vlaanderen|vn|vodka|volkswagen|vote|voting|voto|voyage|vu|vuelos|wales|walter|wang|wanggou|watch|watches|weather|weatherchannel|webcam|weber|website|wed|wedding|weir|wf|whoswho|wien|wiki|williamhill|win|windows|wine|wme|wolterskluwer|work|works|world|ws|wtc|wtf|xbox|xerox|xin|xperia|xxx|xyz|yachts|yahoo|yamaxun|yandex|ye|yodobashi|yoga|yokohama|youtube|yt|za|zara|zero|zip|zm|zone|zuerich|zw'.split('|'); // macro, see gulpfile.js
	
	/**
		The scanner provides an interface that takes a string of text as input, and
		outputs an array of tokens instances that can be used for easy URL parsing.
	
		@module linkify
		@submodule scanner
		@main scanner
	*/
	
	var NUMBERS = '0123456789'.split('');
	var ALPHANUM = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');
	var WHITESPACE = [' ', '\f', '\r', '\t', '\v', '\xA0', '\u1680', '\u180E']; // excluding line breaks
	
	var domainStates = []; // states that jump to DOMAIN on /[a-z0-9]/
	var makeState = function makeState(tokenClass) {
		return new _state.CharacterState(tokenClass);
	};
	
	// Frequently used states
	var S_START = makeState();
	var S_NUM = makeState(_text.NUM);
	var S_DOMAIN = makeState(_text.DOMAIN);
	var S_DOMAIN_HYPHEN = makeState(); // domain followed by 1 or more hyphen characters
	var S_WS = makeState(_text.WS);
	
	// States for special URL symbols
	S_START.on('@', makeState(_text.AT)).on('.', makeState(_text.DOT)).on('+', makeState(_text.PLUS)).on('#', makeState(_text.POUND)).on('?', makeState(_text.QUERY)).on('/', makeState(_text.SLASH)).on('_', makeState(_text.UNDERSCORE)).on(':', makeState(_text.COLON)).on('{', makeState(_text.OPENBRACE)).on('[', makeState(_text.OPENBRACKET)).on('<', makeState(_text.OPENANGLEBRACKET)).on('(', makeState(_text.OPENPAREN)).on('}', makeState(_text.CLOSEBRACE)).on(']', makeState(_text.CLOSEBRACKET)).on('>', makeState(_text.CLOSEANGLEBRACKET)).on(')', makeState(_text.CLOSEPAREN)).on('&', makeState(_text.AMPERSAND)).on([',', ';', '!', '"', '\''], makeState(_text.PUNCTUATION));
	
	// Whitespace jumps
	// Tokens of only non-newline whitespace are arbitrarily long
	S_START.on('\n', makeState(_text.NL)).on(WHITESPACE, S_WS);
	
	// If any whitespace except newline, more whitespace!
	S_WS.on(WHITESPACE, S_WS);
	
	// Generates states for top-level domains
	// Note that this is most accurate when tlds are in alphabetical order
	for (var i = 0; i < tlds.length; i++) {
		var newStates = (0, _state.stateify)(tlds[i], S_START, _text.TLD, _text.DOMAIN);
		domainStates.push.apply(domainStates, newStates);
	}
	
	// Collect the states generated by different protocls
	var partialProtocolFileStates = (0, _state.stateify)('file', S_START, _text.DOMAIN, _text.DOMAIN);
	var partialProtocolFtpStates = (0, _state.stateify)('ftp', S_START, _text.DOMAIN, _text.DOMAIN);
	var partialProtocolHttpStates = (0, _state.stateify)('http', S_START, _text.DOMAIN, _text.DOMAIN);
	var partialProtocolMailtoStates = (0, _state.stateify)('mailto', S_START, _text.DOMAIN, _text.DOMAIN);
	
	// Add the states to the array of DOMAINeric states
	domainStates.push.apply(domainStates, partialProtocolFileStates);
	domainStates.push.apply(domainStates, partialProtocolFtpStates);
	domainStates.push.apply(domainStates, partialProtocolHttpStates);
	
	// Protocol states
	var S_PROTOCOL_FILE = partialProtocolFileStates.pop();
	var S_PROTOCOL_FTP = partialProtocolFtpStates.pop();
	var S_PROTOCOL_HTTP = partialProtocolHttpStates.pop();
	var S_MAILTO = partialProtocolMailtoStates.pop();
	var S_PROTOCOL_SECURE = makeState(_text.DOMAIN);
	var S_FULL_PROTOCOL = makeState(_text.PROTOCOL); // Full protocol ends with COLON
	var S_FULL_MAILTO = makeState(_text.MAILTO); // Mailto ends with COLON
	
	// Secure protocols (end with 's')
	S_PROTOCOL_FTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);
	
	S_PROTOCOL_HTTP.on('s', S_PROTOCOL_SECURE).on(':', S_FULL_PROTOCOL);
	
	domainStates.push(S_PROTOCOL_SECURE);
	
	// Become protocol tokens after a COLON
	S_PROTOCOL_FILE.on(':', S_FULL_PROTOCOL);
	S_PROTOCOL_SECURE.on(':', S_FULL_PROTOCOL);
	S_MAILTO.on(':', S_FULL_MAILTO);
	
	// Localhost
	var partialLocalhostStates = (0, _state.stateify)('localhost', S_START, _text.LOCALHOST, _text.DOMAIN);
	domainStates.push.apply(domainStates, partialLocalhostStates);
	
	// Everything else
	// DOMAINs make more DOMAINs
	// Number and character transitions
	S_START.on(NUMBERS, S_NUM);
	S_NUM.on('-', S_DOMAIN_HYPHEN).on(NUMBERS, S_NUM).on(ALPHANUM, S_DOMAIN); // number becomes DOMAIN
	
	S_DOMAIN.on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
	
	// All the generated states should have a jump to DOMAIN
	for (var _i = 0; _i < domainStates.length; _i++) {
		domainStates[_i].on('-', S_DOMAIN_HYPHEN).on(ALPHANUM, S_DOMAIN);
	}
	
	S_DOMAIN_HYPHEN.on('-', S_DOMAIN_HYPHEN).on(NUMBERS, S_DOMAIN).on(ALPHANUM, S_DOMAIN);
	
	// Set default transition
	S_START.defaultTransition = makeState(_text.SYM);
	
	/**
		Given a string, returns an array of TOKEN instances representing the
		composition of that string.
	
		@method run
		@param {String} str Input string to scan
		@return {Array} Array of TOKEN instances
	*/
	var run = function run(str) {
	
		// The state machine only looks at lowercase strings.
		// This selective `toLowerCase` is used because lowercasing the entire
		// string causes the length and character position to vary in some in some
		// non-English strings. This happens only on V8-based runtimes.
		var lowerStr = str.replace(/[A-Z]/g, function (c) {
			return c.toLowerCase();
		});
		var len = str.length;
		var tokens = []; // return value
	
		var cursor = 0;
	
		// Tokenize the string
		while (cursor < len) {
			var state = S_START;
			var secondState = null;
			var nextState = null;
			var tokenLength = 0;
			var latestAccepting = null;
			var sinceAccepts = -1;
	
			while (cursor < len && (nextState = state.next(lowerStr[cursor]))) {
				secondState = null;
				state = nextState;
	
				// Keep track of the latest accepting state
				if (state.accepts()) {
					sinceAccepts = 0;
					latestAccepting = state;
				} else if (sinceAccepts >= 0) {
					sinceAccepts++;
				}
	
				tokenLength++;
				cursor++;
			}
	
			if (sinceAccepts < 0) {
				continue;
			} // Should never happen
	
			// Roll back to the latest accepting state
			cursor -= sinceAccepts;
			tokenLength -= sinceAccepts;
	
			// Get the class for the new token
			var TOKEN = latestAccepting.emit(); // Current token class
	
			// No more jumps, just make a new token
			tokens.push(new TOKEN(str.substr(cursor - tokenLength, tokenLength)));
		}
	
		return tokens;
	};
	
	var start = S_START;
	exports.State = _state.CharacterState;
	exports.TOKENS = TOKENS;
	exports.run = run;
	exports.start = start;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.stateify = exports.TokenState = exports.CharacterState = undefined;
	
	var _class = __webpack_require__(63);
	
	function createStateClass() {
		return function (tClass) {
			this.j = [];
			this.T = tClass || null;
		};
	}
	
	/**
		A simple state machine that can emit token classes
	
		The `j` property in this class refers to state jumps. It's a
		multidimensional array where for each element:
	
		* index [0] is a symbol or class of symbols to transition to.
		* index [1] is a State instance which matches
	
		The type of symbol will depend on the target implementation for this class.
		In Linkify, we have a two-stage scanner. Each stage uses this state machine
		but with a slighly different (polymorphic) implementation.
	
		The `T` property refers to the token class.
	
		TODO: Can the `on` and `next` methods be combined?
	
		@class BaseState
	*/
	var BaseState = createStateClass();
	BaseState.prototype = {
		defaultTransition: false,
	
		/**
	 	@method constructor
	 	@param {Class} tClass Pass in the kind of token to emit if there are
	 		no jumps after this state and the state is accepting.
	 */
	
		/**
	 	On the given symbol(s), this machine should go to the given state
	 		@method on
	 	@param {Array|Mixed} symbol
	 	@param {BaseState} state Note that the type of this state should be the
	 		same as the current instance (i.e., don't pass in a different
	 		subclass)
	 */
		on: function on(symbol, state) {
			if (symbol instanceof Array) {
				for (var i = 0; i < symbol.length; i++) {
					this.j.push([symbol[i], state]);
				}
				return this;
			}
			this.j.push([symbol, state]);
			return this;
		},
	
	
		/**
	 	Given the next item, returns next state for that item
	 	@method next
	 	@param {Mixed} item Should be an instance of the symbols handled by
	 		this particular machine.
	 	@return {State} state Returns false if no jumps are available
	 */
		next: function next(item) {
			for (var i = 0; i < this.j.length; i++) {
				var jump = this.j[i];
				var symbol = jump[0]; // Next item to check for
				var state = jump[1]; // State to jump to if items match
	
				// compare item with symbol
				if (this.test(item, symbol)) {
					return state;
				}
			}
	
			// Nowhere left to jump!
			return this.defaultTransition;
		},
	
	
		/**
	 	Does this state accept?
	 	`true` only of `this.T` exists
	 		@method accepts
	 	@return {Boolean}
	 */
		accepts: function accepts() {
			return !!this.T;
		},
	
	
		/**
	 	Determine whether a given item "symbolizes" the symbol, where symbol is
	 	a class of items handled by this state machine.
	 		This method should be overriden in extended classes.
	 		@method test
	 	@param {Mixed} item Does this item match the given symbol?
	 	@param {Mixed} symbol
	 	@return {Boolean}
	 */
		test: function test(item, symbol) {
			return item === symbol;
		},
	
	
		/**
	 	Emit the token for this State (just return it in this case)
	 	If this emits a token, this instance is an accepting state
	 	@method emit
	 	@return {Class} T
	 */
		emit: function emit() {
			return this.T;
		}
	};
	
	/**
		State machine for string-based input
	
		@class CharacterState
		@extends BaseState
	*/
	var CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {
		/**
	 	Does the given character match the given character or regular
	 	expression?
	 		@method test
	 	@param {String} char
	 	@param {String|RegExp} charOrRegExp
	 	@return {Boolean}
	 */
		test: function test(character, charOrRegExp) {
			return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);
		}
	});
	
	/**
		State machine for input in the form of TextTokens
	
		@class TokenState
		@extends BaseState
	*/
	var TokenState = (0, _class.inherits)(BaseState, createStateClass(), {
	
		/**
	  * Similar to `on`, but returns the state the results in the transition from
	  * the given item
	  * @method jump
	  * @param {Mixed} item
	  * @param {Token} [token]
	  * @return state
	  */
		jump: function jump(token) {
			var tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
			var state = this.next(new token('')); // dummy temp token
			if (state === this.defaultTransition) {
				// Make a new state!
				state = new this.constructor(tClass);
				this.on(token, state);
			} else if (tClass) {
				state.T = tClass;
			}
			return state;
		},
	
	
		/**
	 	Is the given token an instance of the given token class?
	 		@method test
	 	@param {TextToken} token
	 	@param {Class} tokenClass
	 	@return {Boolean}
	 */
		test: function test(token, tokenClass) {
			return token instanceof tokenClass;
		}
	});
	
	/**
		Given a non-empty target string, generates states (if required) for each
		consecutive substring of characters in str starting from the beginning of
		the string. The final state will have a special value, as specified in
		options. All other "in between" substrings will have a default end state.
	
		This turns the state machine into a Trie-like data structure (rather than a
		intelligently-designed DFA).
	
		Note that I haven't really tried these with any strings other than
		DOMAIN.
	
		@param {String} str
		@param {CharacterState} start State to jump from the first character
		@param {Class} endToken Token class to emit when the given string has been
			matched and no more jumps exist.
		@param {Class} defaultToken "Filler token", or which token type to emit when
			we don't have a full match
		@return {Array} list of newly-created states
	*/
	function stateify(str, start, endToken, defaultToken) {
		var i = 0,
		    len = str.length,
		    state = start,
		    newStates = [],
		    nextState = void 0;
	
		// Find the next state without a jump to the next character
		while (i < len && (nextState = state.next(str[i]))) {
			state = nextState;
			i++;
		}
	
		if (i >= len) {
			return [];
		} // no new tokens were added
	
		while (i < len - 1) {
			nextState = new CharacterState(defaultToken);
			newStates.push(nextState);
			state.on(str[i], nextState);
			state = nextState;
			i++;
		}
	
		nextState = new CharacterState(endToken);
		newStates.push(nextState);
		state.on(str[len - 1], nextState);
	
		return newStates;
	}
	
	exports.CharacterState = CharacterState;
	exports.TokenState = TokenState;
	exports.stateify = stateify;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.AMPERSAND = exports.CLOSEPAREN = exports.CLOSEANGLEBRACKET = exports.CLOSEBRACKET = exports.CLOSEBRACE = exports.OPENPAREN = exports.OPENANGLEBRACKET = exports.OPENBRACKET = exports.OPENBRACE = exports.WS = exports.TLD = exports.SYM = exports.UNDERSCORE = exports.SLASH = exports.MAILTO = exports.PROTOCOL = exports.QUERY = exports.POUND = exports.PLUS = exports.NUM = exports.NL = exports.LOCALHOST = exports.PUNCTUATION = exports.DOT = exports.COLON = exports.AT = exports.DOMAIN = exports.Base = undefined;
	
	var _createTokenClass = __webpack_require__(68);
	
	var _class = __webpack_require__(63);
	
	/******************************************************************************
		Text Tokens
		Tokens composed of strings
	******************************************************************************/
	
	/**
		Abstract class used for manufacturing text tokens.
		Pass in the value this token represents
	
		@class TextToken
		@abstract
	*/
	var TextToken = (0, _createTokenClass.createTokenClass)();
	TextToken.prototype = {
		toString: function toString() {
			return this.v + '';
		}
	};
	
	function inheritsToken(value) {
		var props = value ? { v: value } : {};
		return (0, _class.inherits)(TextToken, (0, _createTokenClass.createTokenClass)(), props);
	}
	
	/**
		A valid domain token
		@class DOMAIN
		@extends TextToken
	*/
	var DOMAIN = inheritsToken();
	
	/**
		@class AT
		@extends TextToken
	*/
	var AT = inheritsToken('@');
	
	/**
		Represents a single colon `:` character
	
		@class COLON
		@extends TextToken
	*/
	var COLON = inheritsToken(':');
	
	/**
		@class DOT
		@extends TextToken
	*/
	var DOT = inheritsToken('.');
	
	/**
		A character class that can surround the URL, but which the URL cannot begin
		or end with. Does not include certain English punctuation like parentheses.
	
		@class PUNCTUATION
		@extends TextToken
	*/
	var PUNCTUATION = inheritsToken();
	
	/**
		The word localhost (by itself)
		@class LOCALHOST
		@extends TextToken
	*/
	var LOCALHOST = inheritsToken();
	
	/**
		Newline token
		@class NL
		@extends TextToken
	*/
	var NL = inheritsToken('\n');
	
	/**
		@class NUM
		@extends TextToken
	*/
	var NUM = inheritsToken();
	
	/**
		@class PLUS
		@extends TextToken
	*/
	var PLUS = inheritsToken('+');
	
	/**
		@class POUND
		@extends TextToken
	*/
	var POUND = inheritsToken('#');
	
	/**
		Represents a web URL protocol. Supported types include
	
		* `http:`
		* `https:`
		* `ftp:`
		* `ftps:`
	
		@class PROTOCOL
		@extends TextToken
	*/
	var PROTOCOL = inheritsToken();
	
	/**
		Represents the start of the email URI protocol
	
		@class MAILTO
		@extends TextToken
	*/
	var MAILTO = inheritsToken('mailto:');
	
	/**
		@class QUERY
		@extends TextToken
	*/
	var QUERY = inheritsToken('?');
	
	/**
		@class SLASH
		@extends TextToken
	*/
	var SLASH = inheritsToken('/');
	
	/**
		@class UNDERSCORE
		@extends TextToken
	*/
	var UNDERSCORE = inheritsToken('_');
	
	/**
		One ore more non-whitespace symbol.
		@class SYM
		@extends TextToken
	*/
	var SYM = inheritsToken();
	
	/**
		@class TLD
		@extends TextToken
	*/
	var TLD = inheritsToken();
	
	/**
		Represents a string of consecutive whitespace characters
	
		@class WS
		@extends TextToken
	*/
	var WS = inheritsToken();
	
	/**
		Opening/closing bracket classes
	*/
	
	var OPENBRACE = inheritsToken('{');
	var OPENBRACKET = inheritsToken('[');
	var OPENANGLEBRACKET = inheritsToken('<');
	var OPENPAREN = inheritsToken('(');
	var CLOSEBRACE = inheritsToken('}');
	var CLOSEBRACKET = inheritsToken(']');
	var CLOSEANGLEBRACKET = inheritsToken('>');
	var CLOSEPAREN = inheritsToken(')');
	
	var AMPERSAND = inheritsToken('&');
	
	exports.Base = TextToken;
	exports.DOMAIN = DOMAIN;
	exports.AT = AT;
	exports.COLON = COLON;
	exports.DOT = DOT;
	exports.PUNCTUATION = PUNCTUATION;
	exports.LOCALHOST = LOCALHOST;
	exports.NL = NL;
	exports.NUM = NUM;
	exports.PLUS = PLUS;
	exports.POUND = POUND;
	exports.QUERY = QUERY;
	exports.PROTOCOL = PROTOCOL;
	exports.MAILTO = MAILTO;
	exports.SLASH = SLASH;
	exports.UNDERSCORE = UNDERSCORE;
	exports.SYM = SYM;
	exports.TLD = TLD;
	exports.WS = WS;
	exports.OPENBRACE = OPENBRACE;
	exports.OPENBRACKET = OPENBRACKET;
	exports.OPENANGLEBRACKET = OPENANGLEBRACKET;
	exports.OPENPAREN = OPENPAREN;
	exports.CLOSEBRACE = CLOSEBRACE;
	exports.CLOSEBRACKET = CLOSEBRACKET;
	exports.CLOSEANGLEBRACKET = CLOSEANGLEBRACKET;
	exports.CLOSEPAREN = CLOSEPAREN;
	exports.AMPERSAND = AMPERSAND;

/***/ },
/* 68 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	function createTokenClass() {
		return function (value) {
			if (value) {
				this.v = value;
			}
		};
	}
	
	exports.createTokenClass = createTokenClass;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.start = exports.run = exports.TOKENS = exports.State = undefined;
	
	var _state = __webpack_require__(66);
	
	var _text = __webpack_require__(67);
	
	var TEXT_TOKENS = _interopRequireWildcard(_text);
	
	var _multi = __webpack_require__(70);
	
	var MULTI_TOKENS = _interopRequireWildcard(_multi);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var makeState = function makeState(tokenClass) {
		return new _state.TokenState(tokenClass);
	};
	
	// The universal starting state.
	/**
		Not exactly parser, more like the second-stage scanner (although we can
		theoretically hotswap the code here with a real parser in the future... but
		for a little URL-finding utility abstract syntax trees may be a little
		overkill).
	
		URL format: http://en.wikipedia.org/wiki/URI_scheme
		Email format: http://en.wikipedia.org/wiki/Email_address (links to RFC in
		reference)
	
		@module linkify
		@submodule parser
		@main parser
	*/
	
	var S_START = makeState();
	
	// Intermediate states for URLs. Note that domains that begin with a protocol
	// are treated slighly differently from those that don't.
	var S_PROTOCOL = makeState(); // e.g., 'http:'
	var S_MAILTO = makeState(); // 'mailto:'
	var S_PROTOCOL_SLASH = makeState(); // e.g., '/', 'http:/''
	var S_PROTOCOL_SLASH_SLASH = makeState(); // e.g., '//', 'http://'
	var S_DOMAIN = makeState(); // parsed string ends with a potential domain name (A)
	var S_DOMAIN_DOT = makeState(); // (A) domain followed by DOT
	var S_TLD = makeState(_multi.URL); // (A) Simplest possible URL with no query string
	var S_TLD_COLON = makeState(); // (A) URL followed by colon (potential port number here)
	var S_TLD_PORT = makeState(_multi.URL); // TLD followed by a port number
	var S_URL = makeState(_multi.URL); // Long URL with optional port and maybe query string
	var S_URL_NON_ACCEPTING = makeState(); // URL followed by some symbols (will not be part of the final URL)
	var S_URL_OPENBRACE = makeState(); // URL followed by {
	var S_URL_OPENBRACKET = makeState(); // URL followed by [
	var S_URL_OPENANGLEBRACKET = makeState(); // URL followed by <
	var S_URL_OPENPAREN = makeState(); // URL followed by (
	var S_URL_OPENBRACE_Q = makeState(_multi.URL); // URL followed by { and some symbols that the URL can end it
	var S_URL_OPENBRACKET_Q = makeState(_multi.URL); // URL followed by [ and some symbols that the URL can end it
	var S_URL_OPENANGLEBRACKET_Q = makeState(_multi.URL); // URL followed by < and some symbols that the URL can end it
	var S_URL_OPENPAREN_Q = makeState(_multi.URL); // URL followed by ( and some symbols that the URL can end it
	var S_URL_OPENBRACE_SYMS = makeState(); // S_URL_OPENBRACE_Q followed by some symbols it cannot end it
	var S_URL_OPENBRACKET_SYMS = makeState(); // S_URL_OPENBRACKET_Q followed by some symbols it cannot end it
	var S_URL_OPENANGLEBRACKET_SYMS = makeState(); // S_URL_OPENANGLEBRACKET_Q followed by some symbols it cannot end it
	var S_URL_OPENPAREN_SYMS = makeState(); // S_URL_OPENPAREN_Q followed by some symbols it cannot end it
	var S_EMAIL_DOMAIN = makeState(); // parsed string starts with local email info + @ with a potential domain name (C)
	var S_EMAIL_DOMAIN_DOT = makeState(); // (C) domain followed by DOT
	var S_EMAIL = makeState(_multi.EMAIL); // (C) Possible email address (could have more tlds)
	var S_EMAIL_COLON = makeState(); // (C) URL followed by colon (potential port number here)
	var S_EMAIL_PORT = makeState(_multi.EMAIL); // (C) Email address with a port
	var S_MAILTO_EMAIL = makeState(_multi.MAILTOEMAIL); // Email that begins with the mailto prefix (D)
	var S_MAILTO_EMAIL_NON_ACCEPTING = makeState(); // (D) Followed by some non-query string chars
	var S_LOCALPART = makeState(); // Local part of the email address
	var S_LOCALPART_AT = makeState(); // Local part of the email address plus @
	var S_LOCALPART_DOT = makeState(); // Local part of the email address plus '.' (localpart cannot end in .)
	var S_NL = makeState(_multi.NL); // single new line
	
	// Make path from start to protocol (with '//')
	S_START.on(_text.NL, S_NL).on(_text.PROTOCOL, S_PROTOCOL).on(_text.MAILTO, S_MAILTO).on(_text.SLASH, S_PROTOCOL_SLASH);
	
	S_PROTOCOL.on(_text.SLASH, S_PROTOCOL_SLASH);
	S_PROTOCOL_SLASH.on(_text.SLASH, S_PROTOCOL_SLASH_SLASH);
	
	// The very first potential domain name
	S_START.on(_text.TLD, S_DOMAIN).on(_text.DOMAIN, S_DOMAIN).on(_text.LOCALHOST, S_TLD).on(_text.NUM, S_DOMAIN);
	
	// Force URL for protocol followed by anything sane
	S_PROTOCOL_SLASH_SLASH.on(_text.TLD, S_URL).on(_text.DOMAIN, S_URL).on(_text.NUM, S_URL).on(_text.LOCALHOST, S_URL);
	
	// Account for dots and hyphens
	// hyphens are usually parts of domain names
	S_DOMAIN.on(_text.DOT, S_DOMAIN_DOT);
	S_EMAIL_DOMAIN.on(_text.DOT, S_EMAIL_DOMAIN_DOT);
	
	// Hyphen can jump back to a domain name
	
	// After the first domain and a dot, we can find either a URL or another domain
	S_DOMAIN_DOT.on(_text.TLD, S_TLD).on(_text.DOMAIN, S_DOMAIN).on(_text.NUM, S_DOMAIN).on(_text.LOCALHOST, S_DOMAIN);
	
	S_EMAIL_DOMAIN_DOT.on(_text.TLD, S_EMAIL).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.NUM, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL_DOMAIN);
	
	// S_TLD accepts! But the URL could be longer, try to find a match greedily
	// The `run` function should be able to "rollback" to the accepting state
	S_TLD.on(_text.DOT, S_DOMAIN_DOT);
	S_EMAIL.on(_text.DOT, S_EMAIL_DOMAIN_DOT);
	
	// Become real URLs after `SLASH` or `COLON NUM SLASH`
	// Here PSS and non-PSS converge
	S_TLD.on(_text.COLON, S_TLD_COLON).on(_text.SLASH, S_URL);
	S_TLD_COLON.on(_text.NUM, S_TLD_PORT);
	S_TLD_PORT.on(_text.SLASH, S_URL);
	S_EMAIL.on(_text.COLON, S_EMAIL_COLON);
	S_EMAIL_COLON.on(_text.NUM, S_EMAIL_PORT);
	
	// Types of characters the URL can definitely end in
	var qsAccepting = [_text.DOMAIN, _text.AT, _text.LOCALHOST, _text.NUM, _text.PLUS, _text.POUND, _text.PROTOCOL, _text.SLASH, _text.TLD, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND];
	
	// Types of tokens that can follow a URL and be part of the query string
	// but cannot be the very last characters
	// Characters that cannot appear in the URL at all should be excluded
	var qsNonAccepting = [_text.COLON, _text.DOT, _text.QUERY, _text.PUNCTUATION, _text.CLOSEBRACE, _text.CLOSEBRACKET, _text.CLOSEANGLEBRACKET, _text.CLOSEPAREN, _text.OPENBRACE, _text.OPENBRACKET, _text.OPENANGLEBRACKET, _text.OPENPAREN];
	
	// These states are responsible primarily for determining whether or not to
	// include the final round bracket.
	
	// URL, followed by an opening bracket
	S_URL.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);
	
	// URL with extra symbols at the end, followed by an opening bracket
	S_URL_NON_ACCEPTING.on(_text.OPENBRACE, S_URL_OPENBRACE).on(_text.OPENBRACKET, S_URL_OPENBRACKET).on(_text.OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET).on(_text.OPENPAREN, S_URL_OPENPAREN);
	
	// Closing bracket component. This character WILL be included in the URL
	S_URL_OPENBRACE.on(_text.CLOSEBRACE, S_URL);
	S_URL_OPENBRACKET.on(_text.CLOSEBRACKET, S_URL);
	S_URL_OPENANGLEBRACKET.on(_text.CLOSEANGLEBRACKET, S_URL);
	S_URL_OPENPAREN.on(_text.CLOSEPAREN, S_URL);
	S_URL_OPENBRACE_Q.on(_text.CLOSEBRACE, S_URL);
	S_URL_OPENBRACKET_Q.on(_text.CLOSEBRACKET, S_URL);
	S_URL_OPENANGLEBRACKET_Q.on(_text.CLOSEANGLEBRACKET, S_URL);
	S_URL_OPENPAREN_Q.on(_text.CLOSEPAREN, S_URL);
	S_URL_OPENBRACE_SYMS.on(_text.CLOSEBRACE, S_URL);
	S_URL_OPENBRACKET_SYMS.on(_text.CLOSEBRACKET, S_URL);
	S_URL_OPENANGLEBRACKET_SYMS.on(_text.CLOSEANGLEBRACKET, S_URL);
	S_URL_OPENPAREN_SYMS.on(_text.CLOSEPAREN, S_URL);
	
	// URL that beings with an opening bracket, followed by a symbols.
	// Note that the final state can still be `S_URL_OPENBRACE_Q` (if the URL only
	// has a single opening bracket for some reason).
	S_URL_OPENBRACE.on(qsAccepting, S_URL_OPENBRACE_Q);
	S_URL_OPENBRACKET.on(qsAccepting, S_URL_OPENBRACKET_Q);
	S_URL_OPENANGLEBRACKET.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	S_URL_OPENPAREN.on(qsAccepting, S_URL_OPENPAREN_Q);
	S_URL_OPENBRACE.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
	S_URL_OPENBRACKET.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
	S_URL_OPENANGLEBRACKET.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
	S_URL_OPENPAREN.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);
	
	// URL that begins with an opening bracket, followed by some symbols
	S_URL_OPENBRACE_Q.on(qsAccepting, S_URL_OPENBRACE_Q);
	S_URL_OPENBRACKET_Q.on(qsAccepting, S_URL_OPENBRACKET_Q);
	S_URL_OPENANGLEBRACKET_Q.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	S_URL_OPENPAREN_Q.on(qsAccepting, S_URL_OPENPAREN_Q);
	S_URL_OPENBRACE_Q.on(qsNonAccepting, S_URL_OPENBRACE_Q);
	S_URL_OPENBRACKET_Q.on(qsNonAccepting, S_URL_OPENBRACKET_Q);
	S_URL_OPENANGLEBRACKET_Q.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
	S_URL_OPENPAREN_Q.on(qsNonAccepting, S_URL_OPENPAREN_Q);
	
	S_URL_OPENBRACE_SYMS.on(qsAccepting, S_URL_OPENBRACE_Q);
	S_URL_OPENBRACKET_SYMS.on(qsAccepting, S_URL_OPENBRACKET_Q);
	S_URL_OPENANGLEBRACKET_SYMS.on(qsAccepting, S_URL_OPENANGLEBRACKET_Q);
	S_URL_OPENPAREN_SYMS.on(qsAccepting, S_URL_OPENPAREN_Q);
	S_URL_OPENBRACE_SYMS.on(qsNonAccepting, S_URL_OPENBRACE_SYMS);
	S_URL_OPENBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENBRACKET_SYMS);
	S_URL_OPENANGLEBRACKET_SYMS.on(qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
	S_URL_OPENPAREN_SYMS.on(qsNonAccepting, S_URL_OPENPAREN_SYMS);
	
	// Account for the query string
	S_URL.on(qsAccepting, S_URL);
	S_URL_NON_ACCEPTING.on(qsAccepting, S_URL);
	
	S_URL.on(qsNonAccepting, S_URL_NON_ACCEPTING);
	S_URL_NON_ACCEPTING.on(qsNonAccepting, S_URL_NON_ACCEPTING);
	
	// Email address-specific state definitions
	// Note: We are not allowing '/' in email addresses since this would interfere
	// with real URLs
	
	// For addresses with the mailto prefix
	// 'mailto:' followed by anything sane is a valid email
	S_MAILTO.on(_text.TLD, S_MAILTO_EMAIL).on(_text.DOMAIN, S_MAILTO_EMAIL).on(_text.NUM, S_MAILTO_EMAIL).on(_text.LOCALHOST, S_MAILTO_EMAIL);
	
	// Greedily get more potential valid email values
	S_MAILTO_EMAIL.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
	S_MAILTO_EMAIL_NON_ACCEPTING.on(qsAccepting, S_MAILTO_EMAIL).on(qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
	
	// For addresses without the mailto prefix
	// Tokens allowed in the localpart of the email
	var localpartAccepting = [_text.DOMAIN, _text.NUM, _text.PLUS, _text.POUND, _text.QUERY, _text.UNDERSCORE, _text.SYM, _text.AMPERSAND, _text.TLD];
	
	// Some of the tokens in `localpartAccepting` are already accounted for here and
	// will not be overwritten (don't worry)
	S_DOMAIN.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
	S_TLD.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT);
	S_DOMAIN_DOT.on(localpartAccepting, S_LOCALPART);
	
	// Okay we're on a localpart. Now what?
	// TODO: IP addresses and what if the email starts with numbers?
	S_LOCALPART.on(localpartAccepting, S_LOCALPART).on(_text.AT, S_LOCALPART_AT) // close to an email address now
	.on(_text.DOT, S_LOCALPART_DOT);
	S_LOCALPART_DOT.on(localpartAccepting, S_LOCALPART);
	S_LOCALPART_AT.on(_text.TLD, S_EMAIL_DOMAIN).on(_text.DOMAIN, S_EMAIL_DOMAIN).on(_text.LOCALHOST, S_EMAIL);
	// States following `@` defined above
	
	var run = function run(tokens) {
		var len = tokens.length;
		var cursor = 0;
		var multis = [];
		var textTokens = [];
	
		while (cursor < len) {
			var state = S_START;
			var secondState = null;
			var nextState = null;
			var multiLength = 0;
			var latestAccepting = null;
			var sinceAccepts = -1;
	
			while (cursor < len && !(secondState = state.next(tokens[cursor]))) {
				// Starting tokens with nowhere to jump to.
				// Consider these to be just plain text
				textTokens.push(tokens[cursor++]);
			}
	
			while (cursor < len && (nextState = secondState || state.next(tokens[cursor]))) {
	
				// Get the next state
				secondState = null;
				state = nextState;
	
				// Keep track of the latest accepting state
				if (state.accepts()) {
					sinceAccepts = 0;
					latestAccepting = state;
				} else if (sinceAccepts >= 0) {
					sinceAccepts++;
				}
	
				cursor++;
				multiLength++;
			}
	
			if (sinceAccepts < 0) {
	
				// No accepting state was found, part of a regular text token
				// Add all the tokens we looked at to the text tokens array
				for (var i = cursor - multiLength; i < cursor; i++) {
					textTokens.push(tokens[i]);
				}
			} else {
	
				// Accepting state!
	
				// First close off the textTokens (if available)
				if (textTokens.length > 0) {
					multis.push(new _multi.TEXT(textTokens));
					textTokens = [];
				}
	
				// Roll back to the latest accepting state
				cursor -= sinceAccepts;
				multiLength -= sinceAccepts;
	
				// Create a new multitoken
				var MULTI = latestAccepting.emit();
				multis.push(new MULTI(tokens.slice(cursor - multiLength, cursor)));
			}
		}
	
		// Finally close off the textTokens (if available)
		if (textTokens.length > 0) {
			multis.push(new _multi.TEXT(textTokens));
		}
	
		return multis;
	};
	
	exports.State = _state.TokenState;
	exports.TOKENS = MULTI_TOKENS;
	exports.run = run;
	exports.start = S_START;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.URL = exports.TEXT = exports.NL = exports.EMAIL = exports.MAILTOEMAIL = exports.Base = undefined;
	
	var _createTokenClass = __webpack_require__(68);
	
	var _class = __webpack_require__(63);
	
	var _text = __webpack_require__(67);
	
	/******************************************************************************
		Multi-Tokens
		Tokens composed of arrays of TextTokens
	******************************************************************************/
	
	// Is the given token a valid domain token?
	// Should nums be included here?
	function isDomainToken(token) {
		return token instanceof _text.DOMAIN || token instanceof _text.TLD;
	}
	
	/**
		Abstract class used for manufacturing tokens of text tokens. That is rather
		than the value for a token being a small string of text, it's value an array
		of text tokens.
	
		Used for grouping together URLs, emails, hashtags, and other potential
		creations.
	
		@class MultiToken
		@abstract
	*/
	var MultiToken = (0, _createTokenClass.createTokenClass)();
	
	MultiToken.prototype = {
		/**
	 	String representing the type for this token
	 	@property type
	 	@default 'TOKEN'
	 */
		type: 'token',
	
		/**
	 	Is this multitoken a link?
	 	@property isLink
	 	@default false
	 */
		isLink: false,
	
		/**
	 	Return the string this token represents.
	 	@method toString
	 	@return {String}
	 */
		toString: function toString() {
			var result = [];
			for (var i = 0; i < this.v.length; i++) {
				result.push(this.v[i].toString());
			}
			return result.join('');
		},
	
	
		/**
	 	What should the value for this token be in the `href` HTML attribute?
	 	Returns the `.toString` value by default.
	 		@method toHref
	 	@return {String}
	 */
		toHref: function toHref() {
			return this.toString();
		},
	
	
		/**
	 	Returns a hash of relevant values for this token, which includes keys
	 	* type - Kind of token ('url', 'email', etc.)
	 	* value - Original text
	 	* href - The value that should be added to the anchor tag's href
	 		attribute
	 		@method toObject
	 	@param {String} [protocol] `'http'` by default
	 	@return {Object}
	 */
		toObject: function toObject() {
			var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';
	
			return {
				type: this.type,
				value: this.toString(),
				href: this.toHref(protocol)
			};
		}
	};
	
	/**
		Represents an arbitrarily mailto email address with the prefix included
		@class MAILTO
		@extends MultiToken
	*/
	var MAILTOEMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
		type: 'email',
		isLink: true
	});
	
	/**
		Represents a list of tokens making up a valid email address
		@class EMAIL
		@extends MultiToken
	*/
	var EMAIL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
		type: 'email',
		isLink: true,
		toHref: function toHref() {
			var tokens = this.v;
			return 'mailto:' + this.toString();
		}
	});
	
	/**
		Represents some plain text
		@class TEXT
		@extends MultiToken
	*/
	var TEXT = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: 'text' });
	
	/**
		Multi-linebreak token - represents a line break
		@class NL
		@extends MultiToken
	*/
	var NL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), { type: 'nl' });
	
	/**
		Represents a list of tokens making up a valid URL
		@class URL
		@extends MultiToken
	*/
	var URL = (0, _class.inherits)(MultiToken, (0, _createTokenClass.createTokenClass)(), {
		type: 'url',
		isLink: true,
	
		/**
	 	Lowercases relevant parts of the domain and adds the protocol if
	 	required. Note that this will not escape unsafe HTML characters in the
	 	URL.
	 		@method href
	 	@param {String} protocol
	 	@return {String}
	 */
		toHref: function toHref() {
			var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';
	
			var hasProtocol = false;
			var hasSlashSlash = false;
			var tokens = this.v;
			var result = [];
			var i = 0;
	
			// Make the first part of the domain lowercase
			// Lowercase protocol
			while (tokens[i] instanceof _text.PROTOCOL) {
				hasProtocol = true;
				result.push(tokens[i].toString().toLowerCase());
				i++;
			}
	
			// Skip slash-slash
			while (tokens[i] instanceof _text.SLASH) {
				hasSlashSlash = true;
				result.push(tokens[i].toString());
				i++;
			}
	
			// Lowercase all other characters in the domain
			while (isDomainToken(tokens[i])) {
				result.push(tokens[i].toString().toLowerCase());
				i++;
			}
	
			// Leave all other characters as they were written
			for (; i < tokens.length; i++) {
				result.push(tokens[i].toString());
			}
	
			result = result.join('');
	
			if (!(hasProtocol || hasSlashSlash)) {
				result = protocol + '://' + result;
			}
	
			return result;
		},
		hasProtocol: function hasProtocol() {
			return this.v[0] instanceof _text.PROTOCOL;
		}
	});
	
	exports.Base = MultiToken;
	exports.MAILTOEMAIL = MAILTOEMAIL;
	exports.EMAIL = EMAIL;
	exports.NL = NL;
	exports.TEXT = TEXT;
	exports.URL = URL;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(72).default;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _linkify = __webpack_require__(62);
	
	var linkify = _interopRequireWildcard(_linkify);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var tokenize = linkify.tokenize,
	    options = linkify.options; /**
	                               	Convert strings of text into linkable HTML text
	                               */
	
	var Options = options.Options;
	
	
	function escapeText(text) {
		return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}
	
	function escapeAttr(href) {
		return href.replace(/"/g, '&quot;');
	}
	
	function attributesToString(attributes) {
		if (!attributes) {
			return '';
		}
		var result = [];
	
		for (var attr in attributes) {
			var val = attributes[attr] + '';
			result.push(attr + '="' + escapeAttr(val) + '"');
		}
		return result.join(' ');
	}
	
	function linkifyStr(str) {
		var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
		opts = new Options(opts);
	
		var tokens = tokenize(str);
		var result = [];
	
		for (var i = 0; i < tokens.length; i++) {
			var token = tokens[i];
	
			if (token.type === 'nl' && opts.nl2br) {
				result.push('<br>\n');
				continue;
			} else if (!token.isLink || !opts.check(token)) {
				result.push(escapeText(token.toString()));
				continue;
			}
	
			var _opts$resolve = opts.resolve(token),
			    formatted = _opts$resolve.formatted,
			    formattedHref = _opts$resolve.formattedHref,
			    tagName = _opts$resolve.tagName,
			    className = _opts$resolve.className,
			    target = _opts$resolve.target,
			    attributes = _opts$resolve.attributes;
	
			var link = '<' + tagName + ' href="' + escapeAttr(formattedHref) + '"';
	
			if (className) {
				link += ' class="' + escapeAttr(className) + '"';
			}
	
			if (target) {
				link += ' target="' + escapeAttr(target) + '"';
			}
	
			if (attributes) {
				link += ' ' + attributesToString(attributes);
			}
	
			link += '>' + escapeText(formatted) + '</' + tagName + '>';
			result.push(link);
		}
	
		return result.join('');
	}
	
	if (!String.prototype.linkify) {
		String.prototype.linkify = function (opts) {
			return linkifyStr(this, opts);
		};
	}
	
	exports.default = linkifyStr;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var AdminGuard = (function () {
	    function AdminGuard(ps, router, backendService) {
	        this.ps = ps;
	        this.router = router;
	        this.backendService = backendService;
	    }
	    AdminGuard.prototype.canActivate = function () {
	        var _this = this;
	        return this.backendService.adminLogin(this.ps.adminObject.u, this.ps.adminObject.p)
	            .map(function (response) {
	            if (response.status == "1") {
	                return true;
	            }
	            _this.router.navigate(['/adminlogin']);
	            return false;
	        });
	    };
	    AdminGuard = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _b) || Object, (typeof (_c = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _c) || Object])
	    ], AdminGuard);
	    return AdminGuard;
	    var _a, _b, _c;
	}());
	exports.AdminGuard = AdminGuard;
	var AdminLoginComponent = (function () {
	    function AdminLoginComponent(ps, router, backendService) {
	        this.ps = ps;
	        this.router = router;
	        this.backendService = backendService;
	    }
	    AdminLoginComponent.prototype.preLogin = function (value) {
	        this.ps.adminObject.u = value.adminusername;
	        this.ps.adminObject.p = value.adminpassword;
	        this.router.navigate(['adminpanel']);
	    };
	    AdminLoginComponent = __decorate([
	        core_1.Component({
	            selector: "adminlogin",
	            template: __webpack_require__(370)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _b) || Object, (typeof (_c = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _c) || Object])
	    ], AdminLoginComponent);
	    return AdminLoginComponent;
	    var _a, _b, _c;
	}());
	exports.AdminLoginComponent = AdminLoginComponent;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var http_1 = __webpack_require__(25);
	// Custom imports
	var Rx_1 = __webpack_require__(75);
	__webpack_require__(238);
	__webpack_require__(171);
	__webpack_require__(202);
	var BackendService = (function () {
	    // backendUrl: string = "http://localhost:3000/api"
	    function BackendService(http) {
	        this.http = http;
	        this.backendUrl = "https://nuricks.herokuapp.com/api";
	    }
	    BackendService.prototype.checkAuth = function () {
	        // check for musician or user on backend
	        // return user
	        return this.http.get(this.backendUrl + "/auth/", { withCredentials: true })
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getMusician = function (id) {
	        return this.http.get(this.backendUrl + "/musicians/getMusicianInfoFromURL/" + id, { withCredentials: true })
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getMusicianFromFbid = function (id) {
	        return this.http.get(this.backendUrl + "/musicians/getMusicianInfoFromID/" + id, { withCredentials: true })
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getClientToken = function () {
	        return this.http.get(this.backendUrl + "/transactions/getClientToken")
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.createPaymentInformation = function (fbid, paymentObj) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify(paymentObj);
	        return this.http.post(this.backendUrl + "/users/createPaymentInformation/" + fbid, body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.initiateTransaction = function (amount, price, customerId, isUser, ticketId) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            numberOfTickets: amount,
	            amount: price,
	            customerId: customerId,
	            isUser: isUser,
	            ticketId: ticketId
	        });
	        return this.http.post(this.backendUrl + "/transactions/initiateTransaction/", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.updateEmail = function (fbid, email) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            fbid: fbid,
	            email: email
	        });
	        return this.http.post(this.backendUrl + "/users/updateUserInfo", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.musicianUpdateCC = function (fbid, digits) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            fbid: fbid,
	            digits: digits
	        });
	        return this.http.post(this.backendUrl + "/musicians/updateCardDigits", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.updateCC = function (fbid, digits) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            fbid: fbid,
	            digits: digits
	        });
	        return this.http.post(this.backendUrl + "/users/updateCardDigits", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.updateEventInfo = function (event) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify(event);
	        return this.http.post(this.backendUrl + "/events/updateEventInfo", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.deleteCustomerPaymentInfo = function (fbid) {
	        return this.http.get(this.backendUrl + "/users/deleteCustomerPaymentInfo/" + fbid)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.musicianDeleteCustomerPaymentInfo = function (fbid) {
	        return this.http.get(this.backendUrl + "/musicians/deleteCustomerPaymentInfo/" + fbid)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.deleteMusician = function (fbid) {
	        return this.http.get(this.backendUrl + "/musicians/deleteMusician/" + fbid)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.musicianCreatePaymentInformation = function (fbid, paymentObj) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify(paymentObj);
	        return this.http.post(this.backendUrl + "/musicians/createPaymentInformation/" + fbid, body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.musicianSaveDashboard = function (musicianObject) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            fbid: musicianObject.fbid,
	            email: musicianObject.email,
	            phoneNumber: musicianObject.phoneNumber,
	            stageName: musicianObject.stageName,
	            bio: musicianObject.bio,
	            soundcloudLink: musicianObject.soundcloudLink,
	            instagramLink: musicianObject.instagramLink,
	            youtubeLink: musicianObject.youtubeLink,
	            facebookLink: musicianObject.facebookLink,
	            picture_url: musicianObject.picture_url
	        });
	        return this.http.post(this.backendUrl + "/musicians/updateMusicianInfo", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getMusicianTickets = function (id) {
	        return this.http.get(this.backendUrl + "/tickets/queryTicketByMusician/" + id)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getMusicianTicketsURL = function (url) {
	        return this.http.get(this.backendUrl + "/tickets/queryTicketByMusicianURL/" + url)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getGlobalTickets = function () {
	        return this.http.get(this.backendUrl + "/tickets/queryGlobalTickets")
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getPossibleEvents = function () {
	        return this.http.get(this.backendUrl + "/events/queryPossibleEvents")
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getEventInfoFromID = function (id) {
	        return this.http.get(this.backendUrl + "/events/getEventInfoFromID/" + id)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getTicketFromEventID = function (id) {
	        return this.http.get(this.backendUrl + "/tickets/queryTicketByEventID/" + id)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getTransactionHistory = function (customer_id) {
	        return this.http.get(this.backendUrl + "/transactions/getTransactionsByID/" + customer_id)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.sendEmail = function (event, user, musician, num, t_id) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            headliner: event.headliner,
	            musicianName: musician,
	            eventDate: event.eventDate,
	            doorsOpen: event.doorsOpen,
	            ageRestriction: event.ageRequirement,
	            venueName: event.venue,
	            streetName: event.street_name,
	            address: event.city + ", " + event.state + " " + event.zip_code,
	            eventURL: event.image_url,
	            guestName: user.firstName + " " + user.lastName,
	            transaction_id: t_id,
	            numberInParty: num
	        });
	        return this.http.post(this.backendUrl + "/transactions/sendEmail", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.createTicket = function (fbid, eventId) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            numberSold: 0,
	            isGlobal: false,
	            createdAt: Date(),
	            updatedAt: Date(),
	            MusicianFbid: fbid,
	            EventId: eventId
	        });
	        return this.http.post(this.backendUrl + "/tickets/createTicket", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.adminLogin = function (username, password) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify({
	            "username": username,
	            "password": password
	        });
	        return this.http.post(this.backendUrl + "/admins/login", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.createEvent = function (formobj) {
	        var headers = new http_1.Headers({ "Content-Type": "application/json", "Accept": "application/json" });
	        var options = new http_1.RequestOptions({ headers: headers });
	        var body = JSON.stringify(formobj);
	        return this.http.post(this.backendUrl + "/events/createEvent", body, options)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getAllMusicians = function () {
	        return this.http.get(this.backendUrl + "/musicians/allMusicians")
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.getAllEvents = function () {
	        return this.http.get(this.backendUrl + "/events/allEvents")
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.logout = function () {
	        return this.http.get(this.backendUrl + "/auth/logout", { withCredentials: true })
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    BackendService.prototype.extractData = function (res) {
	        var body = res.json();
	        return body || {};
	    };
	    BackendService.prototype.handleError = function (error) {
	        var errMsg = (error.message) ? error.message :
	            error.status ? error.status + " - " + error.statusText : "Server error";
	        // Return the error
	        return Rx_1.Observable.throw(errMsg);
	    };
	    BackendService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof http_1.Http !== 'undefined' && http_1.Http) === 'function' && _a) || Object])
	    ], BackendService);
	    return BackendService;
	    var _a;
	}());
	exports.BackendService = BackendService;


/***/ },
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	var backend_service_1 = __webpack_require__(74);
	// keep user logged in
	var PersistentService = (function () {
	    function PersistentService(backendService, router) {
	        this.backendService = backendService;
	        this.router = router;
	        this.musicianObject = {
	            email: "",
	            phoneNumber: "",
	            fbid: "",
	            stageName: "",
	            firstName: "",
	            lastName: "",
	            soundcloudLink: "",
	            bio: "",
	            instagramLink: "",
	            youtubeLink: "",
	            facebookLink: "",
	            picture_url: "",
	            verified: false,
	            urlValue: "",
	            events: [],
	            possibleEvents: [],
	            customer_id: "",
	            card_digits: ""
	        };
	        this.userObject = {
	            email: "",
	            fbid: "",
	            customer_id: "",
	            firstName: "",
	            lastName: "",
	            picture_url: "",
	            card_digits: ""
	        };
	        this.globalUserObject = {
	            events: []
	        };
	        this.adminObject = {
	            u: "",
	            p: ""
	        };
	    }
	    PersistentService.prototype.resolve = function (route, state) {
	        var _this = this;
	        return this.backendService.checkAuth()
	            .map(function (response) {
	            if (response.status == "1" && response.musician_info) {
	                console.log("Musician");
	                var a = response.musician_info;
	                _this.musicianObject.email = a.email;
	                _this.musicianObject.phoneNumber = a.phoneNumber;
	                _this.musicianObject.fbid = a.fbid;
	                _this.musicianObject.stageName = a.stageName;
	                _this.musicianObject.firstName = a.firstName;
	                _this.musicianObject.lastName = a.lastName;
	                _this.musicianObject.soundcloudLink = a.soundcloudLink;
	                _this.musicianObject.bio = a.bio;
	                _this.musicianObject.instagramLink = a.instagramLink;
	                _this.musicianObject.youtubeLink = a.youtubeLink;
	                _this.musicianObject.facebookLink = a.facebookLink;
	                _this.musicianObject.picture_url = a.picture_url;
	                _this.musicianObject.verified = a.verified;
	                _this.musicianObject.urlValue = a.urlValue;
	                _this.musicianObject.customer_id = a.customer_id;
	                _this.musicianObject.card_digits = a.card_digits;
	                // exception for facebook weirdness
	                if (state.url == '/' || state.url == '/#_=_') {
	                    _this.router.navigate(['/dashboard']);
	                }
	            }
	            if (response.status == "1" && response.user_info) {
	                console.log("User");
	                var a = response.user_info;
	                _this.userObject.email = a.email;
	                _this.userObject.fbid = a.fbid;
	                _this.userObject.customer_id = a.customer_id;
	                _this.userObject.firstName = a.firstName;
	                _this.userObject.lastName = a.lastName;
	                _this.userObject.picture_url = a.picture_url;
	                _this.userObject.card_digits = a.card_digits;
	            }
	        }).first();
	    };
	    PersistentService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _b) || Object])
	    ], PersistentService);
	    return PersistentService;
	    var _a, _b;
	}());
	exports.PersistentService = PersistentService;


/***/ },
/* 370 */
/***/ function(module, exports) {

	module.exports = "<div class=\"adminPanel\">\n    <form class=\"adminLogin\" #feedback=\"ngForm\" (ngSubmit)=\"preLogin(feedback.value)\">\n        <h3 class=\"warning\"></h3>\n        <div style=\"margin-top: 100px\"></div>\n        <label for=\"adminUsername\">Username:</label>\n        <input type=\"text\" name=\"adminusername\" id=\"adminUsername\" required ngModel>\n        <label for=\"adminPassword\">Password:</label>\n        <input type=\"password\" name=\"adminpassword\" id=\"adminPassword\" required ngModel>\n        <button>Login</button>\n    </form>\n</div>\n";

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var AdminService = (function () {
	    function AdminService() {
	        this.musicians = [];
	        this.events = [];
	    }
	    return AdminService;
	}());
	exports.AdminService = AdminService;
	var AdminPanelComponent = (function () {
	    function AdminPanelComponent(ps, backendService, as) {
	        this.ps = ps;
	        this.backendService = backendService;
	        this.as = as;
	        this.musicianView = {
	            email: "",
	            fbid: "",
	            stageName: "",
	            firstName: "",
	            lastName: "",
	            soundcloudLink: "",
	            bio: "",
	            instagramLink: "",
	            youtubeLink: "",
	            facebookLink: "",
	            picture_url: "",
	            urlValue: "",
	            verified: false,
	        };
	        this.ticketView = {
	            eventName: '',
	            tickets: []
	        };
	        this.index = 0;
	        $(document).ready(function () {
	            $('.adminTabs').children().click(function (e) {
	                var toShow = "." + $(e.currentTarget).attr('data-show');
	                $('.adminTabs').children().removeClass('active');
	                $(e.currentTarget).addClass('active');
	                $('.adminPanel > div,form').hide(150);
	                $(toShow).delay(150).show();
	            });
	            $('.showImg').click(function (e) {
	                var ele = $('.adminTabs').children()[1];
	                var toShow = "." + $(ele).attr('data-show');
	                $('.adminTabs').children().removeClass('active');
	                $(ele).addClass('active');
	                $('.adminPanel > div,form').hide(150);
	                $(toShow).delay(150).show();
	            });
	            $('.artistBlock .exit').click(function () {
	                $(this).parent().fadeOut(150);
	            });
	            $('#createShow').click(function () {
	                $('.createShow').show();
	            });
	        });
	    }
	    AdminPanelComponent.prototype.eventCallback = function (index) {
	        var _this = this;
	        if (this.as.events[index]) {
	            this.backendService.getTicketFromEventID(this.as.events[index].id)
	                .subscribe(function (response) {
	                if (response.status == "1") {
	                    _this.as.events[index].tickets = response.tickets;
	                    _this.eventCallback(index + 1);
	                }
	            });
	        }
	    };
	    AdminPanelComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.backendService.getAllMusicians()
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.as.musicians = response.musicians;
	            }
	        });
	        this.backendService.getAllEvents()
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.as.events = response.events;
	                _this.eventCallback(0);
	            }
	        });
	    };
	    AdminPanelComponent.prototype.deleteMusician = function (idex) {
	        var _this = this;
	        this.backendService.deleteMusician(this.as.musicians[idex].fbid)
	            .subscribe(function (response) {
	            console.log(response);
	            if (response["status"] == "1") {
	                _this.as.musicians.splice(idex, 1);
	            }
	        });
	    };
	    AdminPanelComponent.prototype.getMusician = function (idex) {
	        this.musicianView = this.as.musicians[idex];
	        $('#musicianModal').fadeIn(150);
	    };
	    AdminPanelComponent.prototype.saveMusician = function (idex) {
	        var mu = this.as.musicians[idex];
	        mu.firstName = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(2) h2 span:nth-child(1)")[0].childNodes[0].data;
	        mu.lastName = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(2) h2 span:nth-child(2)")[0].childNodes[0].data;
	        mu.stageName = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(3) h2")[0].childNodes[0].data;
	        mu.email = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(4) h2")[0].childNodes[0].data;
	        mu.phoneNumber = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(5) h2")[0].childNodes[0].data;
	        mu.fbid = $("#musicianTable tbody tr:nth-child(" + (idex + 2) + ") td:nth-child(7) h2")[0].childNodes[0].data;
	        if (mu.stageName == "Not Specified") {
	            mu.stageName = "";
	        }
	        if (mu.email == "Not Specified") {
	            mu.email = "";
	        }
	        if (mu.phoneNumber == "Not Specified") {
	            mu.phoneNumber = "";
	        }
	        this.backendService.musicianSaveDashboard(mu)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                console.log("UPDATE OK");
	            }
	        });
	    };
	    AdminPanelComponent.prototype.editEvent = function (idex) {
	        var event = this.as.events[idex];
	        event.eventName = $(".showBlock:nth-child(" + (idex + 1) + ") span")[0].innerHTML;
	        event.headliner = $(".showBlock:nth-child(" + (idex + 1) + ") span")[1].innerHTML;
	        event.street_name = $(".showBlock:nth-child(" + (idex + 1) + ") span")[2].innerHTML;
	        event.city = $(".showBlock:nth-child(" + (idex + 1) + ") span")[3].innerHTML;
	        event.state = $(".showBlock:nth-child(" + (idex + 1) + ") span")[4].innerHTML;
	        event.zip_code = $(".showBlock:nth-child(" + (idex + 1) + ") span")[5].innerHTML;
	        event.venue = $(".showBlock:nth-child(" + (idex + 1) + ") span")[6].innerHTML;
	        event.eventDate = new Date($(".showBlock:nth-child(" + (idex + 1) + ") span")[7].innerHTML);
	        event.cost = ($(".showBlock:nth-child(" + (idex + 1) + ") span")[8].innerHTML).slice(1);
	        event.updatedAt = new Date();
	        this.backendService.updateEventInfo(event)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                console.log("EVENT UPDATE OK");
	            }
	        });
	    };
	    AdminPanelComponent.prototype.getMusicianNet = function (i) {
	        var _this = this;
	        this.backendService.getMusicianFromFbid(this.ticketView.tickets[i].MusicianFbid)
	            .subscribe(function (response) {
	            _this.ticketView.tickets[i].firstName = response.musician_info.firstName;
	            _this.ticketView.tickets[i].lastName = response.musician_info.lastName;
	            _this.ticketView.tickets[i].stageName = response.musician_info.stageName;
	            _this.ticketView.tickets[i].phoneNumber = response.musician_info.phoneNumber;
	            ++i;
	            if (i < _this.ticketView.tickets.length) {
	                _this.getMusician(i);
	            }
	        });
	    };
	    AdminPanelComponent.prototype.getEvent = function (idex) {
	        this.ticketView.tickets = this.as.events[idex].tickets;
	        this.ticketView.eventName = this.as.events[idex].eventName;
	        if (this.ticketView.tickets && this.ticketView.tickets.length > 0) {
	            this.getMusicianNet(0);
	        }
	    };
	    AdminPanelComponent.prototype.addShow = function (form) {
	        form.zip_code = parseInt(form.zip_code);
	        form.cost = parseInt(form.cost);
	        form.extraAtDoor = parseInt(form.extraAtDoor);
	        form.numberNeededToSell = parseInt(form.numberNeededToSell);
	        form.isPossibleEvent = form.isPossibleEvent == "" ? false : true;
	        form.eventDate = new Date($("#day").val() + " " + $("#month").val() + " " + $("#year").val());
	        form.ShowStarts = form.ShowStarts + " " + $("#startMeridian").val();
	        form.doorsOpen = form.doorsOpen + " " + $("#openMeridian").val();
	        this.backendService.createEvent(form)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                window.scrollTo(0, 0);
	                $(".createSuccess").show().delay(2500).fadeOut();
	            }
	        });
	    };
	    AdminPanelComponent = __decorate([
	        core_1.Component({
	            selector: "adminpanel",
	            template: __webpack_require__(372)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _b) || Object, AdminService])
	    ], AdminPanelComponent);
	    return AdminPanelComponent;
	    var _a, _b;
	}());
	exports.AdminPanelComponent = AdminPanelComponent;


/***/ },
/* 372 */
/***/ function(module, exports) {

	module.exports = "<style>\n[contenteditable=true] {\n    padding: 0px;\n}\nspan {\n    cursor: text;\n}\n</style>\n<div class=\"artistBlock modal\" id=\"musicianModal\" style=\"display: none\">\n    <i class=\"fa fa-times exit\"></i>\n    <div class=\"artistImg\" [style.background-image]=\"'url('+ musicianView.picture_url +')'\"></div>\n    <h1>Name:</h1>\n    <h2>{{musicianView.stageName}}</h2>\n    <h2>{{musicianView.firstName}} {{musicianView.lastName}}</h2>\n    <h1>Email: <a>{{musicianView.email || \"No Email\"}}</a></h1>\n    <h1>Phone Number: {{musicianView.phoneNumber}}</h1>\n    <h1>Created: <span>{{musicianView.createdAt | date: \"yMMMMd\"}}</span></h1>\n    <h1>Link: <a style=\"word-break: break-all;\" [routerLink]=\"'/musician/' + musicianView.urlValue\" target=\"_blank\">http://www.nrshows.com/musician/{{musicianView.urlValue}}</a></h1>\n    <h1>Social:\n        <a><i [attr.href]=\"musicianView.facebookLink\" target=\"_blank\" *ngIf=\"musicianView.facebookLink != null   && musicianView.facebookLink != ''\"   class=\"fa fa-facebook\"></i></a>\n        <a><i [attr.href]=\"musicianView.soundcloudLink\" target=\"_blank\" *ngIf=\"musicianView.soundcloudLink != null && musicianView.soundcloudLink != ''\" class=\"fa fa-soundcloud\"></i></a>\n        <a><i [attr.href]=\"musicianView.instagramLink\" target=\"_blank\" *ngIf=\"musicianView.instagramLink != null  && musicianView.instagramLink != ''\"  class=\"fa fa-instagram\"></i></a>\n        <a><i [attr.href]=\"musicianView.youtubeLink\" target=\"_blank\" *ngIf=\"musicianView.youtubeLink != null    && musicianView.youtubeLink != ''\"    class=\"fa fa-youtube\"></i></a>\n    </h1>\n</div>\n<div class=\"artistBlock modal\" id=\"ticketModal\" style=\"display: none\">\n    <i class=\"fa fa-times exit\"></i>\n    <h2 *ngIf=\"ticketView.tickets.length <= 0\">No tickets available for this show.</h2>\n    <ul *ngIf=\"ticketView.tickets.length > 0\">\n        <li *ngFor=\"let ticket of ticketView.tickets; let idex = index\">\n            <h1>Ticket #{{idex+1}}</h1>\n            <h1>Name:</h1>\n            <h2>{{ticket.MusicianFbid}}</h2>\n            <h1>Tickets Sold:</h1>\n            <h2>{{ticket.numberSold}}</h2>\n            <h1>Created: <span>{{ticket.createdAt | date: \"yMMMMd\"}}</span></h1>\n            <hr>\n        </li>\n    </ul>\n</div>\n<div class=\"adminPanel\" style=\"margin-top: 100px\">\n    <span class=\"createSuccess dShadow\" style=\"display: none\">\n        <i class=\"fa fa-times exit\"></i>\n        New show created\n    </span>\n    <span class=\"adminTabs\">\n        <span class=\"active\" data-show=\"adminAllShows\">All Shows</span>\n        <span data-show=\"adminAllArtistsB\">Event Viewer</span>\n        <span data-show=\"_adminAllArtists\">All Artists</span>\n        <span data-show=\"addShowForm\" id=\"createShow\">Create Show</span>\n    </span>\n    <div class=\"adminAllShows\">\n        <input type=\"text\" placeholder=\"Search Shows\" class=\"showSearch\">\n        <div class=\"showgrid\">\n\n            <div *ngFor=\"let event of as.events; let idex = index\" class=\"showBlock SBVertical\">\n                <a (click)=\"getEvent(idex)\" data-show=\"adminAllArtists\" class=\"showImg\" [style.background-image]=\"'url('+ event.image_url +')'\"></a>\n                <div class=\"showDetails\">\n                    <h1><span contenteditable=\"true\">{{event.eventName}}</span></h1>\n                    <h2>Headliner: <span contenteditable=\"true\">{{event.headliner}}</span></h2>\n                    <h3>Address: <span contenteditable=\"true\">{{event.street_name}}</span>, <span contenteditable=\"true\">{{event.city}}</span>, <span contenteditable=\"true\">{{event.state}}</span> <span contenteditable=\"true\">{{event.zip_code}}</span></h3>\n                    <h3>Venue: <span contenteditable=\"true\">{{event.venue}}</span></h3>\n                    <h3><span contenteditable=\"true\">{{event.eventDate | date: \"yMMMMd\"}}</span> &mdash; <span contenteditable=\"true\">${{event.cost}}</span></h3>\n                    <a (click)=\"editEvent(idex)\"><i class=\"fa fa-save\"></i> Save</a>\n                </div>\n            </div>\n\n        </div>\n    </div>\n    <div class=\"adminAllArtists adminAllArtistsB\" id=\"eventArtist\" style=\"display: none\">\n        <h1 class=\"title\" *ngIf=\"!ticketView.eventName\">No event selected.</h1>\n        <h1 class=\"title\">{{ticketView.eventName}}</h1>\n        <div class=\"artistGrid\">\n            <div *ngIf=\"!ticketView.tickets.length && ticketView.eventName\">No tickets for this event.</div>\n            <div *ngFor=\"let ticket of ticketView.tickets; let idex = index\">\n                <h1>Ticket #{{idex+1}}</h1>\n                <h2>Stage Name: {{ticket.stageName}}</h2>\n                <h2>Real Name: {{ticket.firstName}} {{ticket.lastName}}</h2>\n                <h2>Phone Number: {{ticket.phoneNumber}}</h2>\n                <h2>Tickets Sold:</h2>\n                <h2>{{ticket.numberSold}}</h2>\n                <h1>Created: <span>{{ticket.createdAt | date: \"yMMMMd\"}}</span></h1>\n            </div>\n        </div>\n    </div>\n    <div class=\"adminAllArtists _adminAllArtists\" style=\"display: none\">\n        <input type=\"text\" placeholder=\"Search Artists\" class=\"artistSearch\">\n\n        <!-- <div class=\"artistGrid\">\n            <div (click)=\"getMusician(idex)\" *ngFor=\"let musician of as.musicians; let idex = index\">\n                <h1>{{musician.firstName}} {{musician.lastName}}</h1>\n                <h2>{{musician.fbid}}</h2>\n            </div>\n        </div> -->\n\n        <table id=\"musicianTable\">\n            <tr>\n                <th>Delete/Edit</th>\n                <th>Artist Name</th>\n                <th>Stage Name</th>\n                <th>Email</th>\n                <th>Phone</th>\n                <th>Joined</th>\n                <th>Artist ID</th>\n            <tr *ngFor=\"let musician of as.musicians; let idex = index\">\n                <td nowrap=\"\">\n                    <i (click)=\"deleteMusician(idex)\" style=\"background: #cc0000\" class=\"fa fa-times optionBtn\"></i>\n                    <i (click)=\"saveMusician(idex)\" class=\"fa fa-save optionBtn\"></i>\n                </td>\n                <td><h2><span contenteditable=\"true\">{{musician.firstName}}</span> <span contenteditable=\"true\">{{musician.lastName}}</span></h2></td>\n                <td><h2 contenteditable=\"true\">{{musician.stageName || \"Not Specified\"}}</h2></td>\n                <td><h2 contenteditable=\"true\">{{musician.email || \"Not Specified\"}}</h2></td>\n                <td><h2 contenteditable=\"true\">{{musician.phoneNumber || \"Not Specified\"}}</h2></td>\n                <td><h2 contenteditable=\"false\">{{musician.createdAt | date: \"yMMMMd\"}}</h2></td>\n                <td><h2 contenteditable=\"false\">{{musician.fbid}}</h2></td>\n            </tr>\n        </table>\n    </div>\n    <form style=\"display: none\" #form=\"ngForm\" (ngSubmit)=\"addShow(form.value)\" class=\"createShow\">\n        <h1 class=\"title\">Add a show</h1>\n        <h3>All fields are required.</h3>\n        <hr>\n        <label for=\"eventName\">Event Name:</label>\n        <input name=\"eventName\" type=\"text\" id=\"eventName\" placeholder=\"Event name\" ngModel>\n        <label for=\"headliner\">Headliner:</label>\n        <input name=\"headliner\" type=\"text\" id=\"headliner\" placeholder=\"Headliner\" ngModel>\n        <label for=\"venue\">Venue:</label>\n        <input name=\"venue\" type=\"text\" id=\"venue\" placeholder=\"Venue\" ngModel>\n        <h2 for=\"eventDate\">Event Date:</h2>\n        <div>\n            <select id=\"day\">\n                <option value=\"1\">01</option>\n                <option value=\"2\">02</option>\n                <option value=\"3\">03</option>\n                <option value=\"4\">04</option>\n                <option value=\"5\">05</option>\n                <option value=\"6\">06</option>\n                <option value=\"7\">07</option>\n                <option value=\"8\">08</option>\n                <option value=\"9\">09</option>\n                <option value=\"10\">10</option>\n                <option value=\"11\">11</option>\n                <option value=\"12\">12</option>\n                <option value=\"13\">13</option>\n                <option value=\"14\">14</option>\n                <option value=\"15\">15</option>\n                <option value=\"16\">16</option>\n                <option value=\"17\">17</option>\n                <option value=\"18\">18</option>\n                <option value=\"19\">19</option>\n                <option value=\"20\">20</option>\n                <option value=\"21\">21</option>\n                <option value=\"22\">22</option>\n                <option value=\"23\">23</option>\n                <option value=\"24\">24</option>\n                <option value=\"25\">25</option>\n                <option value=\"26\">26</option>\n                <option value=\"27\">27</option>\n                <option value=\"28\">28</option>\n                <option value=\"29\">29</option>\n                <option value=\"30\">30</option>\n                <option value=\"31\">31</option>\n            </select>\n            <select id=\"month\">\n                <option value=\"January\">January</option>\n                <option value=\"February\">February</option>\n                <option value=\"March\">March</option>\n                <option value=\"April\">April</option>\n                <option value=\"May\">May</option>\n                <option value=\"June\">June</option>\n                <option value=\"July\">July</option>\n                <option value=\"August\">August</option>\n                <option value=\"September\">September</option>\n                <option value=\"October\">October</option>\n                <option value=\"November\">November</option>\n                <option value=\"December\">December</option>\n            </select>\n            <select id=\"year\">\n                <option value=\"2015\">2015</option>\n                <option value=\"2016\">2016</option>\n                <option value=\"2017\">2017</option>\n                <option value=\"2018\">2018</option>\n                <option value=\"2019\">2019</option>\n                <option value=\"2020\">2020</option>\n                <option value=\"2021\">2021</option>\n                <option value=\"2022\">2022</option>\n                <option value=\"2023\">2023</option>\n                <option value=\"2024\">2024</option>\n                <option value=\"2025\">2025</option>\n            </select>\n        </div>\n        <h2>Event Image:</h2>\n        <input name=\"image_url\" type=\"text\" id=\"imageUrl\" placeholder=\"Image URL\" ngModel>\n        <h1>Event Time</h1>\n        <label for=\"doorsOpen\">Doors Open:</label>\n        <span>\n            <input name=\"doorsOpen\" type=\"text\" id=\"doorsOpen\" placeholder=\"Doors open time\" required ngModel>\n            <select id=\"openMeridian\">\n                <option value=\"AM\">AM</option>\n                <option value=\"PM\">PM</option>\n            </select>\n        </span>\n        <label for=\"showStarts\">Show Starts:</label>\n        <span>\n            <input name=\"ShowStarts\" type=\"text\" id=\"showStarts\" placeholder=\"Show start time\" required ngModel>\n            <select id=\"startMeridian\">\n                <option value=\"AM\">AM</option>\n                <option value=\"PM\">PM</option>\n            </select>\n        </span>\n        <h1>Event Location</h1>\n        <label for=\"eventStreet\">Street:</label>\n        <input name=\"street_name\" type=\"text\" id=\"eventStreet\" placeholder=\"Street\" required ngModel>\n        <label for=\"eventZIP\">ZIP Code:</label>\n        <input name=\"zip_code\" type=\"text\" id=\"eventZIP\" placeholder=\"ZIP code\" required ngModel>\n        <label for=\"eventCity\">City:</label>\n        <input name=\"city\" type=\"text\" id=\"eventCity\" placeholder=\"City\" required ngModel>\n        <label for=\"eventState\">State:</label>\n        <input name=\"state\" type=\"text\" id=\"eventState\" placeholder=\"State\" required ngModel>\n        <h1>Ticket Info</h1>\n        <label for=\"eventCost\">Ticket Cost:</label>\n        <span><p>$</p><input name=\"cost\" type=\"text\" id=\"eventCost\" placeholder=\"Event cost\" required ngModel></span>\n        <label for=\"eventAtDoor\">Extra Cost At Door:</label>\n        <span><p>$</p> <input name=\"extraAtDoor\" type=\"text\" id=\"eventAtDoor\" placeholder=\"Extra cost at door\" required ngModel></span>\n        <label for=\"ticketsRequired\">Minimum Tickets:</label>\n        <input name=\"numberNeededToSell\" type=\"text\" id=\"ticketsRequired\" placeholder=\"Minimum tickets an artist must sell\" required ngModel>\n        <label for=\"eventAge\">Age Requirement:</label>\n        <input name=\"ageRequirement\" type=\"text\" id=\"eventAge\" placeholder=\"Age requirement\" required ngModel>\n        <label for=\"availableEvent\">Make event available to all artists? <input name=\"isPossibleEvent\" type=\"checkbox\" id=\"availableEvent\" ngModel></label>\n        <button type=\"submit\">Add Event</button>\n    </form>\n</div>\n";

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var NavComponent = (function () {
	    function NavComponent(backendService, ps, router) {
	        this.backendService = backendService;
	        this.ps = ps;
	        this.router = router;
	        $(document).ready(function () {
	            // Expand Nu-Ricks logo on hover
	            $(".logo").hover(function (e) {
	                $(e.currentTarget).text("Nu-Ricks");
	            }, function (e) {
	                $(e.currentTarget).text("NR");
	            });
	            // Expand menu on mobile
	            $(".hamburger").click(function () {
	                $(".hamburger").toggleClass("fold");
	                $(".mainWrapper").toggleClass("menuOpen");
	            });
	            // dissolve navbar when not at top
	            $(window).scroll(function () {
	                var navbar = $("nav");
	                if ($(window).scrollTop() == 0) {
	                    navbar.fadeIn(200);
	                }
	                else {
	                    navbar.fadeOut(200);
	                }
	            });
	            $("#mLogin").click(function () {
	                if (!$("body").hasClass("drop")) {
	                    $("body").addClass("drop");
	                    $(".loginOverlay").delay(250).fadeIn();
	                }
	                else {
	                    $(".loginOverlay").fadeOut().queue(function (next) {
	                        $("body").removeClass("drop");
	                        next();
	                    });
	                }
	            });
	        });
	    }
	    NavComponent.prototype.logout = function () {
	        this.router.navigate(['/']);
	        this.backendService.logout()
	            .subscribe(function (response) {
	            if (response.status) {
	                location.reload();
	            }
	        });
	    };
	    NavComponent = __decorate([
	        core_1.Component({
	            selector: 'nuricks-nav',
	            template: __webpack_require__(374)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _b) || Object, (typeof (_c = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _c) || Object])
	    ], NavComponent);
	    return NavComponent;
	    var _a, _b, _c;
	}());
	exports.NavComponent = NavComponent;


/***/ },
/* 374 */
/***/ function(module, exports) {

	module.exports = "<nav style=\"top: 0\">\n\t<div class=\"navbar\">\n\t\t<div class=\"hamburger\">\n\t\t\t<div></div>\n\t\t</div>\n\t</div>\n\t<a [routerLink]=\"['/']\" class=\"logo\">NR</a>\n\t<ul class=\"pages\">\n\t\t<li style=\"font-weight: 900\" class=\"login\" id=\"mLogin\" *ngIf=\"ps.userObject.fbid == '' && ps.musicianObject.fbid == ''\"><a>Login</a></li>\n        <li style=\"font-weight: 900\" *ngIf=\"ps.musicianObject.fbid != ''\"><a>{{ps.musicianObject.firstName}}</a></li>\n\t\t<li style=\"font-weight: 900\" *ngIf=\"ps.userObject.fbid != ''\"><a>{{ps.userObject.firstName}}</a></li>\n\t\t<li [routerLink]=\"['/musicianuser']\" *ngIf=\"ps.musicianObject.fbid != ''\"><a>Account</a></li>\n\t\t<li style=\"font-weight: 100\" [routerLink]=\"['/dashboard']\" *ngIf=\"ps.musicianObject.fbid != ''\"><a>Musician Dashboard</a></li>\n\t\t<li [routerLink]=\"['/user']\" *ngIf=\"ps.userObject.fbid != ''\"><a>Account</a></li>\n        <li style=\"font-weight: 100\" *ngIf=\"ps.userObject.fbid != '' || ps.musicianObject.fbid != ''\"><a (click)=\"logout()\">logout</a></li>\n\t</ul>\n</nav>\n<div class=\"loginOverlay\" style=\"display: none\">\n\t<div class=\"center\">\n\t\t<a class=\"visitorLogin\" href=\"http://nuricks.herokuapp.com/api/users/auth/facebook\">\n\t\t\t<h1>Visitor Access</h1>\n\t\t\t<span><i class=\"fa fa-facebook\"></i>Facebook Login</span>\n\t\t</a>\n\t\t<a class=\"musicianLogin\" href=\"http://nuricks.herokuapp.com/api/musicians/auth/facebook\">\n\t\t\t<h1>Musician Access</h1>\n\t\t\t<span><i class=\"fa fa-facebook\"></i>Facebook Login</span>\n\t\t</a>\n\t</div>\n</div>\n";

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var UserComponent = (function () {
	    function UserComponent(ps, backendService, zone) {
	        this.ps = ps;
	        this.backendService = backendService;
	        this.zone = zone;
	        this.transactions = [];
	        this.braintree = __webpack_require__(376);
	        this.clientKey = "";
	    }
	    UserComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        $(document).ready(function () {
	            $('.userTabs').children().click(function (e) {
	                var toShow = "." + $(e.currentTarget).attr('data-show');
	                $('.userTabs').children().removeClass('activeTab');
	                $(e.currentTarget).addClass('activeTab');
	                $('._userpanel').hide(150);
	                $(toShow).delay(150).show();
	            });
	        });
	        if (this.ps.userObject.customer_id) {
	            this.backendService.getTransactionHistory(this.ps.userObject.customer_id)
	                .subscribe(function (response) {
	                _this.transactions = response.transactions;
	            });
	        }
	        var c = this;
	        this.backendService.getClientToken()
	            .subscribe(function (response) {
	            // Create a client.
	            _this.braintree.client.create({
	                authorization: response.tok
	            }, function (clientErr, clientInstance) {
	                // Stop if there was a problem creating the client.
	                // This could happen if there is a network error or if the authorization
	                // is invalid.
	                if (clientErr) {
	                    console.error('Error creating client:', clientErr);
	                    return;
	                }
	                // Create a PayPal Checkout component.
	                c.braintree.paypalCheckout.create({
	                    client: clientInstance
	                }, function (paypalCheckoutErr, paypalCheckoutInstance) {
	                    // Stop if there was a problem creating PayPal Checkout.
	                    // This could happen if there was a network error or if it's incorrectly
	                    // configured.
	                    if (paypalCheckoutErr) {
	                        console.error('Error creating PayPal Checkout:', paypalCheckoutErr);
	                        return;
	                    }
	                    // Set up PayPal with the checkout.js library
	                    paypal.Button.render({
	                        env: 'sandbox',
	                        payment: function () {
	                            return paypalCheckoutInstance.createPayment({});
	                        },
	                        onAuthorize: function (data, actions) {
	                            return paypalCheckoutInstance.tokenizePayment(data)
	                                .then(function (payload) {
	                                console.log(payload);
	                            });
	                        },
	                        onCancel: function (data) {
	                            console.log('checkout.js payment cancelled', data);
	                        },
	                        onError: function (err) {
	                            console.error('checkout.js error', err);
	                        }
	                    }, '#paypal-button').then(function () {
	                        // The PayPal button will be rendered in an html element with the id
	                        // `paypal-button`. This function will be called when the PayPal button
	                        // is set up and ready to be used.
	                    });
	                });
	            });
	        });
	    };
	    UserComponent.prototype.updateCID = function (id) {
	        var _this = this;
	        this.zone.run(function () { return _this.ps.userObject.customer_id = id; });
	        this.ngOnInit();
	    };
	    UserComponent.prototype.updateCC = function (payload) {
	        var _this = this;
	        this.backendService.updateCC(this.ps.userObject.fbid, payload.details.lastTwo)
	            .subscribe(function (response) {
	            console.log(response);
	            _this.zone.run(function () { return _this.ps.userObject.card_digits = response.user.card_digits; });
	        });
	    };
	    UserComponent.prototype.cardNewWindow = function () {
	        var _this = this;
	        var t = (screen.height / 2) - (250);
	        var l = (screen.width / 2) - (300);
	        this.popup = window.open('', '_blank', 'toolbar=0,resizable=0,top=' + t + ',left=' + l + ',menubar=0,height=500,width=600');
	        this.popup.document.open();
	        this.popup.document.write("<script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script><style id=_card_styling>*,:after,:before{box-sizing:inherit}html{box-sizing:border-box;height:100%;overflow:hidden}body{background:#f2f2f2;font-family:Roboto,verdana,sans-serif;height:100%}h1{font-size:1.5em;font-weight:100}#cardForm{height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.panel{background:#fff;width:80%;box-shadow:0 2px 2px 0 rgba(0,0,0,.16),0 0 2px 0 rgba(0,0,0,.12)}.panel__header{background:#3f51b5;color:#fff}.panel__footer,.panel__header{padding:1em 2em}.panel__footer{background:#f3f3f3}.panel__content{padding:1em 2em;overflow:hidden}.textfield--float-label{width:50%;float:left;display:inline-block}.hosted-field--label{-webkit-transform:translateY(.4em);transform:translateY(.4em);font-size:1.125em;line-height:32px;-webkit-transition:all .15s ease-out;transition:all .15s ease-out;display:block;width:100%;font-weight:400;overflow:hidden;margin-bottom:.5em}.hosted-field--label.filled,.hosted-field--label.invalid,.hosted-field--label.label-float{height:33px;margin-bottom:-1px;-webkit-transform:translate(0,0);transform:translate(0,0);font-size:12px;line-height:15px;text-overflow:ellipsis;color:#2196f3;-webkit-transition:all .15s ease-out;transition:all .15s ease-out}.hosted-field--label.filled{color:rgba(0,0,0,.54)}.hosted-field--label.invalid{color:#f44336}span.icon{position:relative;top:.2em;margin-right:.2em}svg{fill:#333}.hosted-field{height:32px;margin-bottom:1em;display:block;background-color:transparent;color:rgba(0,0,0,.87);border:none;border-bottom:1px solid rgba(0,0,0,.26);outline:0;width:100%;font-size:16px;padding:0;box-shadow:none;border-radius:0;position:relative}.pay-button{background:#e91e63;color:#fff;margin:0 auto;border:0;border-radius:3px;padding:1em 3em;font-size:1em;text-transform:uppercase;box-shadow:0 0 2px rgba(0,0,0,.12),0 2px 2px rgba(0,0,0,.2)}.braintree-hosted-fields-focused{border-bottom:2px solid #3f51b5;-webkit-transition:all .2s ease;transition:all .2s ease}.braintree-hosted-fields-invalid{border-bottom:2px solid #e91e63;-webkit-transition:all .2s ease;transition:all .2s ease}@media (max-width:600px){html{overflow:auto}#cardForm{height:auto;margin:2em;font-size:13px}.panel{width:100%}.textfield--float-label{width:100%;float:none;display:inline-block}.pay-button{width:100%}}</style><form action=\"\" id=cardForm method=post><div class=panel><header class=panel__header><h1>Card Payment</h1></header><div id=error-message></div><div class=panel__content><div class=textfield--float-label><label class=hosted-field--label for=card-number><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M0 0h24v24H0z\"fill=none /><path d=\"M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z\"/></svg> </span>Card Number</label><div class=hosted-field id=card-number name=card-number></div></div><div class=textfield--float-label><label class=hosted-field--label for=cvv><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z\"/></svg> </span>CVV</label><div class=hosted-field id=cvv name=cvv></div></div><div class=textfield--float-label><label class=hosted-field--label for=expiration-date><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z\"/></svg> </span>Expiration Date</label><div class=hosted-field id=expiration-date name=expiration-date></div></div></div><input name=payment_method_nonce type=hidden><footer class=panel__footer><button class=pay-button type=\"submit\">Add Card</button></footer></div></form>");
	        this.popup_doc = this.popup.document;
	        this.submit = this.popup_doc.querySelector('.pay-button');
	        this.form = this.popup_doc.querySelector('#cardForm');
	        var c = this;
	        this.backendService.getClientToken()
	            .subscribe(function (response) {
	            _this.clientKey = response.tok;
	            _this.braintree.client.create({
	                authorization: _this.clientKey
	            }, function (clientErr, clientInstance) {
	                if (clientErr) {
	                    return;
	                }
	                $(c.popup_doc).ready(function () {
	                    c.popup["braintree"].hostedFields.create({
	                        client: clientInstance,
	                        styles: {
	                            'input': {
	                                'font-size': '14pt'
	                            },
	                            'input.invalid': {
	                                'color': 'red'
	                            },
	                            'input.valid': {
	                                'color': 'green'
	                            }
	                        },
	                        fields: {
	                            number: {
	                                selector: '#card-number',
	                                placeholder: '4111 1111 1111 1111'
	                            },
	                            cvv: {
	                                selector: '#cvv',
	                                placeholder: '123'
	                            },
	                            expirationDate: {
	                                selector: '#expiration-date',
	                                placeholder: '10/2019'
	                            }
	                        }
	                    }, function (hostedFieldsErr, hostedFieldsInstance) {
	                        var form = c.popup_doc.querySelector("#cardForm");
	                        if (hostedFieldsErr) {
	                            // Handle error in Hosted Fields creation
	                            return;
	                        }
	                        // c.submit.removeAttribute('disabled');
	                        form.addEventListener('submit', function (event) {
	                            event.preventDefault();
	                            hostedFieldsInstance.tokenize(function (tokenizeErr, payload) {
	                                var payState = payload;
	                                if (tokenizeErr) {
	                                    // Handle error in Hosted Fields tokenization
	                                    return;
	                                }
	                                var u = {
	                                    payment_method_nonce: payload.nonce
	                                };
	                                c.backendService.createPaymentInformation(c.ps.userObject.fbid, u)
	                                    .subscribe(function (response) {
	                                    console.log(response);
	                                    c.popup.close();
	                                    c.updateCID(response.user.customer_id);
	                                    c.updateCC(payState);
	                                });
	                            });
	                        }, false);
	                    });
	                });
	            });
	        });
	    };
	    UserComponent.prototype.paypalWindow = function () {
	    };
	    UserComponent.prototype.updateEmail = function () {
	        var _this = this;
	        this.backendService.updateEmail(this.ps.userObject.fbid, $("#emailInput").val())
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.ps.userObject.email = response.user.email;
	            }
	        });
	    };
	    UserComponent.prototype.deleteAccount = function () {
	    };
	    UserComponent.prototype.deletePaymentMethod = function () {
	        var _this = this;
	        this.backendService.deleteCustomerPaymentInfo(this.ps.userObject.fbid)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.updateCID(null);
	            }
	        });
	    };
	    UserComponent = __decorate([
	        core_1.Component({
	            selector: "user",
	            template: __webpack_require__(549)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _b) || Object, (typeof (_c = typeof core_1.NgZone !== 'undefined' && core_1.NgZone) === 'function' && _c) || Object])
	    ], UserComponent);
	    return UserComponent;
	    var _a, _b, _c;
	}());
	exports.UserComponent = UserComponent;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web
	 * @description This is the top-level module exported by the Braintree JavaScript SDK. In a browser environment, this will be the global <code>braintree</code> object. In a CommonJS environment (like Browserify or Webpack), it will be the default export of the <code>braintree-web</code> package. In AMD environments (like RequireJS), it can be `require`d like other modules.
	 * @example
	 * <caption>CommonJS</caption>
	 * var braintree = require('braintree-web');
	 *
	 * braintree.client.create(...);
	 * @example
	 * <caption>In the browser</caption>
	 * <script src="https://js.braintreegateway.com/web/{@pkg version}/js/client.min.js"></script>
	 * <script>
	 *   window.braintree.client.create(...);
	 * </script>
	 * @example
	 * <caption>AMD</caption>
	 * // main.js
	 * require.config({
	 *   paths: {
	 *     braintreeClient: 'https://js.braintreegateway.com/web/{@pkg version}/js/client.min'
	 *   }
	 * });
	 *
	 * require(['braintreeClient'], function (braintreeClient) {
	 *   braintreeClient.create(...);
	 * });
	 */
	
	/**
	 * @global
	 * @callback callback
	 * @param {?BraintreeError} [err] `null` or `undefined` if there was no error.
	 * @param {?any} [data] The successful result of the asynchronous function call (if data exists).
	 * @description The Node.js-style callback pattern used throughout the SDK.
	 * @returns {void}
	 */
	
	var client = __webpack_require__(377);
	var paypal = __webpack_require__(410);
	var paypalCheckout = __webpack_require__(442);
	var hostedFields = __webpack_require__(445);
	var dataCollector = __webpack_require__(458);
	var americanExpress = __webpack_require__(520);
	var unionpay = __webpack_require__(523);
	var vaultManager = __webpack_require__(527);
	var applePay = __webpack_require__(529);
	var threeDSecure = __webpack_require__(532);
	var usBankAccount = __webpack_require__(538);
	var visaCheckout = __webpack_require__(542);
	var masterpass = __webpack_require__(545);
	var VERSION = "3.14.0";
	
	module.exports = {
	  /** @type {module:braintree-web/client} */
	  client: client,
	  /** @type {module:braintree-web/paypal} */
	  paypal: paypal,
	  /** @type {module:braintree-web/paypal-checkout} */
	  paypalCheckout: paypalCheckout,
	  /** @type {module:braintree-web/hosted-fields} */
	  hostedFields: hostedFields,
	  /** @type {module:braintree-web/three-d-secure} */
	  threeDSecure: threeDSecure,
	  /** @type {module:braintree-web/data-collector} */
	  dataCollector: dataCollector,
	  /** @type {module:braintree-web/american-express} */
	  americanExpress: americanExpress,
	  /** @type {module:braintree-web/unionpay} */
	  unionpay: unionpay,
	  /** @type {module:braintree-web/apple-pay} */
	  applePay: applePay,
	  /** @type {module:braintree-web/us-bank-account} */
	  usBankAccount: usBankAccount,
	  /** @type {module:braintree-web/visa-checkout} */
	  visaCheckout: visaCheckout,
	  /** @type {module:braintree-web/vault-manager} */
	  vaultManager: vaultManager,
	  /** @type {module:braintree-web/masterpass} */
	  masterpass: masterpass,
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var Client = __webpack_require__(380);
	var getConfiguration = __webpack_require__(405).getConfiguration;
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var sharedErrors = __webpack_require__(404);
	
	/** @module braintree-web/client */
	
	/**
	 * @function create
	 * @description This function is the entry point for the <code>braintree.client</code> module. It is used for creating {@link Client} instances that service communication to Braintree servers.
	 * @param {object} options Object containing all {@link Client} options:
	 * @param {string} options.authorization A tokenizationKey or clientToken.
	 * @param {callback} [callback] The second argument, <code>data</code>, is the {@link Client} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * var createClient = require('braintree-web/client').create;
	 *
	 * createClient({
	 *   authorization: CLIENT_AUTHORIZATION
	 * }, function (createErr, clientInstance) {
	 *   // ...
	 * });
	 * @static
	 */
	function create(options) {
	  if (!options.authorization) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.authorization is required when instantiating a client.'
	    }));
	  }
	
	  return getConfiguration(options).then(function (configuration) {
	    if (options.debug) {
	      configuration.isDebug = true;
	    }
	
	    return new Client(configuration);
	  });
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enumerate = __webpack_require__(379);
	
	/**
	 * @class
	 * @global
	 * @param {object} options Construction options
	 * @classdesc This class is used to report error conditions, frequently as the first parameter to callbacks throughout the Braintree SDK.
	 * @description <strong>You cannot use this constructor directly. Interact with instances of this class through {@link callback callbacks}.</strong>
	 */
	function BraintreeError(options) {
	  if (!BraintreeError.types.hasOwnProperty(options.type)) {
	    throw new Error(options.type + ' is not a valid type.');
	  }
	
	  if (!options.code) {
	    throw new Error('Error code required.');
	  }
	
	  if (!options.message) {
	    throw new Error('Error message required.');
	  }
	
	  this.name = 'BraintreeError';
	
	  /**
	   * @type {string}
	   * @description A code that corresponds to specific errors.
	   */
	  this.code = options.code;
	
	  /**
	   * @type {string}
	   * @description A short description of the error.
	   */
	  this.message = options.message;
	
	  /**
	   * @type {BraintreeError.types}
	   * @description The type of error.
	   */
	  this.type = options.type;
	
	  /**
	   * @type {object=}
	   * @description Additional information about the error, such as an underlying network error response.
	   */
	  this.details = options.details;
	}
	
	BraintreeError.prototype = Object.create(Error.prototype);
	BraintreeError.prototype.constructor = BraintreeError;
	
	/**
	 * Enum for {@link BraintreeError} types.
	 * @name BraintreeError.types
	 * @enum
	 * @readonly
	 * @memberof BraintreeError
	 * @property {string} CUSTOMER An error caused by the customer.
	 * @property {string} MERCHANT An error that is actionable by the merchant.
	 * @property {string} NETWORK An error due to a network problem.
	 * @property {string} INTERNAL An error caused by Braintree code.
	 * @property {string} UNKNOWN An error where the origin is unknown.
	 */
	BraintreeError.types = enumerate([
	  'CUSTOMER',
	  'MERCHANT',
	  'NETWORK',
	  'INTERNAL',
	  'UNKNOWN'
	]);
	
	BraintreeError.findRootError = function (err) {
	  if (err instanceof BraintreeError && err.details && err.details.originalError) {
	    return BraintreeError.findRootError(err.details.originalError);
	  }
	
	  return err;
	};
	
	module.exports = BraintreeError;


/***/ },
/* 379 */
/***/ function(module, exports) {

	'use strict';
	
	function enumerate(values, prefix) {
	  prefix = prefix == null ? '' : prefix;
	
	  return values.reduce(function (enumeration, value) {
	    enumeration[value] = prefix + value;
	    return enumeration;
	  }, {});
	}
	
	module.exports = enumerate;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var request = __webpack_require__(381);
	var isWhitelistedDomain = __webpack_require__(392);
	var BraintreeError = __webpack_require__(378);
	var convertToBraintreeError = __webpack_require__(393);
	var addMetadata = __webpack_require__(394);
	var Promise = __webpack_require__(399);
	var once = __webpack_require__(382);
	var deferred = __webpack_require__(401);
	var assign = __webpack_require__(387).assign;
	var constants = __webpack_require__(402);
	var errors = __webpack_require__(403);
	var sharedErrors = __webpack_require__(404);
	
	/**
	 * This object is returned by {@link Client#getConfiguration|getConfiguration}. This information is used extensively by other Braintree modules to properly configure themselves.
	 * @typedef {object} Client~configuration
	 * @property {object} client The braintree-web/client parameters.
	 * @property {string} client.authorization A tokenizationKey or clientToken.
	 * @property {object} gatewayConfiguration Gateway-supplied configuration.
	 * @property {object} analyticsMetadata Analytics-specific data.
	 * @property {string} analyticsMetadata.sessionId Uniquely identifies a browsing session.
	 * @property {string} analyticsMetadata.sdkVersion The braintree.js version.
	 * @property {string} analyticsMetadata.merchantAppId Identifies the merchant's web app.
	 */
	
	/**
	 * @class
	 * @param {Client~configuration} configuration Options
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/client.create|braintree.client.create} instead.</strong>
	 * @classdesc This class is required by many other Braintree components. It serves as the base API layer that communicates with our servers. It is also capable of being used to formulate direct calls to our servers, such as direct credit card tokenization. See {@link Client#request}.
	 */
	function Client(configuration) {
	  var configurationJSON, gatewayConfiguration, braintreeApiConfiguration;
	
	  configuration = configuration || {};
	
	  configurationJSON = JSON.stringify(configuration);
	  gatewayConfiguration = configuration.gatewayConfiguration;
	
	  if (!gatewayConfiguration) {
	    throw new BraintreeError(errors.CLIENT_MISSING_GATEWAY_CONFIGURATION);
	  }
	
	  [
	    'assetsUrl',
	    'clientApiUrl',
	    'configUrl'
	  ].forEach(function (property) {
	    if (property in gatewayConfiguration && !isWhitelistedDomain(gatewayConfiguration[property])) {
	      throw new BraintreeError({
	        type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
	        code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
	        message: property + ' property is on an invalid domain.'
	      });
	    }
	  });
	
	  /**
	   * Returns a copy of the configuration values.
	   * @public
	   * @returns {Client~configuration} configuration
	   */
	  this.getConfiguration = function () {
	    return JSON.parse(configurationJSON);
	  };
	
	  this._request = request;
	  this._configuration = this.getConfiguration();
	
	  this._clientApiBaseUrl = gatewayConfiguration.clientApiUrl + '/v1/';
	
	  braintreeApiConfiguration = gatewayConfiguration.braintreeApi;
	  if (braintreeApiConfiguration) {
	    this._braintreeApi = {
	      baseUrl: braintreeApiConfiguration.url + '/',
	      accessToken: braintreeApiConfiguration.accessToken
	    };
	
	    if (!isWhitelistedDomain(this._braintreeApi.baseUrl)) {
	      throw new BraintreeError({
	        type: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.type,
	        code: errors.CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN.code,
	        message: 'braintreeApi URL is on an invalid domain.'
	      });
	    }
	  }
	}
	
	/**
	 * Used by other modules to formulate all network requests to the Braintree gateway. It is also capable of being used directly from your own form to tokenize credit card information. However, be sure to satisfy PCI compliance if you use direct card tokenization.
	 * @public
	 * @param {object} options Request options:
	 * @param {string} options.method HTTP method, e.g. "get" or "post".
	 * @param {string} options.endpoint Endpoint path, e.g. "payment_methods".
	 * @param {object} options.data Data to send with the request.
	 * @param {number} [options.timeout=60000] Set a timeout (in milliseconds) for the request.
	 * @param {callback} [callback] The second argument, <code>data</code>, is the returned server data.
	 * @example
	 * <caption>Direct Credit Card Tokenization</caption>
	 * var createClient = require('braintree-web/client').create;
	 *
	 * createClient({
	 *   authorization: CLIENT_AUTHORIZATION
	 * }, function (createErr, clientInstance) {
	 *   var form = document.getElementById('my-form-id');
	 *   var data = {
	 *     creditCard: {
	 *       number: form['cc-number'].value,
	 *       cvv: form['cc-cvv'].value,
	 *       expirationDate: form['cc-date'].value,
	 *       billingAddress: {
	 *         postalCode: form['cc-postal'].value
	 *       },
	 *       options: {
	 *         validate: false
	 *       }
	 *     }
	 *   };
	 *
	 *   // Warning: For a merchant to be eligible for the easiest level of PCI compliance (SAQ A),
	 *   // payment fields cannot be hosted on your checkout page.
	 *   // For an alternative to the following, use Hosted Fields.
	 *   clientInstance.request({
	 *     endpoint: 'payment_methods/credit_cards',
	 *     method: 'post',
	 *     data: data
	 *   }, function (requestErr, response) {
	 *     // More detailed example of handling API errors: https://codepen.io/braintree/pen/MbwjdM
	 *     if (requestErr) { throw new Error(requestErr); }
	 *
	 *     console.log('Got nonce:', response.creditCards[0].nonce);
	 *   });
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	Client.prototype.request = function (options, callback) {
	  var self = this; // eslint-disable-line no-invalid-this
	  var requestPromise = new Promise(function (resolve, reject) {
	    var optionName, api, baseUrl, requestOptions;
	
	    if (!options.method) {
	      optionName = 'options.method';
	    } else if (!options.endpoint) {
	      optionName = 'options.endpoint';
	    }
	
	    if (optionName) {
	      throw new BraintreeError({
	        type: errors.CLIENT_OPTION_REQUIRED.type,
	        code: errors.CLIENT_OPTION_REQUIRED.code,
	        message: optionName + ' is required when making a request.'
	      });
	    }
	
	    if ('api' in options) {
	      api = options.api;
	    } else {
	      api = 'clientApi';
	    }
	
	    requestOptions = {
	      method: options.method,
	      timeout: options.timeout
	    };
	
	    if (api === 'clientApi') {
	      baseUrl = self._clientApiBaseUrl;
	
	      requestOptions.data = addMetadata(self._configuration, options.data);
	    } else if (api === 'braintreeApi') {
	      if (!self._braintreeApi) {
	        throw new BraintreeError(sharedErrors.BRAINTREE_API_ACCESS_RESTRICTED);
	      }
	
	      baseUrl = self._braintreeApi.baseUrl;
	
	      requestOptions.data = options.data;
	
	      requestOptions.headers = {
	        'Braintree-Version': constants.BRAINTREE_API_VERSION_HEADER,
	        Authorization: 'Bearer ' + self._braintreeApi.accessToken
	      };
	    } else {
	      throw new BraintreeError({
	        type: errors.CLIENT_OPTION_INVALID.type,
	        code: errors.CLIENT_OPTION_INVALID.code,
	        message: 'options.api is invalid.'
	      });
	    }
	
	    requestOptions.url = baseUrl + options.endpoint;
	
	    self._request(requestOptions, function (err, data, status) {
	      var resolvedData;
	      var requestError = formatRequestError(status, err);
	
	      if (requestError) {
	        reject(requestError);
	        return;
	      }
	
	      resolvedData = assign({_httpStatus: status}, data);
	
	      resolve(resolvedData);
	    });
	  });
	
	  if (typeof callback === 'function') {
	    callback = once(deferred(callback));
	
	    requestPromise.then(function (response) {
	      callback(null, response, response._httpStatus);
	    }).catch(function (err) {
	      var status = err && err.details && err.details.httpStatus;
	
	      callback(err, null, status);
	    });
	    return;
	  }
	
	  return requestPromise; // eslint-disable-line consistent-return
	};
	
	function formatRequestError(status, err) { // eslint-disable-line consistent-return
	  var requestError;
	
	  if (status === -1) {
	    requestError = new BraintreeError(errors.CLIENT_REQUEST_TIMEOUT);
	  } else if (status === 403) {
	    requestError = new BraintreeError(errors.CLIENT_AUTHORIZATION_INSUFFICIENT);
	  } else if (status === 429) {
	    requestError = new BraintreeError(errors.CLIENT_RATE_LIMITED);
	  } else if (status >= 500) {
	    requestError = new BraintreeError(errors.CLIENT_GATEWAY_NETWORK);
	  } else if (status < 200 || status >= 400) {
	    requestError = convertToBraintreeError(err, {
	      type: errors.CLIENT_REQUEST_ERROR.type,
	      code: errors.CLIENT_REQUEST_ERROR.code,
	      message: errors.CLIENT_REQUEST_ERROR.message
	    });
	  }
	
	  if (requestError) {
	    requestError.details = requestError.details || {};
	    requestError.details.httpStatus = status;
	
	    return requestError;
	  }
	}
	
	Client.prototype.toJSON = function () {
	  return this.getConfiguration();
	};
	
	module.exports = Client;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var ajaxIsAvaliable;
	var once = __webpack_require__(382);
	var JSONPDriver = __webpack_require__(383);
	var AJAXDriver = __webpack_require__(386);
	var getUserAgent = __webpack_require__(390);
	var isHTTP = __webpack_require__(391);
	
	function isAjaxAvailable() {
	  if (ajaxIsAvaliable == null) {
	    ajaxIsAvaliable = !(isHTTP() && /MSIE\s(8|9)/.test(getUserAgent()));
	  }
	
	  return ajaxIsAvaliable;
	}
	
	module.exports = function (options, cb) {
	  cb = once(cb || Function.prototype);
	  options.method = (options.method || 'GET').toUpperCase();
	  options.timeout = options.timeout == null ? 60000 : options.timeout;
	  options.data = options.data || {};
	
	  if (isAjaxAvailable()) {
	    AJAXDriver.request(options, cb);
	  } else {
	    JSONPDriver.request(options, cb);
	  }
	};


/***/ },
/* 382 */
/***/ function(module, exports) {

	'use strict';
	
	function once(fn) {
	  var called = false;
	
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(null, arguments);
	    }
	  };
	}
	
	module.exports = once;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var head;
	var uuid = __webpack_require__(384);
	var querystring = __webpack_require__(385);
	var timeouts = {};
	
	function _removeScript(script) {
	  if (script && script.parentNode) {
	    script.parentNode.removeChild(script);
	  }
	}
	
	function _createScriptTag(url, callbackName) {
	  var script = document.createElement('script');
	  var done = false;
	
	  script.src = url;
	  script.async = true;
	  script.onerror = function () {
	    global[callbackName]({message: 'error', status: 500});
	  };
	
	  script.onload = script.onreadystatechange = function () {
	    if (done) { return; }
	
	    if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') {
	      done = true;
	      script.onload = script.onreadystatechange = null;
	    }
	  };
	
	  return script;
	}
	
	function _cleanupGlobal(callbackName) {
	  try {
	    delete global[callbackName];
	  } catch (_) {
	    global[callbackName] = null;
	  }
	}
	
	function _setupTimeout(timeout, callbackName) {
	  timeouts[callbackName] = setTimeout(function () {
	    timeouts[callbackName] = null;
	
	    global[callbackName]({
	      error: 'timeout',
	      status: -1
	    });
	
	    global[callbackName] = function () {
	      _cleanupGlobal(callbackName);
	    };
	  }, timeout);
	}
	
	function _setupGlobalCallback(script, callback, callbackName) {
	  global[callbackName] = function (response) {
	    var status = response.status || 500;
	    var err = null;
	    var data = null;
	
	    delete response.status;
	
	    if (status >= 400 || status < 200) {
	      err = response;
	    } else {
	      data = response;
	    }
	
	    _cleanupGlobal(callbackName);
	    _removeScript(script);
	
	    clearTimeout(timeouts[callbackName]);
	    callback(err, data, status);
	  };
	}
	
	function request(options, callback) {
	  var script;
	  var callbackName = 'callback_json_' + uuid().replace(/-/g, '');
	  var url = options.url;
	  var attrs = options.data;
	  var method = options.method;
	  var timeout = options.timeout;
	
	  url = querystring.queryify(url, attrs);
	  url = querystring.queryify(url, {
	    _method: method,
	    callback: callbackName
	  });
	
	  script = _createScriptTag(url, callbackName);
	  _setupGlobalCallback(script, callback, callbackName);
	  _setupTimeout(timeout, callbackName);
	
	  if (!head) {
	    head = document.getElementsByTagName('head')[0];
	  }
	
	  head.appendChild(script);
	}
	
	module.exports = {
	  request: request
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 384 */
/***/ function(module, exports) {

	'use strict';
	
	function uuid() {
	  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	    var r = Math.random() * 16 | 0;
	    var v = c === 'x' ? r : r & 0x3 | 0x8;
	
	    return v.toString(16);
	  });
	}
	
	module.exports = uuid;


/***/ },
/* 385 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	function _notEmpty(obj) {
	  var key;
	
	  for (key in obj) {
	    if (obj.hasOwnProperty(key)) { return true; }
	  }
	
	  return false;
	}
	
	function _isArray(value) {
	  return value && typeof value === 'object' && typeof value.length === 'number' &&
	    Object.prototype.toString.call(value) === '[object Array]' || false;
	}
	
	function parse(url) {
	  var query, params;
	
	  url = url || global.location.href;
	
	  if (!/\?/.test(url)) {
	    return {};
	  }
	
	  query = url.replace(/#.*$/, '').replace(/^.*\?/, '').split('&');
	
	  params = query.reduce(function (toReturn, keyValue) {
	    var parts = keyValue.split('=');
	    var key = decodeURIComponent(parts[0]);
	    var value = decodeURIComponent(parts[1]);
	
	    toReturn[key] = value;
	    return toReturn;
	  }, {});
	
	  return params;
	}
	
	function stringify(params, namespace) {
	  var k, v, p;
	  var query = [];
	
	  for (p in params) {
	    if (!params.hasOwnProperty(p)) {
	      continue;
	    }
	
	    v = params[p];
	
	    if (namespace) {
	      if (_isArray(params)) {
	        k = namespace + '[]';
	      } else {
	        k = namespace + '[' + p + ']';
	      }
	    } else {
	      k = p;
	    }
	    if (typeof v === 'object') {
	      query.push(stringify(v, k));
	    } else {
	      query.push(encodeURIComponent(k) + '=' + encodeURIComponent(v));
	    }
	  }
	
	  return query.join('&');
	}
	
	function queryify(url, params) {
	  url = url || '';
	
	  if (params != null && typeof params === 'object' && _notEmpty(params)) {
	    url += url.indexOf('?') === -1 ? '?' : '';
	    url += url.indexOf('=') !== -1 ? '&' : '';
	    url += stringify(params);
	  }
	
	  return url;
	}
	
	module.exports = {
	  parse: parse,
	  stringify: stringify,
	  queryify: queryify
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var querystring = __webpack_require__(385);
	var assign = __webpack_require__(387).assign;
	var prepBody = __webpack_require__(388);
	var parseBody = __webpack_require__(389);
	var isXHRAvailable = global.XMLHttpRequest && 'withCredentials' in new global.XMLHttpRequest();
	
	function getRequestObject() {
	  return isXHRAvailable ? new XMLHttpRequest() : new XDomainRequest();
	}
	
	function request(options, cb) {
	  var status, resBody;
	  var method = options.method;
	  var url = options.url;
	  var body = options.data;
	  var timeout = options.timeout;
	  var headers = assign({
	    'Content-Type': 'application/json'
	  }, options.headers);
	  var req = getRequestObject();
	  var callback = cb;
	
	  if (method === 'GET') {
	    url = querystring.queryify(url, body);
	    body = null;
	  }
	
	  if (isXHRAvailable) {
	    req.onreadystatechange = function () {
	      if (req.readyState !== 4) { return; }
	
	      status = req.status;
	      resBody = parseBody(req.responseText);
	
	      if (status >= 400 || status < 200) {
	        callback(resBody || 'error', null, status || 500);
	      } else {
	        callback(null, resBody, status);
	      }
	    };
	  } else {
	    if (options.headers) {
	      url = querystring.queryify(url, headers);
	    }
	
	    req.onload = function () {
	      callback(null, parseBody(req.responseText), req.status);
	    };
	
	    req.onerror = function () {
	      // XDomainRequest does not report a body or status for errors, so
	      // hardcode to 'error' and 500, respectively
	      callback('error', null, 500);
	    };
	
	    // This must remain for IE9 to work
	    req.onprogress = function () {};
	
	    req.ontimeout = function () {
	      callback('timeout', null, -1);
	    };
	  }
	
	  req.open(method, url, true);
	  req.timeout = timeout;
	
	  if (isXHRAvailable) {
	    Object.keys(headers).forEach(function (headerKey) {
	      req.setRequestHeader(headerKey, headers[headerKey]);
	    });
	  }
	
	  try {
	    req.send(prepBody(method, body));
	  } catch (e) { /* ignored */ }
	}
	
	module.exports = {
	  request: request
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 387 */
/***/ function(module, exports) {

	'use strict';
	
	var assignNormalized = typeof Object.assign === 'function' ? Object.assign : assignPolyfill;
	
	function assignPolyfill(destination) {
	  var i, source, key;
	
	  for (i = 1; i < arguments.length; i++) {
	    source = arguments[i];
	    for (key in source) {
	      if (source.hasOwnProperty(key)) {
	        destination[key] = source[key];
	      }
	    }
	  }
	
	  return destination;
	}
	
	module.exports = {
	  assign: assignNormalized,
	  _assign: assignPolyfill
	};


/***/ },
/* 388 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (method, body) {
	  if (typeof method !== 'string') {
	    throw new Error('Method must be a string');
	  }
	
	  if (method.toLowerCase() !== 'get' && body != null) {
	    body = typeof body === 'string' ? body : JSON.stringify(body);
	  }
	
	  return body;
	};


/***/ },
/* 389 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (body) {
	  try {
	    body = JSON.parse(body);
	  } catch (e) { /* ignored */ }
	
	  return body;
	};


/***/ },
/* 390 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = function getUserAgent() {
	  return global.navigator.userAgent;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 391 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = function () {
	  return global.location.protocol === 'http:';
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 392 */
/***/ function(module, exports) {

	'use strict';
	
	var parser;
	var legalHosts = {
	  'paypal.com': 1,
	  'braintreepayments.com': 1,
	  'braintreegateway.com': 1,
	  'braintree-api.com': 1
	};
	
	function stripSubdomains(domain) {
	  return domain.split('.').slice(-2).join('.');
	}
	
	function isWhitelistedDomain(url) {
	  var mainDomain;
	
	  url = url.toLowerCase();
	
	  if (!/^https:/.test(url)) {
	    return false;
	  }
	
	  parser = parser || document.createElement('a');
	  parser.href = url;
	  mainDomain = stripSubdomains(parser.hostname);
	
	  return legalHosts.hasOwnProperty(mainDomain);
	}
	
	module.exports = isWhitelistedDomain;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	function convertToBraintreeError(originalErr, btErrorObject) {
	  if (originalErr instanceof BraintreeError) {
	    return originalErr;
	  }
	
	  return new BraintreeError({
	    type: btErrorObject.type,
	    code: btErrorObject.code,
	    message: btErrorObject.message,
	    details: {
	      originalError: originalErr
	    }
	  });
	}
	
	module.exports = convertToBraintreeError;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createAuthorizationData = __webpack_require__(395);
	var jsonClone = __webpack_require__(397);
	var constants = __webpack_require__(398);
	
	function addMetadata(configuration, data) {
	  var key;
	  var attrs = data ? jsonClone(data) : {};
	  var authAttrs = createAuthorizationData(configuration.authorization).attrs;
	  var _meta = jsonClone(configuration.analyticsMetadata);
	
	  attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
	
	  for (key in attrs._meta) {
	    if (attrs._meta.hasOwnProperty(key)) {
	      _meta[key] = attrs._meta[key];
	    }
	  }
	
	  attrs._meta = _meta;
	
	  if (authAttrs.tokenizationKey) {
	    attrs.tokenizationKey = authAttrs.tokenizationKey;
	  } else {
	    attrs.authorizationFingerprint = authAttrs.authorizationFingerprint;
	  }
	
	  return attrs;
	}
	
	module.exports = addMetadata;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var atob = __webpack_require__(396).atob;
	
	var apiUrls = {
	  production: 'https://api.braintreegateway.com:443',
	  sandbox: 'https://api.sandbox.braintreegateway.com:443'
	};
	
	function _isTokenizationKey(str) {
	  return /^[a-zA-Z0-9]+_[a-zA-Z0-9]+_[a-zA-Z0-9_]+$/.test(str);
	}
	
	function _parseTokenizationKey(tokenizationKey) {
	  var tokens = tokenizationKey.split('_');
	  var environment = tokens[0];
	  var merchantId = tokens.slice(2).join('_');
	
	  return {
	    merchantId: merchantId,
	    environment: environment
	  };
	}
	
	function createAuthorizationData(authorization) {
	  var parsedClientToken, parsedTokenizationKey;
	  var data = {
	    attrs: {},
	    configUrl: ''
	  };
	
	  if (_isTokenizationKey(authorization)) {
	    parsedTokenizationKey = _parseTokenizationKey(authorization);
	    data.attrs.tokenizationKey = authorization;
	    data.configUrl = apiUrls[parsedTokenizationKey.environment] + '/merchants/' + parsedTokenizationKey.merchantId + '/client_api/v1/configuration';
	  } else {
	    parsedClientToken = JSON.parse(atob(authorization));
	    data.attrs.authorizationFingerprint = parsedClientToken.authorizationFingerprint;
	    data.configUrl = parsedClientToken.configUrl;
	  }
	
	  return data;
	}
	
	module.exports = createAuthorizationData;


/***/ },
/* 396 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var atobNormalized = typeof global.atob === 'function' ? global.atob : atob;
	
	function atob(base64String) {
	  var a, b, c, b1, b2, b3, b4, i;
	  var base64Matcher = new RegExp('^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})([=]{1,2})?$');
	  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	  var result = '';
	
	  if (!base64Matcher.test(base64String)) {
	    throw new Error('Non base64 encoded input passed to window.atob polyfill');
	  }
	
	  i = 0;
	  do {
	    b1 = characters.indexOf(base64String.charAt(i++));
	    b2 = characters.indexOf(base64String.charAt(i++));
	    b3 = characters.indexOf(base64String.charAt(i++));
	    b4 = characters.indexOf(base64String.charAt(i++));
	
	    a = (b1 & 0x3F) << 2 | b2 >> 4 & 0x3;
	    b = (b2 & 0xF) << 4 | b3 >> 2 & 0xF;
	    c = (b3 & 0x3) << 6 | b4 & 0x3F;
	
	    result += String.fromCharCode(a) + (b ? String.fromCharCode(b) : '') + (c ? String.fromCharCode(c) : '');
	  } while (i < base64String.length);
	
	  return result;
	}
	
	module.exports = {
	  atob: function (base64String) {
	    return atobNormalized.call(global, base64String);
	  },
	  _atob: atob
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 397 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
	  return JSON.parse(JSON.stringify(value));
	};


/***/ },
/* 398 */
/***/ function(module, exports) {

	'use strict';
	
	var VERSION = "3.14.0";
	var PLATFORM = 'web';
	
	module.exports = {
	  ANALYTICS_PREFIX: 'web.',
	  ANALYTICS_REQUEST_TIMEOUT_MS: 2000,
	  INTEGRATION_TIMEOUT_MS: 60000,
	  VERSION: VERSION,
	  INTEGRATION: 'custom',
	  SOURCE: 'client',
	  PLATFORM: PLATFORM,
	  BRAINTREE_LIBRARY_VERSION: 'braintree/' + PLATFORM + '/' + VERSION
	};


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Promise = global.Promise || __webpack_require__(400);
	
	module.exports = Promise;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {
	
	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;
	
	  function noop() {}
	  
	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }
	
	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];
	
	    doResolve(fn, this);
	  }
	
	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    Promise._immediateFn(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }
	
	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }
	
	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }
	
	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      Promise._immediateFn(function() {
	        if (!self._handled) {
	          Promise._unhandledRejectionFn(self._value);
	        }
	      });
	    }
	
	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }
	
	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }
	
	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }
	
	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };
	
	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new (this.constructor)(noop);
	
	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };
	
	  Promise.all = function (arr) {
	    var args = Array.prototype.slice.call(arr);
	
	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;
	
	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }
	
	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };
	
	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }
	
	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };
	
	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };
	
	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };
	
	  // Use polyfill for setImmediate for performance gains
	  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
	    function (fn) {
	      setTimeoutFunc(fn, 0);
	    };
	
	  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	    if (typeof console !== 'undefined' && console) {
	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	    }
	  };
	
	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @deprecated
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    Promise._immediateFn = fn;
	  };
	
	  /**
	   * Change the function to execute on unhandled rejection
	   * @param {function} fn Function to execute on unhandled rejection
	   * @deprecated
	   */
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    Promise._unhandledRejectionFn = fn;
	  };
	  
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }
	
	})(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(309).setImmediate))

/***/ },
/* 401 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
	  return function () {
	    // IE9 doesn't support passing arguments to setTimeout so we have to emulate it.
	    var args = arguments;
	
	    setTimeout(function () {
	      fn.apply(null, args);
	    }, 1);
	  };
	};


/***/ },
/* 402 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  BRAINTREE_API_VERSION_HEADER: '2017-04-03'
	};


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_GATEWAY_CONFIGURATION_INVALID_DOMAIN'
	  },
	  CLIENT_OPTION_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_OPTION_REQUIRED'
	  },
	  CLIENT_OPTION_INVALID: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_OPTION_INVALID'
	  },
	  CLIENT_MISSING_GATEWAY_CONFIGURATION: {
	    type: BraintreeError.types.INTERNAL,
	    code: 'CLIENT_MISSING_GATEWAY_CONFIGURATION',
	    message: 'Missing gatewayConfiguration.'
	  },
	  CLIENT_INVALID_AUTHORIZATION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_INVALID_AUTHORIZATION',
	    message: 'Authorization is invalid. Make sure your client token or tokenization key is valid.'
	  },
	  CLIENT_GATEWAY_NETWORK: {
	    type: BraintreeError.types.NETWORK,
	    code: 'CLIENT_GATEWAY_NETWORK',
	    message: 'Cannot contact the gateway at this time.'
	  },
	  CLIENT_REQUEST_TIMEOUT: {
	    type: BraintreeError.types.NETWORK,
	    code: 'CLIENT_REQUEST_TIMEOUT',
	    message: 'Request timed out waiting for a reply.'
	  },
	  CLIENT_REQUEST_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'CLIENT_REQUEST_ERROR',
	    message: 'There was a problem with your request.'
	  },
	  CLIENT_RATE_LIMITED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_RATE_LIMITED',
	    message: 'You are being rate-limited; please try again in a few minutes.'
	  },
	  CLIENT_AUTHORIZATION_INSUFFICIENT: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CLIENT_AUTHORIZATION_INSUFFICIENT',
	    message: 'The authorization used has insufficient privileges.'
	  }
	};


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  CALLBACK_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'CALLBACK_REQUIRED'
	  },
	  INSTANTIATION_OPTION_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'INSTANTIATION_OPTION_REQUIRED'
	  },
	  INVALID_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'INVALID_OPTION'
	  },
	  INCOMPATIBLE_VERSIONS: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'INCOMPATIBLE_VERSIONS'
	  },
	  METHOD_CALLED_AFTER_TEARDOWN: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'METHOD_CALLED_AFTER_TEARDOWN'
	  },
	  BRAINTREE_API_ACCESS_RESTRICTED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'BRAINTREE_API_ACCESS_RESTRICTED',
	    message: 'Your access is restricted and cannot use this part of the Braintree API.'
	  }
	};


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var request = __webpack_require__(381);
	var uuid = __webpack_require__(384);
	var constants = __webpack_require__(398);
	var createAuthorizationData = __webpack_require__(395);
	var errors = __webpack_require__(403);
	
	function getConfiguration(options) {
	  return new Promise(function (resolve, reject) {
	    var configuration, authData, attrs, configUrl;
	    var sessionId = uuid();
	    var analyticsMetadata = {
	      merchantAppId: global.location.host,
	      platform: constants.PLATFORM,
	      sdkVersion: constants.VERSION,
	      source: constants.SOURCE,
	      integration: constants.INTEGRATION,
	      integrationType: constants.INTEGRATION,
	      sessionId: sessionId
	    };
	
	    try {
	      authData = createAuthorizationData(options.authorization);
	    } catch (err) {
	      reject(new BraintreeError(errors.CLIENT_INVALID_AUTHORIZATION));
	      return;
	    }
	    attrs = authData.attrs;
	    configUrl = authData.configUrl;
	
	    attrs._meta = analyticsMetadata;
	    attrs.braintreeLibraryVersion = constants.BRAINTREE_LIBRARY_VERSION;
	    attrs.configVersion = '3';
	
	    request({
	      url: configUrl,
	      method: 'GET',
	      data: attrs
	    }, function (err, response, status) {
	      var errorTemplate;
	
	      if (err) {
	        if (status === 403) {
	          errorTemplate = errors.CLIENT_AUTHORIZATION_INSUFFICIENT;
	        } else {
	          errorTemplate = errors.CLIENT_GATEWAY_NETWORK;
	        }
	
	        reject(new BraintreeError({
	          type: errorTemplate.type,
	          code: errorTemplate.code,
	          message: errorTemplate.message,
	          details: {
	            originalError: err
	          }
	        }));
	        return;
	      }
	
	      configuration = {
	        authorization: options.authorization,
	        authorizationType: attrs.tokenizationKey ? 'TOKENIZATION_KEY' : 'CLIENT_TOKEN',
	        analyticsMetadata: analyticsMetadata,
	        gatewayConfiguration: response
	      };
	
	      resolve(configuration);
	    });
	  });
	}
	
	module.exports = {
	  getConfiguration: wrapPromise(getConfiguration)
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var deferred = __webpack_require__(407);
	var once = __webpack_require__(408);
	var promiseOrCallback = __webpack_require__(409);
	
	function wrapPromise(fn) {
	  return function () {
	    var callback;
	    var args = Array.prototype.slice.call(arguments);
	    var lastArg = args[args.length - 1];
	
	    if (typeof lastArg === 'function') {
	      callback = args.pop();
	      callback = once(deferred(callback));
	    }
	    return promiseOrCallback(fn.apply(this, args), callback); // eslint-disable-line no-invalid-this
	  };
	}
	
	wrapPromise.wrapPrototype = function (target, options) {
	  var methods, ignoreMethods, includePrivateMethods;
	
	  options = options || {};
	  ignoreMethods = options.ignoreMethods || [];
	  includePrivateMethods = options.transformPrivateMethods === true;
	
	  methods = Object.getOwnPropertyNames(target.prototype).filter(function (method) {
	    var isNotPrivateMethod;
	    var isNonConstructorFunction = method !== 'constructor' &&
	      typeof target.prototype[method] === 'function';
	    var isNotAnIgnoredMethod = ignoreMethods.indexOf(method) === -1;
	
	    if (includePrivateMethods) {
	      isNotPrivateMethod = true;
	    } else {
	      isNotPrivateMethod = method.charAt(0) !== '_';
	    }
	
	    return isNonConstructorFunction &&
	      isNotPrivateMethod &&
	      isNotAnIgnoredMethod;
	  });
	
	  methods.forEach(function (method) {
	    var original = target.prototype[method];
	
	    target.prototype[method] = wrapPromise(original);
	  });
	
	  return target;
	};
	
	module.exports = wrapPromise;


/***/ },
/* 407 */
/***/ function(module, exports) {

	'use strict';
	
	function deferred(fn) {
	  return function () {
	    // IE9 doesn't support passing arguments to setTimeout so we have to emulate it.
	    var args = arguments;
	
	    setTimeout(function () {
	      fn.apply(null, args);
	    }, 1);
	  };
	}
	
	module.exports = deferred;


/***/ },
/* 408 */
/***/ function(module, exports) {

	'use strict';
	
	function once(fn) {
	  var called = false;
	
	  return function () {
	    if (!called) {
	      called = true;
	      fn.apply(null, arguments);
	    }
	  };
	}
	
	module.exports = once;


/***/ },
/* 409 */
/***/ function(module, exports) {

	'use strict';
	
	function promiseOrCallback(promise, callback) { // eslint-disable-line consistent-return
	  if (callback) {
	    promise
	      .then(function (data) {
	        callback(null, data);
	      })
	      .catch(function (err) {
	        callback(err);
	      });
	  } else {
	    return promise;
	  }
	}
	
	module.exports = promiseOrCallback;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/paypal
	 * @description A component to integrate with PayPal.
	 */
	
	var analytics = __webpack_require__(411);
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(412);
	var PayPal = __webpack_require__(413);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	var wrapPromise = __webpack_require__(406);
	var Promise = __webpack_require__(399);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} callback The second argument, `data`, is the {@link PayPal} instance.
	 * @example
	 * // We recomend creating your PayPal button with button.js
	 * // For an example, see http://codepen.io/braintree/pen/LNKJWa
	 * var paypalButton = document.querySelector('.paypal-button');
	 *
	 * braintree.client.create({
	 *   authorization: CLIENT_AUTHORIZATION
	 * }, function (clientErr, clientInstance) {
	 *   if (clientErr) {
	 *     console.error('Error creating client:', clientErr);
	 *     return;
	 *   }
	 *
	 *   braintree.paypal.create({
	 *     client: clientInstance
	 *   }, function (paypalErr, paypalInstance) {
	 *     if (paypalErr) {
	 *       console.error('Error creating PayPal:', paypalErr);
	 *       return;
	 *     }
	 *
	 *     paypalButton.removeAttribute('disabled');
	 *
	 *     // When the button is clicked, attempt to tokenize.
	 *     paypalButton.addEventListener('click', function (event) {
	 *       // Because tokenization opens a popup, this has to be called as a result of
	 *       // customer action, like clicking a button. You cannot call this at any time.
	 *       paypalInstance.tokenize({
	 *         flow: 'vault'
	 *         // For more tokenization options, see the full PayPal tokenization documentation
	 *         // http://braintree.github.io/braintree-web/current/PayPal.html#tokenize
	 *       }, function (tokenizeErr, payload) {
	 *         if (tokenizeErr) {
	 *           if (tokenizeErr.type !== 'CUSTOMER') {
	 *             console.error('Error tokenizing:', tokenizeErr);
	 *           }
	 *           return;
	 *         }
	 *
	 *         // Tokenization succeeded
	 *         paypalButton.setAttribute('disabled', true);
	 *         console.log('Got a nonce! You should submit this to your server.');
	 *         console.log(payload.nonce);
	 *       });
	 *     }, false);
	 *   });
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var config, pp, clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating PayPal.'
	    }));
	  }
	
	  config = options.client.getConfiguration();
	  clientVersion = config.analyticsMetadata.sdkVersion;
	
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and PayPal (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (config.gatewayConfiguration.paypalEnabled !== true) {
	    return Promise.reject(new BraintreeError(errors.PAYPAL_NOT_ENABLED));
	  }
	
	  analytics.sendEvent(options.client, 'paypal.initialized');
	
	  pp = new PayPal(options);
	  return pp._initialize();
	}
	
	/**
	 * @static
	 * @function isSupported
	 * @description Returns true if PayPal [supports this browser](/current/#browser-support-webviews).
	 * @example
	 * if (braintree.paypal.isSupported()) {
	 *   // Add PayPal button to the page
	 * } else {
	 *   // Hide PayPal payment option
	 * }
	 * @returns {Boolean} Returns true if PayPal supports this browser.
	 */
	function isSupported() {
	  return true;
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  isSupported: isSupported,
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var constants = __webpack_require__(398);
	var addMetadata = __webpack_require__(394);
	
	function _millisToSeconds(millis) {
	  return Math.floor(millis / 1000);
	}
	
	function sendAnalyticsEvent(client, kind, callback) {
	  var configuration = client.getConfiguration();
	  var request = client._request;
	  var timestamp = _millisToSeconds(Date.now());
	  var url = configuration.gatewayConfiguration.analytics.url;
	  var data = {
	    analytics: [{
	      kind: constants.ANALYTICS_PREFIX + kind,
	      timestamp: timestamp
	    }]
	  };
	
	  request({
	    url: url,
	    method: 'post',
	    data: addMetadata(configuration, data),
	    timeout: constants.ANALYTICS_REQUEST_TIMEOUT_MS
	  }, callback);
	}
	
	module.exports = {
	  sendEvent: sendAnalyticsEvent
	};


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  PAYPAL_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_NOT_ENABLED',
	    message: 'PayPal is not enabled for this merchant.'
	  },
	  PAYPAL_TOKENIZATION_REQUEST_ACTIVE: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_TOKENIZATION_REQUEST_ACTIVE',
	    message: 'Another tokenization request is active.'
	  },
	  PAYPAL_ACCOUNT_TOKENIZATION_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'PAYPAL_ACCOUNT_TOKENIZATION_FAILED',
	    message: 'Could not tokenize user\'s PayPal account.'
	  },
	  PAYPAL_FLOW_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'PAYPAL_FLOW_FAILED',
	    message: 'Could not initialize PayPal flow.'
	  },
	  PAYPAL_FLOW_OPTION_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_FLOW_OPTION_REQUIRED',
	    message: 'PayPal flow property is invalid or missing.'
	  },
	  PAYPAL_BROWSER_NOT_SUPPORTED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'PAYPAL_BROWSER_NOT_SUPPORTED',
	    message: 'Browser is not supported.'
	  },
	  PAYPAL_POPUP_OPEN_FAILED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_POPUP_OPEN_FAILED',
	    message: 'PayPal popup failed to open, make sure to tokenize in response to a user action.'
	  },
	  PAYPAL_POPUP_CLOSED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'PAYPAL_POPUP_CLOSED',
	    message: 'Customer closed PayPal popup before authorizing.'
	  },
	  PAYPAL_INVALID_PAYMENT_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_INVALID_PAYMENT_OPTION',
	    message: 'PayPal payment options are invalid.'
	  }
	};


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var frameService = __webpack_require__(414);
	var BraintreeError = __webpack_require__(378);
	var convertToBraintreeError = __webpack_require__(393);
	var useMin = __webpack_require__(438);
	var once = __webpack_require__(382);
	var VERSION = "3.14.0";
	var constants = __webpack_require__(439);
	var INTEGRATION_TIMEOUT_MS = __webpack_require__(398).INTEGRATION_TIMEOUT_MS;
	var analytics = __webpack_require__(411);
	var methods = __webpack_require__(440);
	var deferred = __webpack_require__(401);
	var errors = __webpack_require__(412);
	var convertMethodsToError = __webpack_require__(441);
	var querystring = __webpack_require__(385);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @typedef {object} PayPal~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {string} type The payment method type, always `PayPalAccount`.
	 * @property {object} details Additional PayPal account details.
	 * @property {string} details.email User's email address.
	 * @property {string} details.payerId User's payer ID, the unique identifier for each PayPal account.
	 * @property {string} details.firstName User's given name.
	 * @property {string} details.lastName User's surname.
	 * @property {?string} details.countryCode User's 2 character country code.
	 * @property {?string} details.phone User's phone number (e.g. 555-867-5309).
	 * @property {?object} details.shippingAddress User's shipping address details, only available if shipping address is enabled.
	 * @property {string} details.shippingAddress.recipientName Recipient of postage.
	 * @property {string} details.shippingAddress.line1 Street number and name.
	 * @property {string} details.shippingAddress.line2 Extended address.
	 * @property {string} details.shippingAddress.city City or locality.
	 * @property {string} details.shippingAddress.state State or region.
	 * @property {string} details.shippingAddress.postalCode Postal code.
	 * @property {string} details.shippingAddress.countryCode 2 character country code (e.g. US).
	 * @property {?object} details.billingAddress User's billing address details.
	 * Not available to all merchants; [contact PayPal](https://developers.braintreepayments.com/support/guides/paypal/setup-guide#contacting-paypal-support) for details on eligibility and enabling this feature.
	 * Alternatively, see `shippingAddress` above as an available client option.
	 * @property {string} details.billingAddress.line1 Street number and name.
	 * @property {string} details.billingAddress.line2 Extended address.
	 * @property {string} details.billingAddress.city City or locality.
	 * @property {string} details.billingAddress.state State or region.
	 * @property {string} details.billingAddress.postalCode Postal code.
	 * @property {string} details.billingAddress.countryCode 2 character country code (e.g. US).
	 * @property {?object} creditFinancingOffered This property will only be present when the customer pays with PayPal Credit.
	 * @property {object} creditFinancingOffered.totalCost This is the estimated total payment amount including interest and fees the user will pay during the lifetime of the loan.
	 * @property {string} creditFinancingOffered.totalCost.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.totalCost.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {number} creditFinancingOffered.term Length of financing terms in months.
	 * @property {object} creditFinancingOffered.monthlyPayment This is the estimated amount per month that the customer will need to pay including fees and interest.
	 * @property {string} creditFinancingOffered.monthlyPayment.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.monthlyPayment.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {object} creditFinancingOffered.totalInterest Estimated interest or fees amount the payer will have to pay during the lifetime of the loan.
	 * @property {string} creditFinancingOffered.totalInterest.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.totalInterest.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {boolean} creditFinancingOffered.payerAcceptance Status of whether the customer ultimately was approved for and chose to make the payment using the approved installment credit.
	 * @property {boolean} creditFinancingOffered.cartAmountImmutable Indicates whether the cart amount is editable after payer's acceptance on PayPal side.
	 *
	 */
	
	/**
	 * @typedef {object} PayPal~tokenizeReturn
	 * @property {Function} close A handle to close the PayPal checkout flow.
	 * @property {Function} focus A handle to focus the PayPal checkout flow. Note that some browsers (notably iOS Safari) do not support focusing popups. Firefox requires the focus call to occur as the result of a user interaction, such as a button click.
	 */
	
	/**
	 * @class
	 * @param {object} options see {@link module:braintree-web/paypal.create|paypal.create}
	 * @classdesc This class represents a PayPal component. Instances of this class have methods for launching auth dialogs and other programmatic interactions with the PayPal component.
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/paypal.create|braintree-web.paypal.create} instead.</strong>
	 */
	function PayPal(options) {
	  this._client = options.client;
	  this._assetsUrl = options.client.getConfiguration().gatewayConfiguration.paypal.assetsUrl + '/web/' + VERSION;
	  this._isDebug = options.client.getConfiguration().isDebug;
	  this._loadingFrameUrl = this._assetsUrl + '/html/paypal-landing-frame' + useMin(this._isDebug) + '.html';
	  this._authorizationInProgress = false;
	}
	
	PayPal.prototype._initialize = function () {
	  var self = this;
	  var client = this._client;
	  var failureTimeout = setTimeout(function () {
	    analytics.sendEvent(client, 'paypal.load.timed-out');
	  }, INTEGRATION_TIMEOUT_MS);
	
	  return new Promise(function (resolve) {
	    frameService.create({
	      name: constants.LANDING_FRAME_NAME,
	      dispatchFrameUrl: self._assetsUrl + '/html/dispatch-frame' + useMin(self._isDebug) + '.html',
	      openFrameUrl: self._loadingFrameUrl
	    }, function (service) {
	      self._frameService = service;
	      clearTimeout(failureTimeout);
	      analytics.sendEvent(client, 'paypal.load.succeeded');
	      resolve(self);
	    });
	  });
	};
	
	/**
	 * Launches the PayPal login flow and returns a nonce payload. Only one PayPal login flow should be active at a time. One way to achieve this is to disable your PayPal button while the flow is open.
	 * @public
	 * @param {object} options All tokenization options for the PayPal component.
	 * @param {string} options.flow Set to 'checkout' for one-time payment flow, or 'vault' for Vault flow. If 'vault' is used with a client token generated with a customer id, the PayPal account will be added to that customer as a saved payment method.
	 * @param {string} [options.intent=authorize]
	 * Checkout flows only.
	 * * `authorize` - Submits the transaction for authorization but not settlement.
	 * * `sale` - Payment will be immediately submitted for settlement upon creating a transaction.
	 * @param {boolean} [options.offerCredit=false] Offers the customer PayPal Credit if they qualify.
	 * @param {string} [options.useraction]
	 * Changes the call-to-action in the PayPal flow. By default the final button will show the localized
	 * word for "Continue" and implies that the final amount billed is not yet known.
	 *
	 * Setting this option to `commit` changes the button text to "Pay Now" and page text will convey to
	 * the user that billing will take place immediately.
	 * @param {string|number} [options.amount] The amount of the transaction. Required when using the Checkout flow.
	 * @param {string} [options.currency] The currency code of the amount, such as 'USD'. Required when using the Checkout flow.
	 * @param {string} [options.displayName] The merchant name displayed inside of the PayPal lightbox; defaults to the company name on your Braintree account
	 * @param {string} [options.locale=en_US] Use this option to change the language, links, and terminology used in the PayPal flow. This locale will be used unless the buyer has set a preferred locale for their account. If an unsupported locale is supplied, a fallback locale (determined by buyer preference or browser data) will be used and no error will be thrown.
	 *
	 * Supported locales are:
	 * `da_DK`,
	 * `de_DE`,
	 * `en_AU`,
	 * `en_GB`,
	 * `en_US`,
	 * `es_ES`,
	 * `fr_CA`,
	 * `fr_FR`,
	 * `id_ID`,
	 * `it_IT`,
	 * `ja_JP`,
	 * `ko_KR`,
	 * `nl_NL`,
	 * `no_NO`,
	 * `pl_PL`,
	 * `pt_BR`,
	 * `pt_PT`,
	 * `ru_RU`,
	 * `sv_SE`,
	 * `th_TH`,
	 * `zh_CN`,
	 * `zh_HK`,
	 * and `zh_TW`.
	 *
	 * @param {boolean} [options.enableShippingAddress=false] Returns a shipping address object in {@link PayPal#tokenize}.
	 * @param {object} [options.shippingAddressOverride] Allows you to pass a shipping address you have already collected into the PayPal payment flow.
	 * @param {string} options.shippingAddressOverride.line1 Street address.
	 * @param {string} [options.shippingAddressOverride.line2] Street address (extended).
	 * @param {string} options.shippingAddressOverride.city City.
	 * @param {string} options.shippingAddressOverride.state State.
	 * @param {string} options.shippingAddressOverride.postalCode Postal code.
	 * @param {string} options.shippingAddressOverride.countryCode Country.
	 * @param {string} [options.shippingAddressOverride.phone] Phone number.
	 * @param {string} [options.shippingAddressOverride.recipientName] Recipient's name.
	 * @param {boolean} [options.shippingAddressEditable=true] Set to false to disable user editing of the shipping address.
	 * @param {string} [options.billingAgreementDescription] Use this option to set the description of the preapproved payment agreement visible to customers in their PayPal profile during Vault flows. Max 255 characters.
	 * @param {string} [options.landingPageType=login] Use this option to specify the PayPal page to display when a user lands on the PayPal site to complete the payment. It defaults to `login`.
	 * * `login` - A PayPal account login page is used.
	 * * `billing` - A non-PayPal account landing page is used.
	 * @param {callback} callback The second argument, <code>data</code>, is a {@link PayPal~tokenizePayload|tokenizePayload}.
	 * @example Tokenizing with the vault flow
	 * button.addEventListener('click', function () {
	 *   // Disable the button so that we don't attempt to open multiple popups.
	 *   button.setAttribute('disabled', 'disabled');
	 *
	 *   // Because PayPal tokenization opens a popup, this must be called
	 *   // as a result of a user action, such as a button click.
	 *   paypalInstance.tokenize({
	 *     flow: 'vault' // Required
	 *     // Any other tokenization options
	 *   }, function (tokenizeErr, payload) {
	 *     button.removeAttribute('disabled');
	 *
	 *     if (tokenizeErr) {
	 *       // Handle tokenization errors or premature flow closure
	 *
	 *       switch (tokenizeErr.code) {
	 *         case 'PAYPAL_POPUP_CLOSED':
	 *           console.error('Customer closed PayPal popup.');
	 *           break;
	 *         case 'PAYPAL_ACCOUNT_TOKENIZATION_FAILED':
	 *           console.error('PayPal tokenization failed. See details:', tokenizeErr.details);
	 *           break;
	 *         case 'PAYPAL_FLOW_FAILED':
	 *           console.error('Unable to initialize PayPal flow. Are your options correct?', tokenizeErr.details);
	 *           break;
	 *         default:
	 *           console.error('Error!', tokenizeErr);
	 *       }
	 *     } else {
	 *       // Submit payload.nonce to your server
	 *     }
	 *   });
	 * });
	
	 * @example Tokenizing with the checkout flow
	 * button.addEventListener('click', function () {
	 *   // Disable the button so that we don't attempt to open multiple popups.
	 *   button.setAttribute('disabled', 'disabled');
	 *
	 *   // Because PayPal tokenization opens a popup, this must be called
	 *   // as a result of a user action, such as a button click.
	 *   paypalInstance.tokenize({
	 *     flow: 'checkout', // Required
	 *     amount: '10.00', // Required
	 *     currency: 'USD' // Required
	 *     // Any other tokenization options
	 *   }, function (tokenizeErr, payload) {
	 *     button.removeAttribute('disabled');
	 *
	 *     if (tokenizeErr) {
	 *       // Handle tokenization errors or premature flow closure
	 *
	 *       switch (tokenizeErr.code) {
	 *         case 'PAYPAL_POPUP_CLOSED':
	 *           console.error('Customer closed PayPal popup.');
	 *           break;
	 *         case 'PAYPAL_ACCOUNT_TOKENIZATION_FAILED':
	 *           console.error('PayPal tokenization failed. See details:', tokenizeErr.details);
	 *           break;
	 *         case 'PAYPAL_FLOW_FAILED':
	 *           console.error('Unable to initialize PayPal flow. Are your options correct?', tokenizeErr.details);
	 *           break;
	 *         default:
	 *           console.error('Error!', tokenizeErr);
	 *       }
	 *     } else {
	 *       // Submit payload.nonce to your server
	 *     }
	 *   });
	 * });
	 * @returns {Promise|PayPal~tokenizeReturn} A handle to manage the PayPal checkout frame. If no callback is provided, returns a promise.
	 */
	PayPal.prototype.tokenize = function (options, callback) {
	  var self = this;
	  var client = this._client;
	  var tokenizePromise, optionError;
	
	  if (callback) {
	    callback = once(deferred(callback));
	  }
	
	  if (!options || !constants.FLOW_ENDPOINTS.hasOwnProperty(options.flow)) {
	    optionError = new BraintreeError(errors.PAYPAL_FLOW_OPTION_REQUIRED);
	
	    if (callback) {
	      callback(optionError);
	      return this._frameService.createNoopHandler();
	    }
	
	    return Promise.reject(optionError);
	  }
	
	  tokenizePromise = new Promise(function (resolve, reject) {
	    if (self._authorizationInProgress) {
	      analytics.sendEvent(client, 'paypal.tokenization.error.already-opened');
	
	      reject(new BraintreeError(errors.PAYPAL_TOKENIZATION_REQUEST_ACTIVE));
	    } else {
	      self._authorizationInProgress = true;
	
	      if (!global.popupBridge) {
	        analytics.sendEvent(client, 'paypal.tokenization.opened');
	      }
	
	      if (options.offerCredit === true) {
	        analytics.sendEvent(client, 'paypal.credit.offered');
	      }
	
	      self._navigateFrameToAuth(options).catch(reject);
	      // self MUST happen after _navigateFrameToAuth for Metro browsers to work.
	      self._frameService.open(self._createFrameServiceCallback(options, resolve, reject));
	    }
	  });
	
	  if (callback) {
	    tokenizePromise.then(function (res) {
	      callback(null, res);
	    }).catch(callback);
	
	    return this._frameService.createHandler({
	      beforeClose: function () {
	        analytics.sendEvent(client, 'paypal.tokenization.closed.by-merchant');
	      }
	    });
	  }
	
	  return tokenizePromise;
	};
	
	PayPal.prototype._createFrameServiceCallback = function (options, resolve, reject) {
	  var self = this;
	  var client = this._client;
	
	  if (global.popupBridge) {
	    return function (err, payload) {
	      var cancelled = payload && payload.path && payload.path.substring(0, 7) === '/cancel';
	
	      self._authorizationInProgress = false;
	
	      // `err` exists when the user clicks "Done" button of browser view
	      if (err || cancelled) {
	        analytics.sendEvent(client, 'paypal.tokenization.closed-popupbridge.by-user');
	        // Call merchant's tokenize callback with an error
	        reject(new BraintreeError(errors.PAYPAL_POPUP_CLOSED));
	      } else if (payload) {
	        self._tokenizePayPal(options, payload.queryItems).then(resolve).catch(reject);
	      }
	    };
	  }
	
	  return function (err, params) {
	    self._authorizationInProgress = false;
	
	    if (err) {
	      if (err.code === 'FRAME_SERVICE_FRAME_CLOSED') {
	        analytics.sendEvent(client, 'paypal.tokenization.closed.by-user');
	        reject(new BraintreeError(errors.PAYPAL_POPUP_CLOSED));
	      } else if (err.code === 'FRAME_SERVICE_FRAME_OPEN_FAILED') {
	        reject(new BraintreeError(errors.PAYPAL_POPUP_OPEN_FAILED));
	      }
	    } else if (params) {
	      self._tokenizePayPal(options, params).then(resolve).catch(reject);
	    }
	  };
	};
	
	PayPal.prototype._tokenizePayPal = function (options, params) {
	  var self = this;
	  var client = this._client;
	
	  if (!global.popupBridge) {
	    this._frameService.redirect(this._loadingFrameUrl);
	  }
	
	  return client.request({
	    endpoint: 'payment_methods/paypal_accounts',
	    method: 'post',
	    data: this._formatTokenizeData(options, params)
	  }).then(function (response) {
	    var payload = self._formatTokenizePayload(response);
	
	    if (global.popupBridge) {
	      analytics.sendEvent(client, 'paypal.tokenization.success-popupbridge');
	    } else {
	      analytics.sendEvent(client, 'paypal.tokenization.success');
	    }
	
	    if (payload.creditFinancingOffered) {
	      analytics.sendEvent(client, 'paypal.credit.accepted');
	    }
	
	    self._frameService.close();
	
	    return payload;
	  }).catch(function (err) {
	    if (global.popupBridge) {
	      analytics.sendEvent(client, 'paypal.tokenization.failed-popupbridge');
	    } else {
	      analytics.sendEvent(client, 'paypal.tokenization.failed');
	    }
	
	    self._frameService.close();
	
	    return Promise.reject(convertToBraintreeError(err, {
	      type: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.type,
	      code: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.code,
	      message: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.message
	    }));
	  });
	};
	
	PayPal.prototype._formatTokenizePayload = function (response) {
	  var payload;
	  var account = {};
	
	  if (response.paypalAccounts) {
	    account = response.paypalAccounts[0];
	  }
	
	  payload = {
	    nonce: account.nonce,
	    details: {},
	    type: account.type
	  };
	
	  if (account.details && account.details.payerInfo) {
	    payload.details = account.details.payerInfo;
	  }
	
	  if (account.details && account.details.creditFinancingOffered) {
	    payload.creditFinancingOffered = account.details.creditFinancingOffered;
	  }
	
	  return payload;
	};
	
	PayPal.prototype._formatTokenizeData = function (options, params) {
	  var clientConfiguration = this._client.getConfiguration();
	  var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
	  var isTokenizationKey = clientConfiguration.authorizationType === 'TOKENIZATION_KEY';
	  var data = {
	    paypalAccount: {
	      correlationId: params.ba_token || params.token,
	      options: {
	        validate: options.flow === 'vault' && !isTokenizationKey
	      }
	    }
	  };
	
	  if (params.ba_token) {
	    data.paypalAccount.billingAgreementToken = params.ba_token;
	  } else {
	    data.paypalAccount.paymentToken = params.paymentId;
	    data.paypalAccount.payerId = params.PayerID;
	    data.paypalAccount.unilateral = gatewayConfiguration.paypal.unvettedMerchant;
	
	    if (options.hasOwnProperty('intent')) {
	      data.paypalAccount.intent = options.intent;
	    }
	  }
	
	  return data;
	};
	
	PayPal.prototype._navigateFrameToAuth = function (options) {
	  var self = this;
	  var client = this._client;
	  var endpoint = 'paypal_hermes/' + constants.FLOW_ENDPOINTS[options.flow];
	
	  return client.request({
	    endpoint: endpoint,
	    method: 'post',
	    data: this._formatPaymentResourceData(options)
	  }).then(function (response) {
	    var redirectUrl;
	
	    if (options.flow === 'checkout') {
	      redirectUrl = response.paymentResource.redirectUrl;
	    } else {
	      redirectUrl = response.agreementSetup.approvalUrl;
	    }
	
	    if (options.useraction === 'commit') {
	      redirectUrl = querystring.queryify(redirectUrl, {useraction: 'commit'});
	    }
	
	    if (global.popupBridge) {
	      analytics.sendEvent(client, 'paypal.tokenization.opened-popupbridge');
	    }
	
	    self._frameService.redirect(redirectUrl);
	  }).catch(function (err) {
	    var status = err.details && err.details.httpStatus;
	
	    self._frameService.close();
	    self._authorizationInProgress = false;
	
	    if (status === 422) {
	      return Promise.reject(new BraintreeError({
	        type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
	        code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
	        message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
	        details: {
	          originalError: err
	        }
	      }));
	    }
	
	    return Promise.reject(convertToBraintreeError(err, {
	      type: errors.PAYPAL_FLOW_FAILED.type,
	      code: errors.PAYPAL_FLOW_FAILED.code,
	      message: errors.PAYPAL_FLOW_FAILED.message
	    }));
	  });
	};
	
	PayPal.prototype._formatPaymentResourceData = function (options) {
	  var key;
	  var gatewayConfiguration = this._client.getConfiguration().gatewayConfiguration;
	  var serviceId = this._frameService._serviceId;
	  var paymentResource = {
	    returnUrl: gatewayConfiguration.paypal.assetsUrl + '/web/' + VERSION + '/html/paypal-redirect-frame' + useMin(this._isDebug) + '.html?channel=' + serviceId,
	    cancelUrl: gatewayConfiguration.paypal.assetsUrl + '/web/' + VERSION + '/html/paypal-cancel-frame' + useMin(this._isDebug) + '.html?channel=' + serviceId,
	    offerPaypalCredit: options.offerCredit === true,
	    experienceProfile: {
	      brandName: options.displayName || gatewayConfiguration.paypal.displayName,
	      localeCode: options.locale,
	      noShipping: (!options.enableShippingAddress).toString(),
	      addressOverride: options.shippingAddressEditable === false,
	      landingPageType: options.landingPageType
	    }
	  };
	
	  if (global.popupBridge && typeof global.popupBridge.getReturnUrlPrefix === 'function') {
	    paymentResource.returnUrl = global.popupBridge.getReturnUrlPrefix() + 'return';
	    paymentResource.cancelUrl = global.popupBridge.getReturnUrlPrefix() + 'cancel';
	  }
	
	  if (options.flow === 'checkout') {
	    paymentResource.amount = options.amount;
	    paymentResource.currencyIsoCode = options.currency;
	
	    if (options.hasOwnProperty('intent')) {
	      paymentResource.intent = options.intent;
	    }
	
	    for (key in options.shippingAddressOverride) {
	      if (options.shippingAddressOverride.hasOwnProperty(key)) {
	        paymentResource[key] = options.shippingAddressOverride[key];
	      }
	    }
	  } else {
	    paymentResource.shippingAddress = options.shippingAddressOverride;
	
	    if (options.billingAgreementDescription) {
	      paymentResource.description = options.billingAgreementDescription;
	    }
	  }
	
	  return paymentResource;
	};
	
	/**
	 * Closes the PayPal window if it is open.
	 * @public
	 * @example
	 * paypalInstance.closeWindow();
	 * @returns {void}
	 */
	PayPal.prototype.closeWindow = function () {
	  if (this._authorizationInProgress) {
	    analytics.sendEvent(this._client, 'paypal.tokenize.closed.by-merchant');
	  }
	  this._frameService.close();
	};
	
	/**
	 * Focuses the PayPal window if it is open.
	 * @public
	 * @example
	 * paypalInstance.focusWindow();
	 * @returns {void}
	 */
	PayPal.prototype.focusWindow = function () {
	  this._frameService.focus();
	};
	
	/**
	 * Cleanly remove anything set up by {@link module:braintree-web/paypal.create|create}.
	 * @public
	 * @param {callback} [callback] Called on completion.
	 * @example
	 * paypalInstance.teardown();
	 * @example <caption>With callback</caption>
	 * paypalInstance.teardown(function () {
	 *   // teardown is complete
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	PayPal.prototype.teardown = wrapPromise(function () {
	  var self = this; // eslint-disable-line no-invalid-this
	
	  self._frameService.teardown();
	
	  convertMethodsToError(self, methods(PayPal.prototype));
	
	  analytics.sendEvent(self._client, 'paypal.teardown-completed');
	
	  return Promise.resolve();
	});
	
	module.exports = PayPal;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var FrameService = __webpack_require__(415);
	
	module.exports = {
	  create: function createFrameService(options, callback) {
	    var frameService = new FrameService(options);
	
	    frameService.initialize(function () {
	      callback(frameService);
	    });
	  }
	};


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Popup = __webpack_require__(416);
	var PopupBridge = __webpack_require__(420);
	var Modal = __webpack_require__(422);
	var Bus = __webpack_require__(433);
	var events = __webpack_require__(437);
	var errors = __webpack_require__(421);
	var constants = __webpack_require__(418);
	var uuid = __webpack_require__(384);
	var iFramer = __webpack_require__(423);
	var BraintreeError = __webpack_require__(378);
	var browserDetection = __webpack_require__(427);
	
	var REQUIRED_CONFIG_KEYS = [
	  'name',
	  'dispatchFrameUrl',
	  'openFrameUrl'
	];
	
	function noop() {}
	
	function _validateFrameConfiguration(options) {
	  if (!options) {
	    throw new Error('Valid configuration is required');
	  }
	
	  REQUIRED_CONFIG_KEYS.forEach(function (key) {
	    if (!options.hasOwnProperty(key)) {
	      throw new Error('A valid frame ' + key + ' must be provided');
	    }
	  });
	
	  if (!/^[\w_]+$/.test(options.name)) {
	    throw new Error('A valid frame name must be provided');
	  }
	}
	
	function FrameService(options) {
	  _validateFrameConfiguration(options);
	
	  this._serviceId = uuid().replace(/-/g, '');
	
	  this._options = {
	    name: options.name + '_' + this._serviceId,
	    dispatchFrameUrl: options.dispatchFrameUrl,
	    openFrameUrl: options.openFrameUrl,
	    height: options.height,
	    width: options.width
	  };
	  this.state = options.state;
	
	  this._bus = new Bus({channel: this._serviceId});
	  this._setBusEvents();
	}
	
	FrameService.prototype.initialize = function (callback) {
	  var dispatchFrameReadyHandler = function () {
	    callback();
	    this._bus.off(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
	  }.bind(this);
	
	  this._bus.on(events.DISPATCH_FRAME_READY, dispatchFrameReadyHandler);
	  this._writeDispatchFrame();
	};
	
	FrameService.prototype._writeDispatchFrame = function () {
	  var frameName = constants.DISPATCH_FRAME_NAME + '_' + this._serviceId;
	  var frameSrc = this._options.dispatchFrameUrl;
	
	  this._dispatchFrame = iFramer({
	    name: frameName,
	    src: frameSrc,
	    'class': constants.DISPATCH_FRAME_CLASS,
	    height: 0,
	    width: 0,
	    style: {
	      position: 'absolute',
	      left: '-9999px'
	    }
	  });
	
	  document.body.appendChild(this._dispatchFrame);
	};
	
	FrameService.prototype._setBusEvents = function () {
	  this._bus.on(events.DISPATCH_FRAME_REPORT, function (res, reply) {
	    if (this._onCompleteCallback) {
	      this._onCompleteCallback.call(null, res.err, res.payload);
	    }
	    this._frame.close();
	
	    this._onCompleteCallback = null;
	
	    if (reply) {
	      reply();
	    }
	  }.bind(this));
	
	  this._bus.on(Bus.events.CONFIGURATION_REQUEST, function (reply) {
	    reply(this.state);
	  }.bind(this));
	};
	
	FrameService.prototype.open = function (callback) {
	  this._frame = this._getFrameForEnvironment();
	  this._frame.initialize(callback);
	
	  if (this._frame instanceof PopupBridge) {
	    return;
	  }
	
	  this._onCompleteCallback = callback;
	  this._frame.open();
	
	  if (this.isFrameClosed()) {
	    this._cleanupFrame();
	    if (callback) {
	      callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_OPEN_FAILED));
	    }
	    return;
	  }
	  this._pollForPopupClose();
	};
	
	FrameService.prototype.redirect = function (url) {
	  if (this._frame && !this.isFrameClosed()) {
	    this._frame.redirect(url);
	  }
	};
	
	FrameService.prototype.close = function () {
	  if (!this.isFrameClosed()) {
	    this._frame.close();
	  }
	};
	
	FrameService.prototype.focus = function () {
	  if (!this.isFrameClosed()) {
	    this._frame.focus();
	  }
	};
	
	FrameService.prototype.createHandler = function (options) {
	  options = options || {};
	
	  return {
	    close: function () {
	      if (options.beforeClose) {
	        options.beforeClose();
	      }
	
	      this.close();
	    }.bind(this),
	    focus: function () {
	      if (options.beforeFocus) {
	        options.beforeFocus();
	      }
	
	      this.focus();
	    }.bind(this)
	  };
	};
	
	FrameService.prototype.createNoopHandler = function () {
	  return {
	    close: noop,
	    focus: noop
	  };
	};
	
	FrameService.prototype.teardown = function () {
	  this.close();
	  this._dispatchFrame.parentNode.removeChild(this._dispatchFrame);
	  this._dispatchFrame = null;
	  this._cleanupFrame();
	};
	
	FrameService.prototype.isFrameClosed = function () {
	  return this._frame == null || this._frame.isClosed();
	};
	
	FrameService.prototype._cleanupFrame = function () {
	  this._frame = null;
	  clearInterval(this._popupInterval);
	  this._popupInterval = null;
	};
	
	FrameService.prototype._pollForPopupClose = function () {
	  this._popupInterval = setInterval(function () {
	    if (this.isFrameClosed()) {
	      this._cleanupFrame();
	      if (this._onCompleteCallback) {
	        this._onCompleteCallback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
	      }
	    }
	  }.bind(this), constants.POPUP_POLL_INTERVAL);
	
	  return this._popupInterval;
	};
	
	FrameService.prototype._getFrameForEnvironment = function () {
	  var usePopup = browserDetection.supportsPopups();
	  var popupBridgeExists = Boolean(global.popupBridge);
	
	  if (usePopup) {
	    return new Popup(this._options);
	  } else if (popupBridgeExists) {
	    return new PopupBridge(this._options);
	  }
	
	  return new Modal(this._options);
	};
	
	module.exports = FrameService;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var composeOptions = __webpack_require__(417);
	
	function noop() {}
	
	function Popup(options) {
	  this._frame = null;
	  this._options = options || {};
	
	  this.open();
	}
	
	Popup.prototype.initialize = noop;
	
	Popup.prototype.open = function () {
	  this._frame = global.open(
	    this._options.openFrameUrl,
	    this._options.name,
	    composeOptions(this._options)
	  );
	};
	
	Popup.prototype.focus = function () {
	  this._frame.focus();
	};
	
	Popup.prototype.close = function () {
	  this._frame.close();
	};
	
	Popup.prototype.isClosed = function () {
	  return this._frame && Boolean(this._frame.closed);
	};
	
	Popup.prototype.redirect = function (redirectUrl) {
	  this._frame.location.href = redirectUrl;
	};
	
	module.exports = Popup;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var constants = __webpack_require__(418);
	var position = __webpack_require__(419);
	
	module.exports = function composePopupOptions(options) {
	  var height = options.height || constants.DEFAULT_POPUP_HEIGHT;
	  var width = options.width || constants.DEFAULT_POPUP_WIDTH;
	
	  return [
	    constants.POPUP_BASE_OPTIONS,
	    'height=' + height,
	    'width=' + width,
	    'top=' + position.top(height),
	    'left=' + position.left(width)
	  ].join(',');
	};


/***/ },
/* 418 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  DISPATCH_FRAME_NAME: 'dispatch',
	  DISPATCH_FRAME_CLASS: 'braintree-dispatch-frame',
	  POPUP_BASE_OPTIONS: 'resizable,scrollbars',
	  DEFAULT_POPUP_WIDTH: 450,
	  DEFAULT_POPUP_HEIGHT: 535,
	  POPUP_POLL_INTERVAL: 100,
	  POPUP_CLOSE_TIMEOUT: 100
	};


/***/ },
/* 419 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	function top(height) {
	  var windowHeight = global.outerHeight || document.documentElement.clientHeight;
	  var windowTop = global.screenY == null ? global.screenTop : global.screenY;
	
	  return center(windowHeight, height, windowTop);
	}
	
	function left(width) {
	  var windowWidth = global.outerWidth || document.documentElement.clientWidth;
	  var windowLeft = global.screenX == null ? global.screenLeft : global.screenX;
	
	  return center(windowWidth, width, windowLeft);
	}
	
	function center(windowMetric, popupMetric, offset) {
	  return (windowMetric - popupMetric) / 2 + offset;
	}
	
	module.exports = {
	  top: top,
	  left: left,
	  center: center
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(421);
	
	function noop() {}
	
	function PopupBridge(options) {
	  this._closed = null;
	  this._options = options;
	}
	
	PopupBridge.prototype.initialize = function (callback) {
	  var self = this;
	
	  global.popupBridge.onComplete = function (err, payload) {
	    var popupDismissed = !payload && !err;
	
	    self._closed = true;
	
	    if (err || popupDismissed) {
	      // User clicked "Done" button of browser view
	      callback(new BraintreeError(errors.FRAME_SERVICE_FRAME_CLOSED));
	      return;
	    }
	    // User completed popup flow (includes success and cancel cases)
	    callback(null, payload);
	  };
	};
	
	PopupBridge.prototype.open = function (options) {
	  var url;
	
	  options = options || {};
	  url = options.openFrameUrl || this._options.openFrameUrl;
	
	  this._closed = false;
	  global.popupBridge.open(url);
	};
	
	PopupBridge.prototype.focus = noop;
	
	PopupBridge.prototype.close = noop;
	
	PopupBridge.prototype.isClosed = function () {
	  return Boolean(this._closed);
	};
	
	PopupBridge.prototype.redirect = function (redirectUrl) {
	  this.open({openFrameUrl: redirectUrl});
	};
	
	module.exports = PopupBridge;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  FRAME_SERVICE_FRAME_CLOSED: {
	    type: BraintreeError.types.INTERNAL,
	    code: 'FRAME_SERVICE_FRAME_CLOSED',
	    message: 'Frame closed before tokenization could occur.'
	  },
	  FRAME_SERVICE_FRAME_OPEN_FAILED: {
	    type: BraintreeError.types.INTERNAL,
	    code: 'FRAME_SERVICE_FRAME_OPEN_FAILED',
	    message: 'Frame failed to open.'
	  }
	};


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var iFramer = __webpack_require__(423);
	var assign = __webpack_require__(387).assign;
	var browserDetection = __webpack_require__(427);
	
	var ELEMENT_STYLES = {
	  position: 'fixed',
	  top: 0,
	  left: 0,
	  bottom: 0,
	  padding: 0,
	  margin: 0,
	  border: 0,
	  outline: 'none',
	  zIndex: 20001,
	  background: '#FFFFFF'
	};
	
	function noop() {}
	
	function Modal(options) {
	  this._closed = null;
	  this._frame = null;
	  this._options = options || {};
	  this._container = this._options.container || document.body;
	}
	
	Modal.prototype.initialize = noop;
	
	Modal.prototype.open = function () {
	  var iframerConfig = {
	    src: this._options.openFrameUrl,
	    name: this._options.name,
	    scrolling: 'yes',
	    height: '100%',
	    width: '100%',
	    style: assign({}, ELEMENT_STYLES)
	  };
	
	  if (browserDetection.isIos()) {
	    iframerConfig.style.position = 'absolute';
	
	    this._el = document.createElement('div');
	    this._frame = iFramer(iframerConfig);
	    this._el.appendChild(this._frame);
	  } else {
	    this._el = this._frame = iFramer(iframerConfig);
	  }
	  this._closed = false;
	
	  this._container.appendChild(this._el);
	};
	
	Modal.prototype.focus = noop;
	
	Modal.prototype.close = function () {
	  this._container.removeChild(this._el);
	  this._frame = null;
	  this._closed = true;
	};
	
	Modal.prototype.isClosed = function () {
	  return Boolean(this._closed);
	};
	
	Modal.prototype.redirect = function (redirectUrl) {
	  this._frame.src = redirectUrl;
	};
	
	module.exports = Modal;


/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var setAttributes = __webpack_require__(424);
	var defaultAttributes = __webpack_require__(425);
	var assign = __webpack_require__(426);
	
	module.exports = function createFrame(options) {
	  var iframe = document.createElement('iframe');
	  var config = assign({}, defaultAttributes, options);
	
	  if (config.style && typeof config.style !== 'string') {
	    assign(iframe.style, config.style);
	    delete config.style;
	  }
	
	  setAttributes(iframe, config);
	
	  if (!iframe.getAttribute('id')) {
	    iframe.id = iframe.name;
	  }
	
	  return iframe;
	};


/***/ },
/* 424 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function setAttributes(element, attributes) {
	  var value;
	
	  for (var key in attributes) {
	    if (attributes.hasOwnProperty(key)) {
	      value = attributes[key];
	
	      if (value == null) {
	        element.removeAttribute(key);
	      } else {
	        element.setAttribute(key, value);
	      }
	    }
	  }
	};


/***/ },
/* 425 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  src: 'about:blank',
	  frameBorder: 0,
	  allowtransparency: true,
	  scrolling: 'no'
	};


/***/ },
/* 426 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function assign(target) {
	  var objs = Array.prototype.slice.call(arguments, 1);
	
	  objs.forEach(function (obj) {
	    if (typeof obj !== 'object') { return; }
	
	    Object.keys(obj).forEach(function (key) {
	      target[key] = obj[key];
	    });
	  });
	
	  return target;
	}


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isAndroid = __webpack_require__(428);
	var isChrome = __webpack_require__(429);
	var isIe9 = __webpack_require__(430);
	var isIos = __webpack_require__(431);
	var supportsPopups = __webpack_require__(432);
	
	module.exports = {
	  isAndroid: isAndroid,
	  isChrome: isChrome,
	  isIe9: isIe9,
	  isIos: isIos,
	  supportsPopups: supportsPopups
	};


/***/ },
/* 428 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = function isAndroid(ua) {
	  ua = ua || global.navigator.userAgent;
	  return /Android/.test(ua);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 429 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function isChrome(ua) {
	  ua = ua || navigator.userAgent;
	  return ua.indexOf('Chrome') !== -1 || ua.indexOf('CriOS') !== -1;
	};


/***/ },
/* 430 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function isIe9(ua) {
	  ua = ua || navigator.userAgent;
	  return ua.indexOf('MSIE 9') !== -1;
	};


/***/ },
/* 431 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = function isIos(ua) {
	  ua = ua || global.navigator.userAgent;
	  return /iPhone|iPod|iPad/i.test(ua);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var MINIMUM_SUPPORTED_CHROME_IOS_VERSION = 48;
	
	var isAndroid = __webpack_require__(428);
	var isIos = __webpack_require__(431);
	
	function isUnsupportedIosChrome(ua) {
	  var match, version;
	
	  ua = ua || global.navigator.userAgent;
	  match = ua.match(/CriOS\/(\d+)\./);
	
	  if (!match) {
	    return false;
	  }
	
	  version = parseInt(match[1], 10);
	
	  return version < MINIMUM_SUPPORTED_CHROME_IOS_VERSION;
	}
	
	function isOperaMini(ua) {
	  ua = ua || global.navigator.userAgent;
	  return ua.indexOf('Opera Mini') > -1;
	}
	
	// The Google Search iOS app is technically a webview and doesn't support popups.
	function isGoogleSearchApp(ua) {
	  return /\bGSA\b/.test(ua);
	}
	
	function isIosWebview(ua) {
	  ua = ua || global.navigator.userAgent;
	  if (isIos(ua)) {
	    if (isGoogleSearchApp(ua)) {
	      return true;
	    }
	    return /.+AppleWebKit(?!.*Safari)/.test(ua);
	  }
	  return false;
	}
	
	function isAndroidWebview(ua) {
	  var androidWebviewRegExp = /Version\/[\d\.]+/;
	
	  ua = ua || global.navigator.userAgent;
	  if (isAndroid(ua)) {
	    return androidWebviewRegExp.test(ua) && !isOperaMini(ua);
	  }
	  return false;
	}
	
	module.exports = function supportsPopups(ua) {
	  ua = ua || global.navigator.userAgent;
	  return !(isIosWebview(ua) || isAndroidWebview(ua) || isOperaMini(ua) || isUnsupportedIosChrome(ua));
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var bus = __webpack_require__(434);
	var events = __webpack_require__(435);
	var checkOrigin = __webpack_require__(436).checkOrigin;
	var BraintreeError = __webpack_require__(378);
	
	function BraintreeBus(options) {
	  options = options || {};
	
	  this.channel = options.channel;
	  if (!this.channel) {
	    throw new BraintreeError({
	      type: BraintreeError.types.INTERNAL,
	      code: 'MISSING_CHANNEL_ID',
	      message: 'Channel ID must be specified.'
	    });
	  }
	
	  this.merchantUrl = options.merchantUrl;
	
	  this._isDestroyed = false;
	  this._isVerbose = false;
	
	  this._listeners = [];
	
	  this._log('new bus on channel ' + this.channel, [location.href]);
	}
	
	BraintreeBus.prototype.on = function (eventName, originalHandler) {
	  var namespacedEvent, args;
	  var handler = originalHandler;
	  var self = this;
	
	  if (this._isDestroyed) { return; }
	
	  if (this.merchantUrl) {
	    handler = function () {
	      /* eslint-disable no-invalid-this */
	      if (checkOrigin(this.origin, self.merchantUrl)) {
	        originalHandler.apply(this, arguments);
	      }
	      /* eslint-enable no-invalid-this */
	    };
	  }
	
	  namespacedEvent = this._namespaceEvent(eventName);
	  args = Array.prototype.slice.call(arguments);
	  args[0] = namespacedEvent;
	  args[1] = handler;
	
	  this._log('on', args);
	  bus.on.apply(bus, args);
	
	  this._listeners.push({
	    eventName: eventName,
	    handler: handler,
	    originalHandler: originalHandler
	  });
	};
	
	BraintreeBus.prototype.emit = function (eventName) {
	  var args;
	
	  if (this._isDestroyed) { return; }
	
	  args = Array.prototype.slice.call(arguments);
	  args[0] = this._namespaceEvent(eventName);
	
	  this._log('emit', args);
	  bus.emit.apply(bus, args);
	};
	
	BraintreeBus.prototype._offDirect = function (eventName) {
	  var args = Array.prototype.slice.call(arguments);
	
	  if (this._isDestroyed) { return; }
	
	  args[0] = this._namespaceEvent(eventName);
	
	  this._log('off', args);
	  bus.off.apply(bus, args);
	};
	
	BraintreeBus.prototype.off = function (eventName, originalHandler) {
	  var i, listener;
	  var handler = originalHandler;
	
	  if (this._isDestroyed) { return; }
	
	  if (this.merchantUrl) {
	    for (i = 0; i < this._listeners.length; i++) {
	      listener = this._listeners[i];
	
	      if (listener.originalHandler === originalHandler) {
	        handler = listener.handler;
	      }
	    }
	  }
	
	  this._offDirect(eventName, handler);
	};
	
	BraintreeBus.prototype._namespaceEvent = function (eventName) {
	  return ['braintree', this.channel, eventName].join(':');
	};
	
	BraintreeBus.prototype.teardown = function () {
	  var listener, i;
	
	  for (i = 0; i < this._listeners.length; i++) {
	    listener = this._listeners[i];
	    this._offDirect(listener.eventName, listener.handler);
	  }
	
	  this._listeners.length = 0;
	
	  this._isDestroyed = true;
	};
	
	BraintreeBus.prototype._log = function (functionName, args) {
	  if (this._isVerbose) {
	    console.log(functionName, args); // eslint-disable-line no-console
	  }
	};
	
	BraintreeBus.events = events;
	
	module.exports = BraintreeBus;


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	(function (root, factory) {
	  if (true) {
	    module.exports = factory(typeof global === 'undefined' ? root : global);
	  } else if (typeof define === 'function' && define.amd) {
	    define([], function () { return factory(root); });
	  } else {
	    root.framebus = factory(root);
	  }
	})(this, function (root) { // eslint-disable-line no-invalid-this
	  var win, framebus;
	  var popups = [];
	  var subscribers = {};
	  var prefix = '/*framebus*/';
	
	  function include(popup) {
	    if (popup == null) { return false; }
	    if (popup.Window == null) { return false; }
	    if (popup.constructor !== popup.Window) { return false; }
	
	    popups.push(popup);
	    return true;
	  }
	
	  function target(origin) {
	    var key;
	    var targetedFramebus = {};
	
	    for (key in framebus) {
	      if (!framebus.hasOwnProperty(key)) { continue; }
	
	      targetedFramebus[key] = framebus[key];
	    }
	
	    targetedFramebus._origin = origin || '*';
	
	    return targetedFramebus;
	  }
	
	  function publish(event) {
	    var payload, args;
	    var origin = _getOrigin(this); // eslint-disable-line no-invalid-this
	
	    if (_isntString(event)) { return false; }
	    if (_isntString(origin)) { return false; }
	
	    args = Array.prototype.slice.call(arguments, 1);
	
	    payload = _packagePayload(event, args, origin);
	    if (payload === false) { return false; }
	
	    _broadcast(win.top || win.self, payload, origin);
	
	    return true;
	  }
	
	  function subscribe(event, fn) {
	    var origin = _getOrigin(this); // eslint-disable-line no-invalid-this
	
	    if (_subscriptionArgsInvalid(event, fn, origin)) { return false; }
	
	    subscribers[origin] = subscribers[origin] || {};
	    subscribers[origin][event] = subscribers[origin][event] || [];
	    subscribers[origin][event].push(fn);
	
	    return true;
	  }
	
	  function unsubscribe(event, fn) {
	    var i, subscriberList;
	    var origin = _getOrigin(this); // eslint-disable-line no-invalid-this
	
	    if (_subscriptionArgsInvalid(event, fn, origin)) { return false; }
	
	    subscriberList = subscribers[origin] && subscribers[origin][event];
	    if (!subscriberList) { return false; }
	
	    for (i = 0; i < subscriberList.length; i++) {
	      if (subscriberList[i] === fn) {
	        subscriberList.splice(i, 1);
	        return true;
	      }
	    }
	
	    return false;
	  }
	
	  function _getOrigin(scope) {
	    return scope && scope._origin || '*';
	  }
	
	  function _isntString(string) {
	    return typeof string !== 'string';
	  }
	
	  function _packagePayload(event, args, origin) {
	    var packaged = false;
	    var payload = {
	      event: event,
	      origin: origin
	    };
	    var reply = args[args.length - 1];
	
	    if (typeof reply === 'function') {
	      payload.reply = _subscribeReplier(reply, origin);
	      args = args.slice(0, -1);
	    }
	
	    payload.args = args;
	
	    try {
	      packaged = prefix + JSON.stringify(payload);
	    } catch (e) {
	      throw new Error('Could not stringify event: ' + e.message);
	    }
	    return packaged;
	  }
	
	  function _unpackPayload(e) {
	    var payload, replyOrigin, replySource, replyEvent;
	
	    if (e.data.slice(0, prefix.length) !== prefix) { return false; }
	
	    try {
	      payload = JSON.parse(e.data.slice(prefix.length));
	    } catch (err) {
	      return false;
	    }
	
	    if (payload.reply != null) {
	      replyOrigin = e.origin;
	      replySource = e.source;
	      replyEvent = payload.reply;
	
	      payload.reply = function reply(data) { // eslint-disable-line consistent-return
	        var replyPayload = _packagePayload(replyEvent, [data], replyOrigin);
	
	        if (replyPayload === false) { return false; }
	
	        replySource.postMessage(replyPayload, replyOrigin);
	      };
	
	      payload.args.push(payload.reply);
	    }
	
	    return payload;
	  }
	
	  function _attach(w) {
	    if (win) { return; }
	    win = w || root;
	
	    if (win.addEventListener) {
	      win.addEventListener('message', _onmessage, false);
	    } else if (win.attachEvent) {
	      win.attachEvent('onmessage', _onmessage);
	    } else if (win.onmessage === null) {
	      win.onmessage = _onmessage;
	    } else {
	      win = null;
	    }
	  }
	
	  function _uuid() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0;
	      var v = c === 'x' ? r : r & 0x3 | 0x8;
	
	      return v.toString(16);
	    });
	  }
	
	  function _onmessage(e) {
	    var payload;
	
	    if (_isntString(e.data)) { return; }
	
	    payload = _unpackPayload(e);
	    if (!payload) { return; }
	
	    _dispatch('*', payload.event, payload.args, e);
	    _dispatch(e.origin, payload.event, payload.args, e);
	    _broadcastPopups(e.data, payload.origin, e.source);
	  }
	
	  function _dispatch(origin, event, args, e) {
	    var i;
	
	    if (!subscribers[origin]) { return; }
	    if (!subscribers[origin][event]) { return; }
	
	    for (i = 0; i < subscribers[origin][event].length; i++) {
	      subscribers[origin][event][i].apply(e, args);
	    }
	  }
	
	  function _hasOpener(frame) {
	    if (frame.top !== frame) { return false; }
	    if (frame.opener == null) { return false; }
	    if (frame.opener === frame) { return false; }
	    if (frame.opener.closed === true) { return false; }
	
	    return true;
	  }
	
	  function _broadcast(frame, payload, origin) {
	    var i;
	
	    try {
	      frame.postMessage(payload, origin);
	
	      if (_hasOpener(frame)) {
	        _broadcast(frame.opener.top, payload, origin);
	      }
	
	      for (i = 0; i < frame.frames.length; i++) {
	        _broadcast(frame.frames[i], payload, origin);
	      }
	    } catch (_) { /* ignored */ }
	  }
	
	  function _broadcastPopups(payload, origin, source) {
	    var i, popup;
	
	    for (i = popups.length - 1; i >= 0; i--) {
	      popup = popups[i];
	
	      if (popup.closed === true) {
	        popups = popups.slice(i, 1);
	      } else if (source !== popup) {
	        _broadcast(popup.top, payload, origin);
	      }
	    }
	  }
	
	  function _subscribeReplier(fn, origin) {
	    var uuid = _uuid();
	
	    function replier(d, o) {
	      fn(d, o);
	      framebus.target(origin).unsubscribe(uuid, replier);
	    }
	
	    framebus.target(origin).subscribe(uuid, replier);
	    return uuid;
	  }
	
	  function _subscriptionArgsInvalid(event, fn, origin) {
	    if (_isntString(event)) { return true; }
	    if (typeof fn !== 'function') { return true; }
	    if (_isntString(origin)) { return true; }
	
	    return false;
	  }
	
	  _attach();
	
	  framebus = {
	    target: target,
	    include: include,
	    publish: publish,
	    pub: publish,
	    trigger: publish,
	    emit: publish,
	    subscribe: subscribe,
	    sub: subscribe,
	    on: subscribe,
	    unsubscribe: unsubscribe,
	    unsub: unsubscribe,
	    off: unsubscribe
	  };
	
	  return framebus;
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enumerate = __webpack_require__(379);
	
	module.exports = enumerate([
	  'CONFIGURATION_REQUEST'
	], 'bus:');


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isWhitelistedDomain = __webpack_require__(392);
	
	function checkOrigin(postMessageOrigin, merchantUrl) {
	  var merchantOrigin, merchantHost;
	  var a = document.createElement('a');
	
	  a.href = merchantUrl;
	
	  if (a.protocol === 'https:') {
	    merchantHost = a.host.replace(/:443$/, '');
	  } else if (a.protocol === 'http:') {
	    merchantHost = a.host.replace(/:80$/, '');
	  } else {
	    merchantHost = a.host;
	  }
	
	  merchantOrigin = a.protocol + '//' + merchantHost;
	
	  if (merchantOrigin === postMessageOrigin) { return true; }
	
	  a.href = postMessageOrigin;
	
	  return isWhitelistedDomain(postMessageOrigin);
	}
	
	module.exports = {
	  checkOrigin: checkOrigin
	};


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enumerate = __webpack_require__(379);
	
	module.exports = enumerate([
	  'DISPATCH_FRAME_READY',
	  'DISPATCH_FRAME_REPORT'
	], 'frameService:');


/***/ },
/* 438 */
/***/ function(module, exports) {

	'use strict';
	
	function useMin(isDebug) {
	  return isDebug ? '' : '.min';
	}
	
	module.exports = useMin;


/***/ },
/* 439 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  LANDING_FRAME_NAME: 'braintreepaypallanding',
	  FLOW_ENDPOINTS: {
	    checkout: 'create_payment_resource',
	    vault: 'setup_billing_agreement'
	  }
	};


/***/ },
/* 440 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (obj) {
	  return Object.keys(obj).filter(function (key) {
	    return typeof obj[key] === 'function';
	  });
	};


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var sharedErrors = __webpack_require__(404);
	
	module.exports = function (instance, methodNames) {
	  methodNames.forEach(function (methodName) {
	    instance[methodName] = function () {
	      throw new BraintreeError({
	        type: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.type,
	        code: sharedErrors.METHOD_CALLED_AFTER_TEARDOWN.code,
	        message: methodName + ' cannot be called after teardown.'
	      });
	    };
	  });
	};


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/paypal-checkout
	 * @description A component to integrate with the [PayPal Checkout.js library](https://github.com/paypal/paypal-checkout).
	 */
	
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var errors = __webpack_require__(443);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var PayPalCheckout = __webpack_require__(444);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link PayPalCheckout} instance.
	 * @example
	 * // Be sure to have checkout.js loaded on your page.
	 * // You can use the paypal-checkout package on npm
	 * // with a build tool or use a script hosted by PayPal:
	 * // <script src="https://www.paypalobjects.com/api/checkout.js" data-version-4 log-level="warn"></script>
	 *
	 * braintree.paypalCheckout.create({
	 *   client: clientInstance
	 * }, function (createErr, paypalCheckoutInstance) {
	 *   if (createErr) {
	 *     console.error('Error!', createErr);
	 *     return;
	 *   }
	 *
	 *   paypal.Button.render({
	 *     env: 'production', // or 'sandbox'
	 *
	 *     locale: 'en_US',
	 *
	 *     payment: function () {
	 *       return paypalCheckoutInstance.createPayment({
	 *         flow: 'vault'
	 *       });
	 *     },
	 *
	 *     onAuthorize: function (data, actions) {
	 *       return paypalCheckoutInstance.tokenizePayment(data).then(function (payload) {
	 *         // Submit payload.nonce to your server
	 *       });
	 *     },
	 *
	 *     onCancel: function (data) {
	 *       console.log('checkout.js payment cancelled', JSON.stringify(data, 0, 2));
	 *     },
	 *
	 *     onError: function (err) {
	 *       console.error('checkout.js error', err);
	 *     }
	 *   }, '#paypal-button'); // the PayPal button will be rendered in an html element with the id `paypal-button`
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var config, clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating PayPal Checkout.'
	    }));
	  }
	
	  config = options.client.getConfiguration();
	  clientVersion = config.analyticsMetadata.sdkVersion;
	
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and PayPal Checkout (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (!config.gatewayConfiguration.paypalEnabled) {
	    return Promise.reject(new BraintreeError(errors.PAYPAL_NOT_ENABLED));
	  }
	
	  if (!config.gatewayConfiguration.paypal.clientId) {
	    return Promise.reject(new BraintreeError(errors.PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED));
	  }
	
	  analytics.sendEvent(options.client, 'paypal-checkout.initialized');
	
	  return Promise.resolve(new PayPalCheckout(options));
	}
	
	/**
	 * @static
	 * @function isSupported
	 * @description Returns true if PayPal Checkout [supports this browser](/current/#browser-support-webviews).
	 * @deprecated Previously, this method checked for Popup support in the brower. Checkout.js now falls back to a modal if popups are not supported.
	 * @example
	 * if (braintree.paypalCheckout.isSupported()) {
	 *   // Add PayPal button to the page
	 * } else {
	 *   // Hide PayPal payment option
	 * }
	 * @returns {Boolean} Returns true if PayPal Checkout supports this browser.
	 */
	function isSupported() {
	  return true;
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  isSupported: isSupported,
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  PAYPAL_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_NOT_ENABLED',
	    message: 'PayPal is not enabled for this merchant.'
	  },
	  PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_SANDBOX_ACCOUNT_NOT_LINKED',
	    message: 'A linked PayPal Sandbox account is required to use PayPal Checkout in Sandbox. See https://developers.braintreepayments.com/guides/paypal/testing-go-live/#linked-paypal-testing for details on linking your PayPal sandbox with Braintree.'
	  },
	  PAYPAL_TOKENIZATION_REQUEST_ACTIVE: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_TOKENIZATION_REQUEST_ACTIVE',
	    message: 'Another tokenization request is active.'
	  },
	  PAYPAL_ACCOUNT_TOKENIZATION_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'PAYPAL_ACCOUNT_TOKENIZATION_FAILED',
	    message: 'Could not tokenize user\'s PayPal account.'
	  },
	  PAYPAL_FLOW_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'PAYPAL_FLOW_FAILED',
	    message: 'Could not initialize PayPal flow.'
	  },
	  PAYPAL_FLOW_OPTION_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_FLOW_OPTION_REQUIRED',
	    message: 'PayPal flow property is invalid or missing.'
	  },
	  PAYPAL_POPUP_OPEN_FAILED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_POPUP_OPEN_FAILED',
	    message: 'PayPal popup failed to open, make sure to tokenize in response to a user action.'
	  },
	  PAYPAL_POPUP_CLOSED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'PAYPAL_POPUP_CLOSED',
	    message: 'Customer closed PayPal popup before authorizing.'
	  },
	  PAYPAL_INVALID_PAYMENT_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'PAYPAL_INVALID_PAYMENT_OPTION',
	    message: 'PayPal payment options are invalid.'
	  }
	};


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var analytics = __webpack_require__(411);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var BraintreeError = __webpack_require__(378);
	var convertToBraintreeError = __webpack_require__(393);
	var errors = __webpack_require__(443);
	var constants = __webpack_require__(439);
	
	/**
	 * PayPal Checkout tokenized payload. Returned in {@link PayPalCheckout#tokenizePayment}'s callback as the second argument, `data`.
	 * @typedef {object} PayPalCheckout~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {string} type The payment method type, always `PayPalAccount`.
	 * @property {object} details Additional PayPal account details.
	 * @property {string} details.email User's email address.
	 * @property {string} details.payerId User's payer ID, the unique identifier for each PayPal account.
	 * @property {string} details.firstName User's given name.
	 * @property {string} details.lastName User's surname.
	 * @property {?string} details.countryCode User's 2 character country code.
	 * @property {?string} details.phone User's phone number (e.g. 555-867-5309).
	 * @property {?object} details.shippingAddress User's shipping address details, only available if shipping address is enabled.
	 * @property {string} details.shippingAddress.recipientName Recipient of postage.
	 * @property {string} details.shippingAddress.line1 Street number and name.
	 * @property {string} details.shippingAddress.line2 Extended address.
	 * @property {string} details.shippingAddress.city City or locality.
	 * @property {string} details.shippingAddress.state State or region.
	 * @property {string} details.shippingAddress.postalCode Postal code.
	 * @property {string} details.shippingAddress.countryCode 2 character country code (e.g. US).
	 * @property {?object} details.billingAddress User's billing address details.
	 * Not available to all merchants; [contact PayPal](https://developers.braintreepayments.com/support/guides/paypal/setup-guide#contacting-paypal-support) for details on eligibility and enabling this feature.
	 * Alternatively, see `shippingAddress` above as an available client option.
	 * @property {string} details.billingAddress.line1 Street number and name.
	 * @property {string} details.billingAddress.line2 Extended address.
	 * @property {string} details.billingAddress.city City or locality.
	 * @property {string} details.billingAddress.state State or region.
	 * @property {string} details.billingAddress.postalCode Postal code.
	 * @property {string} details.billingAddress.countryCode 2 character country code (e.g. US).
	 * @property {?object} creditFinancingOffered This property will only be present when the customer pays with PayPal Credit.
	 * @property {object} creditFinancingOffered.totalCost This is the estimated total payment amount including interest and fees the user will pay during the lifetime of the loan.
	 * @property {string} creditFinancingOffered.totalCost.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.totalCost.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {number} creditFinancingOffered.term Length of financing terms in months.
	 * @property {object} creditFinancingOffered.monthlyPayment This is the estimated amount per month that the customer will need to pay including fees and interest.
	 * @property {string} creditFinancingOffered.monthlyPayment.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.monthlyPayment.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {object} creditFinancingOffered.totalInterest Estimated interest or fees amount the payer will have to pay during the lifetime of the loan.
	 * @property {string} creditFinancingOffered.totalInterest.value An amount defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) for the given currency.
	 * @property {string} creditFinancingOffered.totalInterest.currency 3 letter currency code as defined by [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm).
	 * @property {boolean} creditFinancingOffered.payerAcceptance Status of whether the customer ultimately was approved for and chose to make the payment using the approved installment credit.
	 * @property {boolean} creditFinancingOffered.cartAmountImmutable Indicates whether the cart amount is editable after payer's acceptance on PayPal side.
	 */
	
	/**
	 * @class
	 * @param {object} options see {@link module:braintree-web/paypal-checkout.create|paypal-checkout.create}
	 * @classdesc This class represents a PayPal Checkout component that coordinates with the {@link https://developer.paypal.com/docs/integration/direct/express-checkout/integration-jsv4|PayPal checkout.js} library. Instances of this class can generate payment data and tokenize authorized payments.
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/paypal-checkout.create|braintree-web.paypal-checkout.create} instead.</strong>
	 */
	function PayPalCheckout(options) {
	  this._client = options.client;
	}
	
	/**
	 * Creates a PayPal payment ID or billing token using the given options. This is meant to be passed to PayPal's checkout.js library.
	 * When a {@link callback} is defined, the function returns undefined and invokes the callback with the id to be used with the checkout.js library. Otherwise, it returns a Promise that resolves with the id.
	 * @public
	 * @param {object} options All options for the PayPalCheckout component.
	 * @param {string} options.flow Set to 'checkout' for one-time payment flow, or 'vault' for Vault flow. If 'vault' is used with a client token generated with a customer ID, the PayPal account will be added to that customer as a saved payment method.
	 * @param {string} [options.intent=authorize]
	 * Checkout flows only.
	 * * `authorize` - Submits the transaction for authorization but not settlement.
	 * * `sale` - Payment will be immediately submitted for settlement upon creating a transaction.
	 * @param {boolean} [options.offerCredit=false] Offers the customer PayPal Credit if they qualify.
	 * @param {string|number} [options.amount] The amount of the transaction. Required when using the Checkout flow.
	 * @param {string} [options.currency] The currency code of the amount, such as 'USD'. Required when using the Checkout flow.
	 * @param {string} [options.displayName] The merchant name displayed inside of the PayPal lightbox; defaults to the company name on your Braintree account
	 * @param {string} [options.locale=en_US] Use this option to change the language, links, and terminology used in the PayPal flow. This locale will be used unless the buyer has set a preferred locale for their account. If an unsupported locale is supplied, a fallback locale (determined by buyer preference or browser data) will be used and no error will be thrown.
	 *
	 * Supported locales are:
	 * `da_DK`,
	 * `de_DE`,
	 * `en_AU`,
	 * `en_GB`,
	 * `en_US`,
	 * `es_ES`,
	 * `fr_CA`,
	 * `fr_FR`,
	 * `id_ID`,
	 * `it_IT`,
	 * `ja_JP`,
	 * `ko_KR`,
	 * `nl_NL`,
	 * `no_NO`,
	 * `pl_PL`,
	 * `pt_BR`,
	 * `pt_PT`,
	 * `ru_RU`,
	 * `sv_SE`,
	 * `th_TH`,
	 * `zh_CN`,
	 * `zh_HK`,
	 * and `zh_TW`.
	 *
	 * @param {boolean} [options.enableShippingAddress=false] Returns a shipping address object in {@link PayPal#tokenize}.
	 * @param {object} [options.shippingAddressOverride] Allows you to pass a shipping address you have already collected into the PayPal payment flow.
	 * @param {string} options.shippingAddressOverride.line1 Street address.
	 * @param {string} [options.shippingAddressOverride.line2] Street address (extended).
	 * @param {string} options.shippingAddressOverride.city City.
	 * @param {string} options.shippingAddressOverride.state State.
	 * @param {string} options.shippingAddressOverride.postalCode Postal code.
	 * @param {string} options.shippingAddressOverride.countryCode Country.
	 * @param {string} [options.shippingAddressOverride.phone] Phone number.
	 * @param {string} [options.shippingAddressOverride.recipientName] Recipient's name.
	 * @param {boolean} [options.shippingAddressEditable=true] Set to false to disable user editing of the shipping address.
	 * @param {string} [options.billingAgreementDescription] Use this option to set the description of the preapproved payment agreement visible to customers in their PayPal profile during Vault flows. Max 255 characters.
	 * @param {string} [options.landingPageType=login] Use this option to specify the PayPal page to display when a user lands on the PayPal site to complete the payment.
	 * * `login` - A PayPal account login page is used.
	 * * `billing` - A non-PayPal account landing page is used.
	 * @param {callback} [callback] The second argument is a PayPal `paymentId` or `billingToken` string, depending on whether `options.flow` is `checkout` or `vault`. This is also what is resolved by the promise if no callback is provided.
	 * @example
	 * // this paypal object is created by checkout.js
	 * // see https://github.com/paypal/paypal-checkout
	 * paypal.Button.render({
	 *   // when createPayment resolves, it is automatically passed to checkout.js
	 *   payment: function () {
	 *    return paypalCheckoutInstance.createPayment({
	 *       flow: 'checkout',
	 *       amount: '10.00',
	 *       currency: 'USD',
	 *       intent: 'sale'
	 *     });
	 *   },
	 *   // Add other options, e.g. onAuthorize, env, locale
	 * }, '#paypal-button');
	 *
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	PayPalCheckout.prototype.createPayment = function (options) {
	  var endpoint;
	
	  if (!options || !constants.FLOW_ENDPOINTS.hasOwnProperty(options.flow)) {
	    return Promise.reject(new BraintreeError(errors.PAYPAL_FLOW_OPTION_REQUIRED));
	  }
	
	  endpoint = 'paypal_hermes/' + constants.FLOW_ENDPOINTS[options.flow];
	
	  analytics.sendEvent(this._client, 'paypal-checkout.createPayment');
	  if (options.offerCredit === true) {
	    analytics.sendEvent(this._client, 'paypal-checkout.credit.offered');
	  }
	
	  return this._client.request({
	    endpoint: endpoint,
	    method: 'post',
	    data: this._formatPaymentResourceData(options)
	  }).then(function (response) {
	    var flowToken;
	
	    if (options.flow === 'checkout') {
	      flowToken = response.paymentResource.paymentToken;
	    } else {
	      flowToken = response.agreementSetup.tokenId;
	    }
	
	    return flowToken;
	  }).catch(function (err) {
	    var status = err.details && err.details.httpStatus;
	
	    if (status === 422) {
	      return Promise.reject(new BraintreeError({
	        type: errors.PAYPAL_INVALID_PAYMENT_OPTION.type,
	        code: errors.PAYPAL_INVALID_PAYMENT_OPTION.code,
	        message: errors.PAYPAL_INVALID_PAYMENT_OPTION.message,
	        details: {
	          originalError: err
	        }
	      }));
	    }
	
	    return Promise.reject(convertToBraintreeError(err, {
	      type: errors.PAYPAL_FLOW_FAILED.type,
	      code: errors.PAYPAL_FLOW_FAILED.code,
	      message: errors.PAYPAL_FLOW_FAILED.message
	    }));
	  });
	};
	
	/**
	 * Tokenizes the authorize data from PayPal's checkout.js library when completing a buyer approval flow.
	 * When a {@link callback} is defined, invokes the callback with {@link PayPalCheckout~tokenizePayload|tokenizePayload} and returns undefined. Otherwise, returns a Promise that resolves with a {@link PayPalCheckout~tokenizePayload|tokenizePayload}.
	 * @public
	 * @param {object} tokenizeOptions Tokens and IDs required to tokenize the payment.
	 * @param {string} tokenizeOptions.payerId Payer ID returned by PayPal `onAuthorize` callback.
	 * @param {string} [tokenizeOptions.paymentId] Payment ID returned by PayPal `onAuthorize` callback.
	 * @param {string} [tokenizeOptions.billingToken] Billing Token returned by PayPal `onAuthorize` callback.
	 * @param {callback} [callback] The second argument, <code>payload</code>, is a {@link PayPalCheckout~tokenizePayload|tokenizePayload}. If no callback is provided, the promise resolves with a {@link PayPalCheckout~tokenizePayload|tokenizePayload}.
	 * @example
	 * // this paypal object is created by checkout.js
	 * // see https://github.com/paypal/paypal-checkout
	 * paypal.Button.render({
	 *   onAuthorize: function (data, actions) {
	 *     return paypalCheckoutInstance.tokenizePayment(data).then(function (payload) {
	 *       // Submit payload.nonce to your server
	 *     }).catch(function (err) {
	 *       // handle error
	 *     });
	 *   },
	 *   // Add other options, e.g. payment, env, locale
	 * }, '#paypal-button');
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	PayPalCheckout.prototype.tokenizePayment = function (tokenizeOptions) {
	  var self = this;
	  var payload;
	  var client = this._client;
	  var options = {
	    flow: tokenizeOptions.billingToken ? 'vault' : 'checkout',
	    intent: tokenizeOptions.intent
	  };
	  var params = {
	    // The paymentToken provided by Checkout.js v4 is the ECToken
	    ecToken: tokenizeOptions.paymentToken,
	    billingToken: tokenizeOptions.billingToken,
	    payerId: tokenizeOptions.payerID,
	    paymentId: tokenizeOptions.paymentID
	  };
	
	  analytics.sendEvent(client, 'paypal-checkout.tokenization.started');
	
	  return client.request({
	    endpoint: 'payment_methods/paypal_accounts',
	    method: 'post',
	    data: self._formatTokenizeData(options, params)
	  }).then(function (response) {
	    payload = self._formatTokenizePayload(response);
	
	    analytics.sendEvent(client, 'paypal-checkout.tokenization.success');
	    if (payload.creditFinancingOffered) {
	      analytics.sendEvent(client, 'paypal-checkout.credit.accepted');
	    }
	
	    return payload;
	  }).catch(function (err) {
	    analytics.sendEvent(client, 'paypal-checkout.tokenization.failed');
	
	    return Promise.reject(convertToBraintreeError(err, {
	      type: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.type,
	      code: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.code,
	      message: errors.PAYPAL_ACCOUNT_TOKENIZATION_FAILED.message
	    }));
	  });
	};
	
	PayPalCheckout.prototype._formatPaymentResourceData = function (options) {
	  var key;
	  var gatewayConfiguration = this._client.getConfiguration().gatewayConfiguration;
	  var paymentResource = {
	    // returnUrl and cancelUrl are required in hermes create_payment_resource route
	    // but are not validated and are not actually used with checkout.js
	    returnUrl: 'x',
	    cancelUrl: 'x',
	    offerPaypalCredit: options.offerCredit === true,
	    experienceProfile: {
	      brandName: options.displayName || gatewayConfiguration.paypal.displayName,
	      localeCode: options.locale,
	      noShipping: (!options.enableShippingAddress).toString(),
	      addressOverride: options.shippingAddressEditable === false,
	      landingPageType: options.landingPageType
	    }
	  };
	
	  if (options.flow === 'checkout') {
	    paymentResource.amount = options.amount;
	    paymentResource.currencyIsoCode = options.currency;
	
	    if (options.hasOwnProperty('intent')) {
	      paymentResource.intent = options.intent;
	    }
	
	    for (key in options.shippingAddressOverride) {
	      if (options.shippingAddressOverride.hasOwnProperty(key)) {
	        paymentResource[key] = options.shippingAddressOverride[key];
	      }
	    }
	  } else {
	    paymentResource.shippingAddress = options.shippingAddressOverride;
	
	    if (options.billingAgreementDescription) {
	      paymentResource.description = options.billingAgreementDescription;
	    }
	  }
	
	  return paymentResource;
	};
	
	PayPalCheckout.prototype._formatTokenizeData = function (options, params) {
	  var clientConfiguration = this._client.getConfiguration();
	  var gatewayConfiguration = clientConfiguration.gatewayConfiguration;
	  var isTokenizationKey = clientConfiguration.authorizationType === 'TOKENIZATION_KEY';
	  var data = {
	    paypalAccount: {
	      correlationId: params.billingToken || params.ecToken,
	      options: {
	        validate: options.flow === 'vault' && !isTokenizationKey
	      }
	    }
	  };
	
	  if (params.billingToken) {
	    data.paypalAccount.billingAgreementToken = params.billingToken;
	  } else {
	    data.paypalAccount.paymentToken = params.paymentId;
	    data.paypalAccount.payerId = params.payerId;
	    data.paypalAccount.unilateral = gatewayConfiguration.paypal.unvettedMerchant;
	
	    if (options.intent) {
	      data.paypalAccount.intent = options.intent;
	    }
	  }
	
	  return data;
	};
	
	PayPalCheckout.prototype._formatTokenizePayload = function (response) {
	  var payload;
	  var account = {};
	
	  if (response.paypalAccounts) {
	    account = response.paypalAccounts[0];
	  }
	
	  payload = {
	    nonce: account.nonce,
	    details: {},
	    type: account.type
	  };
	
	  if (account.details && account.details.payerInfo) {
	    payload.details = account.details.payerInfo;
	  }
	
	  if (account.details && account.details.creditFinancingOffered) {
	    payload.creditFinancingOffered = account.details.creditFinancingOffered;
	  }
	
	  return payload;
	};
	
	module.exports = wrapPromise.wrapPrototype(PayPalCheckout);


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/** @module braintree-web/hosted-fields */
	
	var HostedFields = __webpack_require__(446);
	var wrapPromise = __webpack_require__(406);
	var Promise = __webpack_require__(399);
	var VERSION = "3.14.0";
	
	/**
	 * Fields used in {@link module:braintree-web/hosted-fields~fieldOptions fields options}
	 * @typedef {object} field
	 * @property {string} selector A CSS selector to find the container where the hosted field will be inserted.
	 * @property {string} [placeholder] Will be used as the `placeholder` attribute of the input. If `placeholder` is not natively supported by the browser, it will be polyfilled.
	 * @property {string} [type] Will be used as the `type` attribute of the input. To mask `cvv` input, for instance, `type: "password"` can be used.
	 * @property {boolean} [formatInput=true] Enable or disable automatic formatting on this field.
	 * @property {object|boolean} [select] If truthy, this field becomes a `<select>` dropdown list. This can only be used for `expirationMonth` and `expirationYear` fields. If you do not use a `placeholder` property for the field, the current month/year will be the default selected value.
	 * @property {string[]} [select.options] An array of 12 strings, one per month. This can only be used for the `expirationMonth` field. For example, the array can look like `['01 - January', '02 - February', ...]`.
	 * @property {number} [maxlength] Will be used as the `maxlength` attribute of the input if it is less than the default. The primary use cases for the `maxlength` option are: limiting the length of the CVV input for CVV-only verifications when the card type is known and limiting the length of the postal code input when cards are coming from a known region. This option applies only to CVV and postal code fields.
	 */
	
	/**
	 * An object that has {@link module:braintree-web/hosted-fields~field field objects} for each field. Used in {@link module:braintree-web/hosted-fields~create create}.
	 * @typedef {object} fieldOptions
	 * @property {field} [number] A field for card number.
	 * @property {field} [expirationDate] A field for expiration date in `MM/YYYY` format. This should not be used with the `expirationMonth` and `expirationYear` properties.
	 * @property {field} [expirationMonth] A field for expiration month in `MM` format. This should be used with the `expirationYear` property.
	 * @property {field} [expirationYear] A field for expiration year in `YYYY` format. This should be used with the `expirationMonth` property.
	 * @property {field} [cvv] A field for 3 or 4 digit CVV or CID.
	 * @property {field} [postalCode] A field for postal or region code.
	 */
	
	/**
	 * An object that represents CSS that will be applied in each hosted field. This object looks similar to CSS. Typically, these styles involve fonts (such as `font-family` or `color`).
	 *
	 * These are the CSS properties that Hosted Fields supports. Any other CSS should be specified on your page and outside of any Braintree configuration. Trying to set unsupported properties will fail and put a warning in the console.
	 *
	 * Supported CSS properties are:
	 * `appearance`
	 * `color`
	 * `direction`
	 * `font-family`
	 * `font-size-adjust`
	 * `font-size`
	 * `font-stretch`
	 * `font-style`
	 * `font-variant-alternates`
	 * `font-variant-caps`
	 * `font-variant-east-asian`
	 * `font-variant-ligatures`
	 * `font-variant-numeric`
	 * `font-variant`
	 * `font-weight`
	 * `font`
	 * `letter-spacing`
	 * `line-height`
	 * `opacity`
	 * `outline`
	 * `text-shadow`
	 * `transition`
	 * `-moz-appearance`
	 * `-moz-osx-font-smoothing`
	 * `-moz-tap-highlight-color`
	 * `-moz-transition`
	 * `-webkit-appearance`
	 * `-webkit-font-smoothing`
	 * `-webkit-tap-highlight-color`
	 * `-webkit-transition`
	 * @typedef {object} styleOptions
	 */
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {fieldOptions} options.fields A {@link module:braintree-web/hosted-fields~fieldOptions set of options for each field}.
	 * @param {styleOptions} options.styles {@link module:braintree-web/hosted-fields~styleOptions Styles} applied to each field.
	 * @param {callback} [callback] The second argument, `data`, is the {@link HostedFields} instance. If no callback is provided, `create` returns a promise that resolves with the {@link HostedFields} instance.
	 * @returns {void}
	 * @example
	 * braintree.hostedFields.create({
	 *   client: clientInstance,
	 *   styles: {
	 *     'input': {
	 *       'font-size': '16pt',
	 *       'color': '#3A3A3A'
	 *     },
	 *     '.number': {
	 *       'font-family': 'monospace'
	 *     },
	 *     '.valid': {
	 *       'color': 'green'
	 *     }
	 *   },
	 *   fields: {
	 *     number: {
	 *       selector: '#card-number'
	 *     },
	 *     cvv: {
	 *       selector: '#cvv',
	 *       placeholder: '•••'
	 *     },
	 *     expirationDate: {
	 *       selector: '#expiration-date',
	 *       type: 'month'
	 *     }
	 *   }
	 * }, callback);
	 * @example <caption>Right to Left Language Support</caption>
	 * braintree.hostedFields.create({
	 *   client: clientInstance,
	 *   styles: {
	 *     'input': {
	 *       // other styles
	 *       direction: 'rtl'
	 *     },
	 *   },
	 *   fields: {
	 *     number: {
	 *       selector: '#card-number',
	 *       // Credit card formatting is not currently supported
	 *       // with RTL languages, so we need to turn it off for the number input
	 *       formatInput: false
	 *     },
	 *     cvv: {
	 *       selector: '#cvv',
	 *       placeholder: '•••'
	 *     },
	 *     expirationDate: {
	 *       selector: '#expiration-date',
	 *       type: 'month'
	 *     }
	 *   }
	 * }, callback);
	 */
	function create(options) {
	  var integration;
	
	  return new Promise(function (resolve) {
	    integration = new HostedFields(options);
	
	    integration.on('ready', function () {
	      resolve(integration);
	    });
	  });
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Destructor = __webpack_require__(447);
	var classlist = __webpack_require__(449);
	var iFramer = __webpack_require__(423);
	var Bus = __webpack_require__(433);
	var BraintreeError = __webpack_require__(378);
	var composeUrl = __webpack_require__(450);
	var constants = __webpack_require__(451);
	var errors = __webpack_require__(452);
	var INTEGRATION_TIMEOUT_MS = __webpack_require__(398).INTEGRATION_TIMEOUT_MS;
	var uuid = __webpack_require__(384);
	var findParentTags = __webpack_require__(453);
	var isIos = __webpack_require__(431);
	var events = constants.events;
	var EventEmitter = __webpack_require__(454);
	var injectFrame = __webpack_require__(455);
	var analytics = __webpack_require__(411);
	var whitelistedFields = constants.whitelistedFields;
	var VERSION = "3.14.0";
	var methods = __webpack_require__(440);
	var convertMethodsToError = __webpack_require__(441);
	var sharedErrors = __webpack_require__(404);
	var getCardTypes = __webpack_require__(456);
	var attributeValidationError = __webpack_require__(457);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @typedef {object} HostedFields~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {object} details Additional account details.
	 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
	 * @property {string} details.lastTwo Last two digits of card number.
	 * @property {string} description A human-readable description.
	 * @property {string} type The payment method type, always `CreditCard`.
	 */
	
	/**
	 * @typedef {object} HostedFields~stateObject
	 * @description The event payload sent from {@link HostedFields#on|on} or {@link HostedFields#getState|getState}.
	 * @property {HostedFields~hostedFieldsCard[]} cards
	 * This will return an array of potential {@link HostedFields~hostedFieldsCard|cards}. If the card type has been determined, the array will contain only one card.
	 * Internally, Hosted Fields uses <a href="https://github.com/braintree/credit-card-type">credit-card-type</a>,
	 * an open-source card detection library.
	 * @property {string} emittedBy
	 * The name of the field associated with an event. This will not be included if returned by {@link HostedFields#getState|getState}. It will be one of the following strings:<br>
	 * - `"number"`
	 * - `"cvv"`
	 * - `"expirationDate"`
	 * - `"expirationMonth"`
	 * - `"expirationYear"`
	 * - `"postalCode"`
	 * @property {object} fields
	 * @property {?HostedFields~hostedFieldsFieldData} fields.number {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the number field, if it is present.
	 * @property {?HostedFields~hostedFieldsFieldData} fields.cvv {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the CVV field, if it is present.
	 * @property {?HostedFields~hostedFieldsFieldData} fields.expirationDate {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the expiration date field, if it is present.
	 * @property {?HostedFields~hostedFieldsFieldData} fields.expirationMonth {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the expiration month field, if it is present.
	 * @property {?HostedFields~hostedFieldsFieldData} fields.expirationYear {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the expiration year field, if it is present.
	 * @property {?HostedFields~hostedFieldsFieldData} fields.postalCode {@link HostedFields~hostedFieldsFieldData|hostedFieldsFieldData} for the postal code field, if it is present.
	 */
	
	/**
	 * @typedef {object} HostedFields~hostedFieldsFieldData
	 * @description Data about Hosted Fields fields, sent in {@link HostedFields~stateObject|stateObjects}.
	 * @property {HTMLElement} container Reference to the container DOM element on your page associated with the current event.
	 * @property {boolean} isFocused Whether or not the input is currently focused.
	 * @property {boolean} isEmpty Whether or not the user has entered a value in the input.
	 * @property {boolean} isPotentiallyValid
	 * A determination based on the future validity of the input value.
	 * This is helpful when a user is entering a card number and types <code>"41"</code>.
	 * While that value is not valid for submission, it is still possible for
	 * it to become a fully qualified entry. However, if the user enters <code>"4x"</code>
	 * it is clear that the card number can never become valid and isPotentiallyValid will
	 * return false.
	 * @property {boolean} isValid Whether or not the value of the associated input is <i>fully</i> qualified for submission.
	 */
	
	/**
	 * @typedef {object} HostedFields~hostedFieldsCard
	 * @description Information about the card type, sent in {@link HostedFields~stateObject|stateObjects}.
	 * @property {string} type The code-friendly representation of the card type. It will be one of the following strings:
	 * - `american-express`
	 * - `diners-club`
	 * - `discover`
	 * - `jcb`
	 * - `maestro`
	 * - `master-card`
	 * - `unionpay`
	 * - `visa`
	 * @property {string} niceType The pretty-printed card type. It will be one of the following strings:
	 * - `American Express`
	 * - `Diners Club`
	 * - `Discover`
	 * - `JCB`
	 * - `Maestro`
	 * - `MasterCard`
	 * - `UnionPay`
	 * - `Visa`
	 * @property {object} code
	 * This object contains data relevant to the security code requirements of the card brand.
	 * For example, on a Visa card there will be a <code>CVV</code> of 3 digits, whereas an
	 * American Express card requires a 4-digit <code>CID</code>.
	 * @property {string} code.name <code>"CVV"</code> <code>"CID"</code> <code>"CVC"</code>
	 * @property {number} code.size The expected length of the security code. Typically, this is 3 or 4.
	 */
	
	/**
	 * @name HostedFields#on
	 * @function
	 * @param {string} event The name of the event to which you are subscribing.
	 * @param {function} handler A callback to handle the event.
	 * @description Subscribes a handler function to a named event. `event` should be {@link HostedFields#event:blur|blur}, {@link HostedFields#event:focus|focus}, {@link HostedFields#event:empty|empty}, {@link HostedFields#event:notEmpty|notEmpty}, {@link HostedFields#event:cardTypeChange|cardTypeChange}, or {@link HostedFields#event:validityChange|validityChange}. Events will emit a {@link HostedFields~stateObject|stateObject}.
	 * @example
	 * <caption>Listening to a Hosted Field event, in this case 'focus'</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('focus', function (event) {
	 *     console.log(event.emittedBy, 'has been focused');
	 *   });
	 * });
	 * @returns {void}
	 */
	
	/**
	 * This event is emitted when the user requests submission of an input field, such as by pressing the Enter or Return key on their keyboard, or mobile equivalent.
	 * @event HostedFields#inputSubmitRequest
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Clicking a submit button upon hitting Enter (or equivalent) within a Hosted Field</caption>
	 * var hostedFields = require('braintree-web/hosted-fields');
	 * var submitButton = document.querySelector('input[type="submit"]');
	 *
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('inputSubmitRequest', function () {
	 *     // User requested submission, e.g. by pressing Enter or equivalent
	 *     submitButton.click();
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when a field transitions from having data to being empty.
	 * @event HostedFields#empty
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to an empty event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('empty', function (event) {
	 *     console.log(event.emittedBy, 'is now empty');
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when a field transitions from being empty to having data.
	 * @event HostedFields#notEmpty
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to an notEmpty event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('notEmpty', function (event) {
	 *     console.log(event.emittedBy, 'is now not empty');
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when a field loses focus.
	 * @event HostedFields#blur
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to a blur event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('blur', function (event) {
	 *     console.log(event.emittedBy, 'lost focus');
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when a field gains focus.
	 * @event HostedFields#focus
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to a focus event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('focus', function (event) {
	 *     console.log(event.emittedBy, 'gained focus');
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when activity within the number field has changed such that the possible card type has changed.
	 * @event HostedFields#cardTypeChange
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to a cardTypeChange event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('cardTypeChange', function (event) {
	 *     if (event.cards.length === 1) {
	 *       console.log(event.cards[0].type);
	 *     } else {
	 *       console.log('Type of card not yet known');
	 *     }
	 *   });
	 * });
	 */
	
	/**
	 * This event is emitted when the validity of a field has changed. Validity is represented in the {@link HostedFields~stateObject|stateObject} as two booleans: `isValid` and `isPotentiallyValid`.
	 * @event HostedFields#validityChange
	 * @type {HostedFields~stateObject}
	 * @example
	 * <caption>Listening to a validityChange event</caption>
	 * hostedFields.create({ ... }, function (createErr, hostedFieldsInstance) {
	 *   hostedFieldsInstance.on('validityChange', function (event) {
	 *     var field = event.fields[event.emittedBy];
	 *
	 *     if (field.isValid) {
	 *       console.log(event.emittedBy, 'is fully valid');
	 *     } else if (field.isPotentiallyValid) {
	 *       console.log(event.emittedBy, 'is potentially valid');
	 *     } else {
	 *       console.log(event.emittedBy, 'is not valid');
	 *     }
	 *   });
	 * });
	 */
	
	function createInputEventHandler(fields) {
	  return function (eventData) {
	    var field;
	    var merchantPayload = eventData.merchantPayload;
	    var emittedBy = merchantPayload.emittedBy;
	    var container = fields[emittedBy].containerElement;
	
	    Object.keys(merchantPayload.fields).forEach(function (key) {
	      merchantPayload.fields[key].container = fields[key].containerElement;
	    });
	
	    field = merchantPayload.fields[emittedBy];
	
	    classlist.toggle(container, constants.externalClasses.FOCUSED, field.isFocused);
	    classlist.toggle(container, constants.externalClasses.VALID, field.isValid);
	    classlist.toggle(container, constants.externalClasses.INVALID, !field.isPotentiallyValid);
	
	    this._state = { // eslint-disable-line no-invalid-this
	      cards: merchantPayload.cards,
	      fields: merchantPayload.fields
	    };
	
	    this._emit(eventData.type, merchantPayload); // eslint-disable-line no-invalid-this
	  };
	}
	
	/**
	 * @class HostedFields
	 * @param {object} options The Hosted Fields {@link module:braintree-web/hosted-fields.create create} options.
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/hosted-fields.create|braintree-web.hosted-fields.create} instead.</strong>
	 * @classdesc This class represents a Hosted Fields component produced by {@link module:braintree-web/hosted-fields.create|braintree-web/hosted-fields.create}. Instances of this class have methods for interacting with the input fields within Hosted Fields' iframes.
	 */
	function HostedFields(options) {
	  var failureTimeout, clientVersion, clientConfig;
	  var self = this;
	  var fields = {};
	  var fieldCount = 0;
	  var componentId = uuid();
	
	  if (!options.client) {
	    throw new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Hosted Fields.'
	    });
	  }
	
	  clientConfig = options.client.getConfiguration();
	  clientVersion = clientConfig.analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    throw new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Hosted Fields (version ' + VERSION + ') components must be from the same SDK version.'
	    });
	  }
	
	  if (!options.fields) {
	    throw new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.fields is required when instantiating Hosted Fields.'
	    });
	  }
	
	  EventEmitter.call(this);
	
	  this._injectedNodes = [];
	  this._destructor = new Destructor();
	  this._fields = fields;
	  this._state = {
	    fields: {},
	    cards: getCardTypes('')
	  };
	
	  this._bus = new Bus({
	    channel: componentId,
	    merchantUrl: location.href
	  });
	
	  this._destructor.registerFunctionForTeardown(function () {
	    self._bus.teardown();
	  });
	
	  this._client = options.client;
	
	  analytics.sendEvent(this._client, 'custom.hosted-fields.initialized');
	
	  Object.keys(options.fields).forEach(function (key) {
	    var field, container, frame;
	
	    if (!constants.whitelistedFields.hasOwnProperty(key)) {
	      throw new BraintreeError({
	        type: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.type,
	        code: errors.HOSTED_FIELDS_INVALID_FIELD_KEY.code,
	        message: '"' + key + '" is not a valid field.'
	      });
	    }
	
	    field = options.fields[key];
	
	    container = document.querySelector(field.selector);
	
	    if (!container) {
	      throw new BraintreeError({
	        type: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.type,
	        code: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.code,
	        message: errors.HOSTED_FIELDS_INVALID_FIELD_SELECTOR.message,
	        details: {
	          fieldSelector: field.selector,
	          fieldKey: key
	        }
	      });
	    } else if (container.querySelector('iframe[name^="braintree-"]')) {
	      throw new BraintreeError({
	        type: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.type,
	        code: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.code,
	        message: errors.HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME.message,
	        details: {
	          fieldSelector: field.selector,
	          fieldKey: key
	        }
	      });
	    }
	
	    if (field.maxlength && typeof field.maxlength !== 'number') {
	      throw new BraintreeError({
	        type: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.type,
	        code: errors.HOSTED_FIELDS_FIELD_PROPERTY_INVALID.code,
	        message: 'The value for maxlength must be a number.',
	        details: {
	          fieldKey: key
	        }
	      });
	    }
	
	    frame = iFramer({
	      type: key,
	      name: 'braintree-hosted-field-' + key,
	      style: constants.defaultIFrameStyle
	    });
	
	    this._injectedNodes = this._injectedNodes.concat(injectFrame(frame, container));
	    this._setupLabelFocus(key, container);
	    fields[key] = {
	      frameElement: frame,
	      containerElement: container
	    };
	    fieldCount++;
	
	    this._state.fields[key] = {
	      isEmpty: true,
	      isValid: false,
	      isPotentiallyValid: true,
	      isFocused: false,
	      container: container
	    };
	
	    setTimeout(function () {
	      frame.src = composeUrl(clientConfig.gatewayConfiguration.assetsUrl, componentId, clientConfig.isDebug);
	    }, 0);
	  }.bind(this));
	
	  failureTimeout = setTimeout(function () {
	    analytics.sendEvent(self._client, 'custom.hosted-fields.load.timed-out');
	  }, INTEGRATION_TIMEOUT_MS);
	
	  this._bus.on(events.FRAME_READY, function (reply) {
	    fieldCount--;
	    if (fieldCount === 0) {
	      clearTimeout(failureTimeout);
	      reply(options);
	      self._emit('ready');
	    }
	  });
	
	  this._bus.on(
	    events.INPUT_EVENT,
	    createInputEventHandler(fields).bind(this)
	  );
	
	  this._destructor.registerFunctionForTeardown(function () {
	    var j, node, parent;
	
	    for (j = 0; j < self._injectedNodes.length; j++) {
	      node = self._injectedNodes[j];
	      parent = node.parentNode;
	
	      parent.removeChild(node);
	
	      classlist.remove(
	        parent,
	        constants.externalClasses.FOCUSED,
	        constants.externalClasses.INVALID,
	        constants.externalClasses.VALID
	      );
	    }
	  });
	
	  this._destructor.registerFunctionForTeardown(function () {
	    var methodNames = methods(HostedFields.prototype).concat(methods(EventEmitter.prototype));
	
	    convertMethodsToError(self, methodNames);
	  });
	}
	
	HostedFields.prototype = Object.create(EventEmitter.prototype, {
	  constructor: HostedFields
	});
	
	HostedFields.prototype._setupLabelFocus = function (type, container) {
	  var labels, i;
	  var shouldSkipLabelFocus = isIos();
	  var bus = this._bus;
	
	  if (shouldSkipLabelFocus) { return; }
	  if (container.id == null) { return; }
	
	  function triggerFocus() {
	    bus.emit(events.TRIGGER_INPUT_FOCUS, type);
	  }
	
	  labels = Array.prototype.slice.call(document.querySelectorAll('label[for="' + container.id + '"]'));
	  labels = labels.concat(findParentTags(container, 'label'));
	
	  for (i = 0; i < labels.length; i++) {
	    labels[i].addEventListener('click', triggerFocus, false);
	  }
	
	  this._destructor.registerFunctionForTeardown(function () {
	    for (i = 0; i < labels.length; i++) {
	      labels[i].removeEventListener('click', triggerFocus, false);
	    }
	  });
	};
	
	/**
	 * Cleanly remove anything set up by {@link module:braintree-web/hosted-fields.create|create}.
	 * @public
	 * @param {callback} [callback] Called on completion, containing an error if one occurred. No data is returned if teardown completes successfully. If no callback is provided, `teardown` returns a promise.
	 * @example
	 * hostedFieldsInstance.teardown(function (teardownErr) {
	 *   if (teardownErr) {
	 *     console.error('Could not tear down Hosted Fields!');
	 *   } else {
	 *     console.info('Hosted Fields has been torn down!');
	 *   }
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.teardown = function () {
	  var self = this;
	
	  return new Promise(function (resolve, reject) {
	    self._destructor.teardown(function (err) {
	      analytics.sendEvent(self._client, 'custom.hosted-fields.teardown-completed');
	
	      if (err) {
	        reject(err);
	      } else {
	        resolve();
	      }
	    });
	  });
	};
	
	/**
	 * Tokenizes fields and returns a nonce payload.
	 * @public
	 * @param {object} [options] All tokenization options for the Hosted Fields component.
	 * @param {boolean} [options.vault=false] When true, will vault the tokenized card. Cards will only be vaulted when using a client created with a client token that includes a customer ID.
	 * @param {string} [options.billingAddress.postalCode] When supplied, this postal code will be tokenized along with the contents of the fields. If a postal code is provided as part of the Hosted Fields configuration, the value of the field will be tokenized and this value will be ignored.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link HostedFields~tokenizePayload|tokenizePayload}. If no callback is provided, `tokenize` returns a function that resolves with a {@link HostedFields~tokenizePayload|tokenizePayload}.
	 * @example <caption>Tokenize a card</caption>
	 * hostedFieldsInstance.tokenize(function (tokenizeErr, payload) {
	 *   if (tokenizeErr) {
	 *     switch (tokenizeErr.code) {
	 *       case 'HOSTED_FIELDS_FIELDS_EMPTY':
	 *         console.error('All fields are empty! Please fill out the form.');
	 *         break;
	 *       case 'HOSTED_FIELDS_FIELDS_INVALID':
	 *         console.error('Some fields are invalid:', tokenizeErr.details.invalidFieldKeys);
	 *         break;
	 *       case 'HOSTED_FIELDS_FAILED_TOKENIZATION':
	 *         console.error('Tokenization failed server side. Is the card valid?');
	 *         break;
	 *       case 'HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE':
	 *         // will only get here if you generate a client token with a customer ID
	 *         // with the fail on duplicate payment method option. See:
	 *         // https://developers.braintreepayments.com/reference/request/client-token/generate/#options.fail_on_duplicate_payment_method
	 *         console.error('This payment method already exists in your vault.');
	 *         break;
	 *       case 'HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED':
	 *         // will only get here if you generate a client token with a customer ID
	 *         // with the verify card option or if you have credit card verification
	 *         // turned on in your Braintree Gateway. See
	 *         // https://developers.braintreepayments.com/reference/request/client-token/generate/#options.verify_card
	 *         console.error('CVV did not pass verification');
	 *         break;
	 *       case 'HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR':
	 *         console.error('Network error occurred when tokenizing.');
	 *         break;
	 *       default:
	 *         console.error('Something bad happened!', tokenizeErr);
	 *     }
	 *   } else {
	 *     console.log('Got nonce:', payload.nonce);
	 *   }
	 * });
	 * @example <caption>Tokenize and vault a card</caption>
	 * hostedFieldsInstance.tokenize({
	 *   vault: true
	 * }, function (tokenizeErr, payload) {
	 *   if (tokenizeErr) {
	 *     console.error(tokenizeErr);
	 *   } else {
	 *     console.log('Got nonce:', payload.nonce);
	 *   }
	 * });
	 * @example <caption>Tokenize a card with the postal code option</caption>
	 * hostedFieldsInstance.tokenize({
	 *   billingAddress: {
	 *     postalCode: '11111'
	 *   }
	 * }, function (tokenizeErr, payload) {
	 *   if (tokenizeErr) {
	 *     console.error(tokenizeErr);
	 *   } else {
	 *     console.log('Got nonce:', payload.nonce);
	 *   }
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.tokenize = function (options) {
	  var self = this;
	
	  if (!options) {
	    options = {};
	  }
	
	  return new Promise(function (resolve, reject) {
	    self._bus.emit(events.TOKENIZATION_REQUEST, options, function (response) {
	      var err = response[0];
	      var payload = response[1];
	
	      if (err) {
	        reject(err);
	      } else {
	        resolve(payload);
	      }
	    });
	  });
	};
	
	/**
	 * Add a class to a {@link module:braintree-web/hosted-fields~field field}. Useful for updating field styles when events occur elsewhere in your checkout.
	 * @public
	 * @param {string} field The field you wish to add a class to. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {string} classname The class to be added.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the class is added successfully.
	 *
	 * @example
	 * hostedFieldsInstance.addClass('number', 'custom-class', function (addClassErr) {
	 *   if (addClassErr) {
	 *     console.error(addClassErr);
	 *   }
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.addClass = function (field, classname) {
	  var err;
	
	  if (!whitelistedFields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + field + '" is not a valid field. You must use a valid field option when adding a class.'
	    });
	  } else if (!this._fields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot add class to "' + field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    this._bus.emit(events.ADD_CLASS, field, classname);
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * Removes a class to a {@link module:braintree-web/hosted-fields~field field}. Useful for updating field styles when events occur elsewhere in your checkout.
	 * @public
	 * @param {string} field The field you wish to remove a class from. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {string} classname The class to be removed.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the class is removed successfully.
	 *
	 * @example
	 * hostedFieldsInstance.addClass('number', 'custom-class', function (addClassErr) {
	 *   if (addClassErr) {
	 *     console.error(addClassErr);
	 *     return;
	 *   }
	 *
	 *   // some time later...
	 *   hostedFieldsInstance.removeClass('number', 'custom-class');
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.removeClass = function (field, classname) {
	  var err;
	
	  if (!whitelistedFields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + field + '" is not a valid field. You must use a valid field option when removing a class.'
	    });
	  } else if (!this._fields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot remove class from "' + field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    this._bus.emit(events.REMOVE_CLASS, field, classname);
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * Sets an attribute of a {@link module:braintree-web/hosted-fields~field field}.
	 * Supported attributes are `aria-invalid`, `aria-required`, `disabled`, and `placeholder`.
	 *
	 * @public
	 * @param {object} options The options for the attribute you wish to set.
	 * @param {string} options.field The field to which you wish to add an attribute. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {string} options.attribute The name of the attribute you wish to add to the field.
	 * @param {string} options.value The value for the attribute.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the attribute is set successfully.
	 *
	 * @example <caption>Set the placeholder attribute of a field</caption>
	 * hostedFieldsInstance.setAttribute({
	 *   field: 'number',
	 *   attribute: 'placeholder',
	 *   value: '1111 1111 1111 1111'
	 * }, function (attributeErr) {
	 *   if (attributeErr) {
	 *     console.error(attributeErr);
	 *   }
	 * });
	 *
	 * @example <caption>Set the aria-required attribute of a field</caption>
	 * hostedFieldsInstance.setAttribute({
	 *   field: 'number',
	 *   attribute: 'aria-required',
	 *   value: true
	 * }, function (attributeErr) {
	 *   if (attributeErr) {
	 *     console.error(attributeErr);
	 *   }
	 * });
	 *
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.setAttribute = function (options) {
	  var attributeErr, err;
	
	  if (!whitelistedFields.hasOwnProperty(options.field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + options.field + '" is not a valid field. You must use a valid field option when setting an attribute.'
	    });
	  } else if (!this._fields.hasOwnProperty(options.field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot set attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    attributeErr = attributeValidationError(options.attribute, options.value);
	
	    if (attributeErr) {
	      err = attributeErr;
	    } else {
	      this._bus.emit(events.SET_ATTRIBUTE, options.field, options.attribute, options.value);
	    }
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * Removes a supported attribute from a {@link module:braintree-web/hosted-fields~field field}.
	 *
	 * @public
	 * @param {object} options The options for the attribute you wish to remove.
	 * @param {string} options.field The field from which you wish to remove an attribute. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {string} options.attribute The name of the attribute you wish to remove from the field.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the attribute is removed successfully.
	 *
	 * @example <caption>Remove the placeholder attribute of a field</caption>
	 * hostedFieldsInstance.removeAttribute({
	 *   field: 'number',
	 *   attribute: 'placeholder'
	 * }, function (attributeErr) {
	 *   if (attributeErr) {
	 *     console.error(attributeErr);
	 *   }
	 * });
	 *
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.removeAttribute = function (options) {
	  var attributeErr, err;
	
	  if (!whitelistedFields.hasOwnProperty(options.field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + options.field + '" is not a valid field. You must use a valid field option when removing an attribute.'
	    });
	  } else if (!this._fields.hasOwnProperty(options.field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot remove attribute for "' + options.field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    attributeErr = attributeValidationError(options.attribute);
	
	    if (attributeErr) {
	      err = attributeErr;
	    } else {
	      this._bus.emit(events.REMOVE_ATTRIBUTE, options.field, options.attribute);
	    }
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * @deprecated since version 3.8.0. Use {@link HostedFields#setAttribute|setAttribute} instead.
	 *
	 * @public
	 * @param {string} field The field whose placeholder you wish to change. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {string} placeholder Will be used as the `placeholder` attribute of the input.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the placeholder updated successfully.
	 *
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	HostedFields.prototype.setPlaceholder = function (field, placeholder) {
	  return this.setAttribute({
	    field: field,
	    attribute: 'placeholder',
	    value: placeholder
	  });
	};
	
	/**
	 * Clear the value of a {@link module:braintree-web/hosted-fields~field field}.
	 * @public
	 * @param {string} field The field you wish to clear. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the field cleared successfully.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * hostedFieldsInstance.clear('number', function (clearErr) {
	 *   if (clearErr) {
	 *     console.error(clearErr);
	 *   }
	 * });
	 *
	 * @example <caption>Clear several fields</caption>
	 * hostedFieldsInstance.clear('number');
	 * hostedFieldsInstance.clear('cvv');
	 * hostedFieldsInstance.clear('expirationDate');
	 */
	HostedFields.prototype.clear = function (field) {
	  var err;
	
	  if (!whitelistedFields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + field + '" is not a valid field. You must use a valid field option when clearing a field.'
	    });
	  } else if (!this._fields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot clear "' + field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    this._bus.emit(events.CLEAR_FIELD, field);
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * Programmatically focus a {@link module:braintree-web/hosted-fields~field field}.
	 * @public
	 * @param {string} field The field you want to focus. Must be a valid {@link module:braintree-web/hosted-fields~fieldOptions fieldOption}.
	 * @param {callback} [callback] Callback executed on completion, containing an error if one occurred. No data is returned if the field focused successfully.
	 * @returns {void}
	 * @example
	 * hostedFieldsInstance.focus('number', function (focusErr) {
	 *   if (focusErr) {
	 *     console.error(focusErr);
	 *   }
	 * });
	 * @example <caption>Using an event listener</caption>
	 * myElement.addEventListener('click', function (e) {
	 *   // Note: In Firefox, the focus method can be suppressed
	 *   // if the element has a tabindex property or the element
	 *   // is an anchor link with an href property.
	 *   e.preventDefault();
	 *   hostedFieldsInstance.focus('number');
	 * });
	 */
	HostedFields.prototype.focus = function (field) {
	  var err;
	
	  if (!whitelistedFields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_INVALID.type,
	      code: errors.HOSTED_FIELDS_FIELD_INVALID.code,
	      message: '"' + field + '" is not a valid field. You must use a valid field option when focusing a field.'
	    });
	  } else if (!this._fields.hasOwnProperty(field)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.type,
	      code: errors.HOSTED_FIELDS_FIELD_NOT_PRESENT.code,
	      message: 'Cannot focus "' + field + '" field because it is not part of the current Hosted Fields options.'
	    });
	  } else {
	    this._bus.emit(events.TRIGGER_INPUT_FOCUS, field);
	  }
	
	  if (err) {
	    return Promise.reject(err);
	  }
	
	  return Promise.resolve();
	};
	
	/**
	 * Returns an {@link HostedFields~stateObject|object} that includes the state of all fields and possible card types.
	 * @public
	 * @returns {object} {@link HostedFields~stateObject|stateObject}
	 * @example <caption>Check if all fields are valid</caption>
	 * var state = hostedFields.getState();
	 *
	 * var formValid = Object.keys(state.fields).every(function (key) {
	 *   return state.fields[key].isValid;
	 * });
	 */
	HostedFields.prototype.getState = function () {
	  return this._state;
	};
	
	module.exports = wrapPromise.wrapPrototype(HostedFields);


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var batchExecuteFunctions = __webpack_require__(448);
	
	function Destructor() {
	  this._teardownRegistry = [];
	
	  this._isTearingDown = false;
	}
	
	Destructor.prototype.registerFunctionForTeardown = function (fn) {
	  if (typeof fn === 'function') {
	    this._teardownRegistry.push(fn);
	  }
	};
	
	Destructor.prototype.teardown = function (callback) {
	  if (this._isTearingDown) {
	    callback(new Error('Destructor is already tearing down'));
	    return;
	  }
	
	  this._isTearingDown = true;
	
	  batchExecuteFunctions(this._teardownRegistry, function (err) {
	    this._teardownRegistry = [];
	    this._isTearingDown = false;
	
	    if (typeof callback === 'function') {
	      callback(err);
	    }
	  }.bind(this));
	};
	
	module.exports = Destructor;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var once = __webpack_require__(382);
	
	function call(fn, callback) {
	  var isSync = fn.length === 0;
	
	  if (isSync) {
	    fn();
	    callback(null);
	  } else {
	    fn(callback);
	  }
	}
	
	module.exports = function (functions, cb) {
	  var i;
	  var length = functions.length;
	  var remaining = length;
	  var callback = once(cb);
	
	  if (length === 0) {
	    callback(null);
	    return;
	  }
	
	  function finish(err) {
	    if (err) {
	      callback(err);
	      return;
	    }
	
	    remaining -= 1;
	    if (remaining === 0) {
	      callback(null);
	    }
	  }
	
	  for (i = 0; i < length; i++) {
	    call(functions[i], finish);
	  }
	};


/***/ },
/* 449 */
/***/ function(module, exports) {

	'use strict';
	
	function _classesOf(element) {
	  return element.className.trim().split(/\s+/);
	}
	
	function add(element) {
	  var toAdd = Array.prototype.slice.call(arguments, 1);
	  var className = _classesOf(element).filter(function (classname) {
	    return toAdd.indexOf(classname) === -1;
	  }).concat(toAdd).join(' ');
	
	  element.className = className;
	}
	
	function remove(element) {
	  var toRemove = Array.prototype.slice.call(arguments, 1);
	  var className = _classesOf(element).filter(function (classname) {
	    return toRemove.indexOf(classname) === -1;
	  }).join(' ');
	
	  element.className = className;
	}
	
	function toggle(element, classname, adding) {
	  if (adding) {
	    add(element, classname);
	  } else {
	    remove(element, classname);
	  }
	}
	
	module.exports = {
	  add: add,
	  remove: remove,
	  toggle: toggle
	};


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var constants = __webpack_require__(451);
	var useMin = __webpack_require__(438);
	
	module.exports = function composeUrl(assetsUrl, componentId, isDebug) {
	  return assetsUrl +
	    '/web/' +
	    constants.VERSION +
	    '/html/hosted-fields-frame' + useMin(isDebug) + '.html#' +
	    componentId;
	};


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/* eslint-disable no-reserved-keys */
	
	var enumerate = __webpack_require__(379);
	var errors = __webpack_require__(452);
	var VERSION = "3.14.0";
	
	var constants = {
	  VERSION: VERSION,
	  maxExpirationYearAge: 19,
	  externalEvents: {
	    FOCUS: 'focus',
	    BLUR: 'blur',
	    EMPTY: 'empty',
	    NOT_EMPTY: 'notEmpty',
	    VALIDITY_CHANGE: 'validityChange',
	    CARD_TYPE_CHANGE: 'cardTypeChange'
	  },
	  defaultMaxLengths: {
	    number: 19,
	    postalCode: 8,
	    expirationDate: 7,
	    expirationMonth: 2,
	    expirationYear: 4,
	    cvv: 3
	  },
	  externalClasses: {
	    FOCUSED: 'braintree-hosted-fields-focused',
	    INVALID: 'braintree-hosted-fields-invalid',
	    VALID: 'braintree-hosted-fields-valid'
	  },
	  defaultIFrameStyle: {
	    border: 'none',
	    width: '100%',
	    height: '100%',
	    'float': 'left'
	  },
	  tokenizationErrorCodes: {
	    81724: errors.HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE,
	    81736: errors.HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED
	  },
	  whitelistedStyles: [
	    '-moz-appearance',
	    '-moz-osx-font-smoothing',
	    '-moz-tap-highlight-color',
	    '-moz-transition',
	    '-webkit-appearance',
	    '-webkit-font-smoothing',
	    '-webkit-tap-highlight-color',
	    '-webkit-transition',
	    'appearance',
	    'color',
	    'direction',
	    'font',
	    'font-family',
	    'font-size',
	    'font-size-adjust',
	    'font-stretch',
	    'font-style',
	    'font-variant',
	    'font-variant-alternates',
	    'font-variant-caps',
	    'font-variant-east-asian',
	    'font-variant-ligatures',
	    'font-variant-numeric',
	    'font-weight',
	    'letter-spacing',
	    'line-height',
	    'opacity',
	    'outline',
	    'text-shadow',
	    'transition'
	  ],
	  whitelistedFields: {
	    number: {
	      name: 'credit-card-number',
	      label: 'Credit Card Number'
	    },
	    cvv: {
	      name: 'cvv',
	      label: 'CVV'
	    },
	    expirationDate: {
	      name: 'expiration',
	      label: 'Expiration Date'
	    },
	    expirationMonth: {
	      name: 'expiration-month',
	      label: 'Expiration Month'
	    },
	    expirationYear: {
	      name: 'expiration-year',
	      label: 'Expiration Year'
	    },
	    postalCode: {
	      name: 'postal-code',
	      label: 'Postal Code'
	    }
	  },
	  whitelistedAttributes: {
	    'aria-invalid': 'boolean',
	    'aria-required': 'boolean',
	    disabled: 'boolean',
	    placeholder: 'string'
	  }
	};
	
	constants.events = enumerate([
	  'FRAME_READY',
	  'VALIDATE_STRICT',
	  'CONFIGURATION',
	  'TOKENIZATION_REQUEST',
	  'INPUT_EVENT',
	  'TRIGGER_INPUT_FOCUS',
	  'ADD_CLASS',
	  'REMOVE_CLASS',
	  'SET_ATTRIBUTE',
	  'REMOVE_ATTRIBUTE',
	  'CLEAR_FIELD'
	], 'hosted-fields:');
	
	module.exports = constants;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  HOSTED_FIELDS_INVALID_FIELD_KEY: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_INVALID_FIELD_KEY'
	  },
	  HOSTED_FIELDS_INVALID_FIELD_SELECTOR: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_INVALID_FIELD_SELECTOR',
	    message: 'Selector does not reference a valid DOM node.'
	  },
	  HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_FIELD_DUPLICATE_IFRAME',
	    message: 'Element already contains a Braintree iframe.'
	  },
	  HOSTED_FIELDS_FIELD_INVALID: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_FIELD_INVALID'
	  },
	  HOSTED_FIELDS_FIELD_NOT_PRESENT: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_FIELD_NOT_PRESENT'
	  },
	  HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'HOSTED_FIELDS_TOKENIZATION_NETWORK_ERROR',
	    message: 'A tokenization network error occurred.'
	  },
	  HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'HOSTED_FIELDS_TOKENIZATION_FAIL_ON_DUPLICATE',
	    message: 'This credit card already exists in the merchant\'s vault.'
	  },
	  HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'HOSTED_FIELDS_TOKENIZATION_CVV_VERIFICATION_FAILED',
	    message: 'CVV verification failed during tokenization.'
	  },
	  HOSTED_FIELDS_FAILED_TOKENIZATION: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'HOSTED_FIELDS_FAILED_TOKENIZATION',
	    message: 'The supplied card data failed tokenization.'
	  },
	  HOSTED_FIELDS_FIELDS_EMPTY: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'HOSTED_FIELDS_FIELDS_EMPTY',
	    message: 'All fields are empty. Cannot tokenize empty card fields.'
	  },
	  HOSTED_FIELDS_FIELDS_INVALID: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'HOSTED_FIELDS_FIELDS_INVALID',
	    message: 'Some payment input fields are invalid. Cannot tokenize invalid card fields.'
	  },
	  HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED'
	  },
	  HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED'
	  },
	  HOSTED_FIELDS_FIELD_PROPERTY_INVALID: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'HOSTED_FIELDS_FIELD_PROPERTY_INVALID'
	  }
	};


/***/ },
/* 453 */
/***/ function(module, exports) {

	'use strict';
	
	function findParentTags(element, tag) {
	  var parent = element.parentNode;
	  var parents = [];
	
	  while (parent != null) {
	    if (parent.tagName != null && parent.tagName.toLowerCase() === tag) {
	      parents.push(parent);
	    }
	
	    parent = parent.parentNode;
	  }
	
	  return parents;
	}
	
	module.exports = findParentTags;


/***/ },
/* 454 */
/***/ function(module, exports) {

	'use strict';
	
	function EventEmitter() {
	  this._events = {};
	}
	
	EventEmitter.prototype.on = function (event, callback) {
	  if (this._events[event]) {
	    this._events[event].push(callback);
	  } else {
	    this._events[event] = [callback];
	  }
	};
	
	EventEmitter.prototype._emit = function (event) {
	  var i, args;
	  var callbacks = this._events[event];
	
	  if (!callbacks) { return; }
	
	  args = Array.prototype.slice.call(arguments, 1);
	
	  for (i = 0; i < callbacks.length; i++) {
	    callbacks[i].apply(null, args);
	  }
	};
	
	module.exports = EventEmitter;


/***/ },
/* 455 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function injectFrame(frame, container) {
	  var clearboth = document.createElement('div');
	  var fragment = document.createDocumentFragment();
	
	  clearboth.style.clear = 'both';
	
	  fragment.appendChild(frame);
	  fragment.appendChild(clearboth);
	
	  container.appendChild(fragment);
	
	  return [frame, clearboth];
	};


/***/ },
/* 456 */
/***/ function(module, exports) {

	'use strict';
	
	var types = {};
	var VISA = 'visa';
	var MASTERCARD = 'master-card';
	var AMERICAN_EXPRESS = 'american-express';
	var DINERS_CLUB = 'diners-club';
	var DISCOVER = 'discover';
	var JCB = 'jcb';
	var UNIONPAY = 'unionpay';
	var MAESTRO = 'maestro';
	var CVV = 'CVV';
	var CID = 'CID';
	var CVC = 'CVC';
	var CVN = 'CVN';
	var testOrder = [
	  VISA,
	  MASTERCARD,
	  AMERICAN_EXPRESS,
	  DINERS_CLUB,
	  DISCOVER,
	  JCB,
	  UNIONPAY,
	  MAESTRO
	];
	
	function clone(x) {
	  var prefixPattern, exactPattern, dupe;
	
	  if (!x) { return null; }
	
	  prefixPattern = x.prefixPattern.source;
	  exactPattern = x.exactPattern.source;
	  dupe = JSON.parse(JSON.stringify(x));
	  dupe.prefixPattern = prefixPattern;
	  dupe.exactPattern = exactPattern;
	
	  return dupe;
	}
	
	types[VISA] = {
	  niceType: 'Visa',
	  type: VISA,
	  prefixPattern: /^4$/,
	  exactPattern: /^4\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [16, 18, 19],
	  code: {
	    name: CVV,
	    size: 3
	  }
	};
	
	types[MASTERCARD] = {
	  niceType: 'MasterCard',
	  type: MASTERCARD,
	  prefixPattern: /^(5|5[1-5]|2|22|222|222[1-9]|2[3-6]|27[0-1]|2720)$/,
	  exactPattern: /^(5[1-5]|222[1-9]|2[3-6]|27[0-1]|2720)\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [16],
	  code: {
	    name: CVC,
	    size: 3
	  }
	};
	
	types[AMERICAN_EXPRESS] = {
	  niceType: 'American Express',
	  type: AMERICAN_EXPRESS,
	  prefixPattern: /^(3|34|37)$/,
	  exactPattern: /^3[47]\d*$/,
	  isAmex: true,
	  gaps: [4, 10],
	  lengths: [15],
	  code: {
	    name: CID,
	    size: 4
	  }
	};
	
	types[DINERS_CLUB] = {
	  niceType: 'Diners Club',
	  type: DINERS_CLUB,
	  prefixPattern: /^(3|3[0689]|30[0-5])$/,
	  exactPattern: /^3(0[0-5]|[689])\d*$/,
	  gaps: [4, 10],
	  lengths: [14],
	  code: {
	    name: CVV,
	    size: 3
	  }
	};
	
	types[DISCOVER] = {
	  niceType: 'Discover',
	  type: DISCOVER,
	  prefixPattern: /^(6|60|601|6011|65|64|64[4-9])$/,
	  exactPattern: /^(6011|65|64[4-9])\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [16, 19],
	  code: {
	    name: CID,
	    size: 3
	  }
	};
	
	types[JCB] = {
	  niceType: 'JCB',
	  type: JCB,
	  prefixPattern: /^(2|21|213|2131|1|18|180|1800|3|35)$/,
	  exactPattern: /^(2131|1800|35)\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [16],
	  code: {
	    name: CVV,
	    size: 3
	  }
	};
	
	types[UNIONPAY] = {
	  niceType: 'UnionPay',
	  type: UNIONPAY,
	  prefixPattern: /^(6|62)$/,
	  exactPattern: /^62\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [16, 17, 18, 19],
	  code: {
	    name: CVN,
	    size: 3
	  }
	};
	
	types[MAESTRO] = {
	  niceType: 'Maestro',
	  type: MAESTRO,
	  prefixPattern: /^(5|5[06-9]|6\d*)$/,
	  exactPattern: /^5[06-9]\d*$/,
	  gaps: [4, 8, 12],
	  lengths: [12, 13, 14, 15, 16, 17, 18, 19],
	  code: {
	    name: CVC,
	    size: 3
	  }
	};
	
	function creditCardType(cardNumber) {
	  var type, value, i;
	  var prefixResults = [];
	  var exactResults = [];
	
	  if (!(typeof cardNumber === 'string' || cardNumber instanceof String)) {
	    return [];
	  }
	
	  for (i = 0; i < testOrder.length; i++) {
	    type = testOrder[i];
	    value = types[type];
	
	    if (cardNumber.length === 0) {
	      prefixResults.push(clone(value));
	      continue;
	    }
	
	    if (value.exactPattern.test(cardNumber)) {
	      exactResults.push(clone(value));
	    } else if (value.prefixPattern.test(cardNumber)) {
	      prefixResults.push(clone(value));
	    }
	  }
	
	  return exactResults.length ? exactResults : prefixResults;
	}
	
	creditCardType.getTypeInfo = function (type) {
	  return clone(types[type]);
	};
	
	creditCardType.types = {
	  VISA: VISA,
	  MASTERCARD: MASTERCARD,
	  AMERICAN_EXPRESS: AMERICAN_EXPRESS,
	  DINERS_CLUB: DINERS_CLUB,
	  DISCOVER: DISCOVER,
	  JCB: JCB,
	  UNIONPAY: UNIONPAY,
	  MAESTRO: MAESTRO
	};
	
	module.exports = creditCardType;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(452);
	var whitelist = __webpack_require__(451).whitelistedAttributes;
	
	function attributeValidationError(attribute, value) {
	  var err;
	
	  if (!whitelist.hasOwnProperty(attribute)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.type,
	      code: errors.HOSTED_FIELDS_ATTRIBUTE_NOT_SUPPORTED.code,
	      message: 'The "' + attribute + '" attribute is not supported in Hosted Fields.'
	    });
	  } else if (value != null && !_isValid(attribute, value)) {
	    err = new BraintreeError({
	      type: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.type,
	      code: errors.HOSTED_FIELDS_ATTRIBUTE_VALUE_NOT_ALLOWED.code,
	      message: 'Value "' + value + '" is not allowed for "' + attribute + '" attribute.'
	    });
	  }
	
	  return err;
	}
	
	function _isValid(attribute, value) {
	  if (whitelist[attribute] === 'string') {
	    return typeof value === 'string' || typeof value === 'number';
	  } else if (whitelist[attribute] === 'boolean') {
	    return String(value) === 'true' || String(value) === 'false';
	  }
	
	  return false;
	}
	
	module.exports = attributeValidationError;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/** @module braintree-web/data-collector */
	
	var kount = __webpack_require__(459);
	var fraudnet = __webpack_require__(518);
	var BraintreeError = __webpack_require__(378);
	var methods = __webpack_require__(440);
	var convertMethodsToError = __webpack_require__(441);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var sharedErrors = __webpack_require__(404);
	var errors = __webpack_require__(519);
	
	/**
	 * @class
	 * @global
	 * @name DataCollector
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/data-collector.create|braintree-web.data-collector.create} instead.</strong>
	 * @classdesc This class is used for advanced fraud integration with PayPal and Kount. Instances of this class have {@link DataCollector#deviceData|deviceData} which is used to correlate user sessions with server transactions. Before using DataCollector, make sure you have enabled advanced fraud protection in the Braintree gateway. To use your own Kount ID, contact our support team ([support@braintreepayments.com](mailto:support@braintreepayments.com) or [877.434.2894](tel:877.434.2894)).
	 */
	
	/**
	 * @memberof DataCollector
	 * @name deviceData
	 * @type string
	 * @description JSON string to pass with server transactions.
	 * @instance
	 */
	
	/**
	 * @memberof DataCollector
	 * @name teardown
	 * @function
	 * @description Cleanly remove anything set up by {@link module:braintree-web/data-collector.create|create}.
	 * @param {callback} [callback] Called on completion. If no callback is provided, `teardown` returns a promise.
	 * @instance
	 * @example
	 * dataCollectorInstance.teardown();
	 * @example <caption>With callback</caption>
	 * dataCollectorInstance.teardown(function () {
	 *   // teardown is complete
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	
	/**
	 * @static
	 * @function create
	 * @description Creates a DataCollector instance. Requires advanced fraud protection to be enabled in the Braintree gateway. Contact our [support team](mailto:support@braintreepayments.com) to configure your Kount ID.
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {boolean} [options.kount] If true, Kount fraud data collection is enabled.
	 * @param {boolean} [options.paypal] If true, PayPal fraud data collection is enabled.
	 * @param {callback} [callback] The second argument, `data`, is the {@link DataCollector} instance.
	 * @example
	 * var createClient = require('braintree-web/client').create;
	 * var createDataCollector = require('braintree-web/data-collector').create;
	 *
	 * createClient({
	 *   authorization: CLIENT_AUTHORIZATION
	 * }, function (clientErr, clientInstance) {
	 *   if (err) {
	 *     // handle client error
	 *     return;
	 *   }
	 *   createDataCollector({
	 *     client: clientInstance,
	 *     kount: true
	 *   }, function (dataCollectorErr, dataCollectorInstance) {
	 *     if (dataCollectorErr) {
	 *       // handle data collector error
	 *       return;
	 *     }
	 *     // data collector is set up
	 *   });
	 * });
	 *
	 * @returns {Promise|void} Returns a promise that resolves the {@link DataCollector} instance if no callback is provided.
	 */
	function create(options) {
	  var data, kountInstance, fraudnetInstance, config, clientVersion;
	  var result = {};
	  var instances = [];
	  var teardown = createTeardownMethod(result, instances);
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Data Collector.'
	    }));
	  }
	
	  config = options.client.getConfiguration();
	  clientVersion = config.analyticsMetadata.sdkVersion;
	
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Data Collector (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (options.kount === true) {
	    if (!config.gatewayConfiguration.kount) {
	      return Promise.reject(new BraintreeError(errors.DATA_COLLECTOR_KOUNT_NOT_ENABLED));
	    }
	
	    try {
	      kountInstance = kount.setup({
	        environment: config.gatewayConfiguration.environment,
	        merchantId: config.gatewayConfiguration.kount.kountMerchantId
	      });
	    } catch (err) {
	      return Promise.reject(new BraintreeError({
	        type: errors.DATA_COLLECTOR_KOUNT_ERROR.type,
	        code: errors.DATA_COLLECTOR_KOUNT_ERROR.code,
	        message: err.message
	      }));
	    }
	
	    data = kountInstance.deviceData;
	    instances.push(kountInstance);
	  } else {
	    data = {};
	  }
	
	  if (options.paypal === true) {
	    fraudnetInstance = fraudnet.setup();
	    data.correlation_id = fraudnetInstance.sessionId; // eslint-disable-line camelcase
	    instances.push(fraudnetInstance);
	  }
	
	  if (instances.length === 0) {
	    return Promise.reject(new BraintreeError(errors.DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS));
	  }
	
	  result.deviceData = JSON.stringify(data);
	  result.teardown = teardown;
	
	  return Promise.resolve(result);
	}
	
	function createTeardownMethod(result, instances) {
	  return wrapPromise(function teardown() {
	    return new Promise(function (resolve) {
	      var i;
	
	      for (i = 0; i < instances.length; i++) {
	        instances[i].teardown();
	      }
	
	      convertMethodsToError(result, methods(result));
	
	      resolve();
	    });
	  });
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var sjcl = __webpack_require__(460);
	var camelCaseToSnakeCase = __webpack_require__(517);
	
	var QA_URL = 'https://assets.qa.braintreepayments.com/data';
	var IFRAME_ID = 'braintreeDataFrame';
	var environmentUrls = {
	  development: QA_URL,
	  qa: QA_URL,
	  sandbox: 'https://assets.braintreegateway.com/sandbox/data',
	  production: 'https://assets.braintreegateway.com/data'
	};
	
	function setup(o) {
	  var options = o != null ? o : {};
	
	  return new Kount(options);
	}
	
	function Kount(options) {
	  sjcl.random.startCollectors();
	
	  this._currentEnvironment = this._initializeEnvironment(options);
	  this._deviceSessionId = this._generateDeviceSessionId();
	  this.deviceData = this._getDeviceData();
	
	  this._iframe = this._setupIFrame();
	}
	
	Kount.prototype.teardown = function () {
	  sjcl.random.stopCollectors();
	  this._removeIframe();
	};
	
	Kount.prototype._removeIframe = function () {
	  this._iframe.parentNode.removeChild(this._iframe);
	};
	
	Kount.prototype._getDeviceData = function () {
	  return camelCaseToSnakeCase({
	    deviceSessionId: this._deviceSessionId,
	    fraudMerchantId: this._currentEnvironment.id
	  });
	};
	
	Kount.prototype._generateDeviceSessionId = function () {
	  var bits, hexString;
	
	  bits = sjcl.random.randomWords(4, 0);
	  hexString = sjcl.codec.hex.fromBits(bits);
	
	  return hexString;
	};
	
	Kount.prototype._setupIFrame = function () {
	  var params;
	  var self = this;
	  var iframe = document.getElementById(IFRAME_ID);
	
	  if (iframe != null) {
	    return iframe;
	  }
	
	  params = '?m=' + this._currentEnvironment.id + '&s=' + this._deviceSessionId;
	
	  iframe = document.createElement('iframe');
	  iframe.width = 1;
	  iframe.id = IFRAME_ID;
	  iframe.height = 1;
	  iframe.frameBorder = 0;
	  iframe.scrolling = 'no';
	
	  document.body.appendChild(iframe);
	  setTimeout(function () {
	    iframe.src = self._currentEnvironment.url + '/logo.htm' + params;
	    iframe.innerHTML = '<img src="' + self._currentEnvironment.url + '/logo.gif' + params + '" />';
	  }, 10);
	
	  return iframe;
	};
	
	Kount.prototype._initializeEnvironment = function (options) {
	  var url = environmentUrls[options.environment];
	
	  if (url == null) {
	    throw new Error(options.environment + ' is not a valid environment for kount.environment');
	  }
	
	  return {
	    url: url,
	    name: options.environment,
	    id: options.merchantId
	  };
	};
	
	module.exports = {
	  setup: setup,
	  Kount: Kount,
	  environmentUrls: environmentUrls
	};


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;"use strict";var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};
	sjcl.cipher.aes=function(a){this.l[0][0][0]||this.G();var b,c,d,e,f=this.l[0][4],g=this.l[1];b=a.length;var k=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid("invalid aes key size");this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^k<<24,k=k<<1^283*(k>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&
	255]]};
	sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},l:[[[],[],[],[],[]],[[],[],[],[],[]]],G:function(){var a=this.l[0],b=this.l[1],c=a[4],d=b[4],e,f,g,k=[],l=[],p,n,h,m;for(e=0;0x100>e;e++)l[(k[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=p||1,g=l[g]||1)for(h=g^g<<1^g<<2^g<<3^g<<4,h=h>>8^h&255^99,c[f]=h,d[h]=f,n=k[e=k[p=k[f]]],m=0x1010101*n^0x10001*e^0x101*p^0x1010100*f,n=0x101*k[h]^0x1010100*h,e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][h]=m=m<<24^m>>>8;for(e=
	0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};
	function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid("invalid aes block size");var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var k,l,p,n=d.length/4-2,h,m=4,q=[0,0,0,0];k=a.l[c];a=k[0];var r=k[1],v=k[2],w=k[3],x=k[4];for(h=0;h<n;h++)k=a[e>>>24]^r[f>>16&255]^v[g>>8&255]^w[b&255]^d[m],l=a[f>>>24]^r[g>>16&255]^v[b>>8&255]^w[e&255]^d[m+1],p=a[g>>>24]^r[b>>16&255]^v[e>>8&255]^w[f&255]^d[m+2],b=a[b>>>24]^r[e>>16&255]^v[f>>8&255]^w[g&255]^d[m+3],m+=4,e=k,f=l,g=p;for(h=
	0;4>h;h++)q[c?3&-h:h]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[m++],k=e,e=f,f=g,g=b,b=k;return q}
	sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.M(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.M(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===
	b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b=b&31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+0x10000000000*a},getPartial:function(a){return Math.round(a/0x10000000000)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return!1;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===
	c},M:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},Y:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]},byteswapM:function(a){var b,c;for(b=0;b<a.length;++b)c=a[b],a[b]=c>>>24|c>>>8&0xff00|(c&0xff00)<<8|c<<24;return a}};
	sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>24),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};
	sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a=a+"00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};sjcl.hash.sha256=function(a){this.b[0]||this.G();a?(this.u=a.u.slice(0),this.o=a.o.slice(0),this.h=a.h):this.reset()};sjcl.hash.sha256.hash=function(a){return(new sjcl.hash.sha256).update(a).finalize()};
	sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.u=this.K.slice(0);this.o=[];this.h=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.o=sjcl.bitArray.concat(this.o,a);b=this.h;a=this.h=b+sjcl.bitArray.bitLength(a);if(0x1fffffffffffff<a)throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");if("undefined"!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,d.subarray(16*e,
	16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&0x1ff);b<=a;b+=512)u(this,c.splice(0,16));return this},finalize:function(){var a,b=this.o,c=this.u,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.h/0x100000000));for(b.push(this.h|0);b.length;)u(this,b.splice(0,16));this.reset();return c},K:[],b:[],G:function(){function a(a){return 0x100000000*(a-Math.floor(a))|0}for(var b=0,c=2,d,e;64>b;c++){e=!0;for(d=2;d*d<=c;d++)if(0===c%d){e=
	!1;break}e&&(8>b&&(this.K[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};
	function u(a,b){var c,d,e,f=a.u,g=a.b,k=f[0],l=f[1],p=f[2],n=f[3],h=f[4],m=f[5],q=f[6],r=f[7];for(c=0;64>c;c++)16>c?d=b[c]:(d=b[c+1&15],e=b[c+14&15],d=b[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+b[c&15]+b[c+9&15]|0),d=d+r+(h>>>6^h>>>11^h>>>25^h<<26^h<<21^h<<7)+(q^h&(m^q))+g[c],r=q,q=m,m=h,h=n+d|0,n=p,p=l,l=k,k=d+(l&p^n&(l^p))+(l>>>2^l>>>13^l>>>22^l<<30^l<<19^l<<10)|0;f[0]=f[0]+k|0;f[1]=f[1]+l|0;f[2]=f[2]+p|0;f[3]=f[3]+n|0;f[4]=f[4]+h|0;f[5]=f[5]+m|0;f[6]=f[6]+q|0;f[7]=
	f[7]+r|0}sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.i=[0];this.H=0;this.v={};this.F=0;this.J={};this.L=this.f=this.j=this.T=0;this.b=[0,0,0,0,0,0,0,0];this.g=[0,0,0,0];this.C=void 0;this.D=a;this.s=!1;this.B={progress:{},seeded:{}};this.m=this.S=0;this.w=1;this.A=2;this.O=0x10000;this.I=[0,48,64,96,128,192,0x100,384,512,768,1024];this.P=3E4;this.N=80};
	sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.m)throw new sjcl.exception.notReady("generator isn't seeded");if(d&this.A){d=!(d&this.w);e=[];var f=0,g;this.L=e[0]=(new Date).valueOf()+this.P;for(g=0;16>g;g++)e.push(0x100000000*Math.random()|0);for(g=0;g<this.c.length&&(e=e.concat(this.c[g].finalize()),f+=this.i[g],this.i[g]=0,d||!(this.H&1<<g));g++);this.H>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.i.push(0));this.f-=f;f>this.j&&(this.j=
	f);this.H++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.C=new sjcl.cipher.aes(this.b);for(d=0;4>d&&(this.g[d]=this.g[d]+1|0,!this.g[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.O&&y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b)throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");this.D=a},addEntropy:function(a,
	b,c){c=c||"user";var d,e,f=(new Date).valueOf(),g=this.v[c],k=this.isReady(),l=0;d=this.J[c];void 0===d&&(d=this.J[c]=this.T++);void 0===g&&(g=this.v[c]=0);this.v[c]=(this.v[c]+1)%this.c.length;switch(typeof a){case "number":void 0===b&&(b=1);this.c[g].update([d,this.F++,1,b,f,1,a|0]);break;case "object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else for("[object Array]"!==c&&(l=1),c=0;c<a.length&&!l;c++)"number"!==typeof a[c]&&
	(l=1);if(!l){if(void 0===b)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,e=e>>>1;this.c[g].update([d,this.F++,2,b,f,a.length].concat(a))}break;case "string":void 0===b&&(b=a.length);this.c[g].update([d,this.F++,3,b,f,a.length]);this.c[g].update(a);break;default:l=1}if(l)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.i[g]+=b;this.f+=b;k===this.m&&(this.isReady()!==this.m&&A("seeded",Math.max(this.j,this.f)),A("progress",this.getProgress()))},
	isReady:function(a){a=this.I[void 0!==a?a:this.D];return this.j&&this.j>=a?this.i[0]>this.N&&(new Date).valueOf()>this.L?this.A|this.w:this.w:this.f>=a?this.A|this.m:this.m},getProgress:function(a){a=this.I[a?a:this.D];return this.j>=a?1:this.f>a?1:this.f/a},startCollectors:function(){if(!this.s){this.a={loadTimeCollector:B(this,this.V),mouseCollector:B(this,this.W),keyboardCollector:B(this,this.U),accelerometerCollector:B(this,this.R),touchCollector:B(this,this.X)};if(window.addEventListener)window.addEventListener("load",
	this.a.loadTimeCollector,!1),window.addEventListener("mousemove",this.a.mouseCollector,!1),window.addEventListener("keypress",this.a.keyboardCollector,!1),window.addEventListener("devicemotion",this.a.accelerometerCollector,!1),window.addEventListener("touchmove",this.a.touchCollector,!1);else if(document.attachEvent)document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector);else throw new sjcl.exception.bug("can't attach event");
	this.s=!0}},stopCollectors:function(){this.s&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,!1),window.removeEventListener("mousemove",this.a.mouseCollector,!1),window.removeEventListener("keypress",this.a.keyboardCollector,!1),window.removeEventListener("devicemotion",this.a.accelerometerCollector,!1),window.removeEventListener("touchmove",this.a.touchCollector,!1)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",
	this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.s=!1)},addEventListener:function(a,b){this.B[a][this.S++]=b},removeEventListener:function(a,b){var c,d,e=this.B[a],f=[];for(d in e)e.hasOwnProperty(d)&&e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},U:function(){C(this,1)},W:function(a){var b,c;try{b=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&&0!=c&&this.addEntropy([b,c],2,"mouse");C(this,0)},X:function(a){a=
	a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,"touch");C(this,0)},V:function(){C(this,2)},R:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&this.addEntropy(b,1,"accelerometer")}a&&this.addEntropy(a,2,"accelerometer");C(this,0)}};
	function A(a,b){var c,d=sjcl.random.B[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function C(a,b){"undefined"!==typeof window&&window.performance&&"function"===typeof window.performance.now?a.addEntropy(window.performance.now(),b,"loadtime"):a.addEntropy((new Date).valueOf(),b,"loadtime")}function y(a){a.b=z(a).concat(z(a));a.C=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4>b&&(a.g[b]=a.g[b]+1|0,!a.g[b]);b++);return a.C.encrypt(a.g)}
	function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);
	a:try{var D,E,F,G;if(G="undefined"!==typeof module&&module.exports){var H;try{H=__webpack_require__(461)}catch(a){H=null}G=E=H}if(G&&E.randomBytes)D=E.randomBytes(128),D=new Uint32Array((new Uint8Array(D)).buffer),sjcl.random.addEntropy(D,1024,"crypto['randomBytes']");else if("undefined"!==typeof window&&"undefined"!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(F);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);
	else break a;sjcl.random.addEntropy(F,1024,"crypto['getRandomValues']")}}catch(a){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(a))}"undefined"!==typeof module&&module.exports&&(module.exports=sjcl);"function"==="function"&&!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){return sjcl}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(466)
	
	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}
	
	exports.createHash = __webpack_require__(468)
	
	exports.createHmac = __webpack_require__(480)
	
	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}
	
	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}
	
	var p = __webpack_require__(481)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync
	__webpack_require__(483)(exports, module.exports);
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(463)
	var ieee754 = __webpack_require__(464)
	var isArray = __webpack_require__(465)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 463 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}


/***/ },
/* 464 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 465 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(467)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(462).Buffer))

/***/ },
/* 467 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(469)
	
	var md5 = toConstructor(__webpack_require__(477))
	var rmd160 = toConstructor(__webpack_require__(479))
	
	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}
	
	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}
	
	var Buffer = __webpack_require__(462).Buffer
	var Hash   = __webpack_require__(470)(Buffer)
	
	exports.sha1 = __webpack_require__(471)(Buffer, Hash)
	exports.sha256 = __webpack_require__(475)(Buffer, Hash)
	exports.sha512 = __webpack_require__(476)(Buffer, Hash)


/***/ },
/* 470 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }
	
	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)
	
	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }
	
	      s += ch
	      f += ch
	
	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s
	
	    return this
	  }
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)
	
	    var hash = this._update(this._block) || this._hash()
	
	    return enc ? hash.toString(enc) : hash
	  }
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }
	
	  return Hash
	}


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(472).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)
	
	  var POOL = []
	
	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()
	
	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)
	
	    this._h = null
	    this.init()
	  }
	
	  inherits(Sha1, Hash)
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0
	
	    Hash.prototype.init.call(this)
	    return this
	  }
	
	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e
	
	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e
	
	    var w = this._w
	
	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)
	
	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )
	
	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }
	
	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }
	
	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }
	
	  return Sha1
	}


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(473);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(474);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(311)))

/***/ },
/* 473 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 474 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(472).inherits
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]
	
	  var W = new Array(64)
	
	  function Sha256() {
	    this.init()
	
	    this._w = W //new Array(64)
	
	    Hash.call(this, 16*4, 14*4)
	  }
	
	  inherits(Sha256, Hash)
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }
	
	  function R (X, n) {
	    return (X >>> n);
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }
	
	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }
	
	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }
	
	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }
	
	  Sha256.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }
	
	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0
	
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)
	
	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)
	
	    return H
	  }
	
	  return Sha256
	
	}


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(472).inherits
	
	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]
	
	  var W = new Array(160)
	
	  function Sha512() {
	    this.init()
	    this._w = W
	
	    Hash.call(this, 128, 112)
	  }
	
	  inherits(Sha512, Hash)
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0
	
	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0
	
	    this._len = this._s = 0
	
	    return this
	  }
	
	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }
	
	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }
	
	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }
	
	  Sha512.prototype._update = function(M) {
	
	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl
	
	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0
	
	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2
	
	      var Wi, Wil
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)
	
	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)
	
	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]
	
	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]
	
	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
	
	        W[j] = Wi
	        W[j + 1] = Wil
	      }
	
	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]
	
	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)
	
	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)
	
	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }
	
	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0
	
	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }
	
	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)
	
	    return H
	  }
	
	  return Sha512
	
	}


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(478);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;
	
	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;
	
	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);
	
	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160
	
	
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];
	
	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};
	
	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function (H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};
	
	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}
	
	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}
	
	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}
	
	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}
	
	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}
	
	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );
	
	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(468)
	
	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)
	
	module.exports = Hmac
	
	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg
	
	  var blocksize = (alg === 'sha512') ? 128 : 64
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key
	
	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)
	
	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }
	
	  this._hash = createHash(alg).update(ipad)
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(482)
	
	module.exports = function (crypto, exports) {
	  exports = exports || {}
	
	  var exported = pbkdf2Export(crypto)
	
	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync
	
	  return exports
	}


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }
	
	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')
	
	    setTimeout(function() {
	      var result
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }
	
	      callback(undefined, result)
	    })
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')
	
	    if (iterations < 0)
	      throw new TypeError('Bad iterations')
	
	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')
	
	    if (keylen < 0)
	      throw new TypeError('Bad key length')
	
	    digest = digest || 'sha1'
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)
	
	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)
	
	      var U = crypto.createHmac(digest, password).update(block1).digest()
	
	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }
	
	      U.copy(T, 0, 0, hLen)
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }
	
	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }
	
	    return DK
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function (crypto, exports) {
	  exports = exports || {};
	  var ciphers = __webpack_require__(484)(crypto);
	  exports.createCipher = ciphers.createCipher;
	  exports.createCipheriv = ciphers.createCipheriv;
	  var deciphers = __webpack_require__(516)(crypto);
	  exports.createDecipher = deciphers.createDecipher;
	  exports.createDecipheriv = deciphers.createDecipheriv;
	  var modes = __webpack_require__(507);
	  function listCiphers () {
	    return Object.keys(modes);
	  }
	  exports.listCiphers = listCiphers;
	};
	


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(485);
	var Transform = __webpack_require__(486);
	var inherits = __webpack_require__(489);
	var modes = __webpack_require__(507);
	var ebtk = __webpack_require__(508);
	var StreamCipher = __webpack_require__(509);
	inherits(Cipher, Transform);
	function Cipher(mode, key, iv) {
	  if (!(this instanceof Cipher)) {
	    return new Cipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Cipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Cipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  this.push(this._mode.encrypt(this, chunk));
	  this._cipher.scrub();
	  next();
	};
	
	
	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};
	
	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = new Buffer(len);
	
	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }
	  var out = Buffer.concat([this.cache, padBuff]);
	  return out;
	};
	var modelist = {
	  ECB: __webpack_require__(510),
	  CBC: __webpack_require__(511),
	  CFB: __webpack_require__(513),
	  OFB: __webpack_require__(514),
	  CTR: __webpack_require__(515)
	};
	module.exports = function (crypto) {
	  function createCipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv);
	    }
	    return new Cipher(modelist[config.mode], password, iv);
	  }
	  function createCipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createCipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createCipher: createCipher,
	    createCipheriv: createCipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var uint_max = Math.pow(2, 32);
	function fixup_uint32(x) {
	    var ret, x_pos;
	    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
	    return ret;
	}
	function scrub_vec(v) {
	  var i, _i, _ref;
	  for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	    v[i] = 0;
	  }
	  return false;
	}
	
	function Global() {
	  var i;
	  this.SBOX = [];
	  this.INV_SBOX = [];
	  this.SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.INV_SUB_MIX = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 4; i = ++_i) {
	      _results.push([]);
	    }
	    return _results;
	  })();
	  this.init();
	  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	}
	
	Global.prototype.init = function() {
	  var d, i, sx, t, x, x2, x4, x8, xi, _i;
	  d = (function() {
	    var _i, _results;
	    _results = [];
	    for (i = _i = 0; _i < 256; i = ++_i) {
	      if (i < 128) {
	        _results.push(i << 1);
	      } else {
	        _results.push((i << 1) ^ 0x11b);
	      }
	    }
	    return _results;
	  })();
	  x = 0;
	  xi = 0;
	  for (i = _i = 0; _i < 256; i = ++_i) {
	    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    this.SBOX[x] = sx;
	    this.INV_SBOX[sx] = x;
	    x2 = d[x];
	    x4 = d[x2];
	    x8 = d[x4];
	    t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    this.SUB_MIX[3][x] = t;
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    this.INV_SUB_MIX[3][sx] = t;
	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }
	  return true;
	};
	
	var G = new Global();
	
	
	AES.blockSize = 4 * 4;
	
	AES.prototype.blockSize = AES.blockSize;
	
	AES.keySize = 256 / 8;
	
	AES.prototype.keySize = AES.keySize;
	
	AES.ivSize = AES.blockSize;
	
	AES.prototype.ivSize = AES.ivSize;
	
	 function bufferToArray(buf) {
	  var len = buf.length/4;
	  var out = new Array(len);
	  var i = -1;
	  while (++i < len) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }
	  return out;
	 }
	function AES(key) {
	  this._key = bufferToArray(key);
	  this._doReset();
	}
	
	AES.prototype._doReset = function() {
	  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
	  keyWords = this._key;
	  keySize = keyWords.length;
	  this._nRounds = keySize + 6;
	  ksRows = (this._nRounds + 1) * 4;
	  this._keySchedule = [];
	  for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
	    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
	  }
	  this._invKeySchedule = [];
	  for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
	    ksRow = ksRows - invKsRow;
	    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
	    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
	  }
	  return true;
	};
	
	AES.prototype.encryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf;
	};
	
	AES.prototype.decryptBlock = function(M) {
	  M = bufferToArray(new Buffer(M));
	  var temp = [M[3], M[1]];
	  M[1] = temp[0];
	  M[3] = temp[1];
	  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
	  var buf = new Buffer(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf;
	};
	
	AES.prototype.scrub = function() {
	  scrub_vec(this._keySchedule);
	  scrub_vec(this._invKeySchedule);
	  scrub_vec(this._key);
	};
	
	AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
	  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
	
	  s0 = M[0] ^ keySchedule[0];
	  s1 = M[1] ^ keySchedule[1];
	  s2 = M[2] ^ keySchedule[2];
	  s3 = M[3] ^ keySchedule[3];
	  ksRow = 4;
	  for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
	    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }
	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  return [
	    fixup_uint32(t0),
	    fixup_uint32(t1),
	    fixup_uint32(t2),
	    fixup_uint32(t3)
	  ];
	
	};
	
	
	
	
	  exports.AES = AES;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Transform = __webpack_require__(487).Transform;
	var inherits = __webpack_require__(489);
	
	module.exports = CipherBase;
	inherits(CipherBase, Transform);
	function CipherBase() {
	  Transform.call(this);
	}
	CipherBase.prototype.update = function (data, inputEnd, outputEnc) {
	  this.write(data, inputEnd);
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	CipherBase.prototype.final = function (outputEnc) {
	  this.end();
	  var outData = new Buffer('');
	  var chunk;
	  while ((chunk = this.read())) {
	    outData = Buffer.concat([outData, chunk]);
	  }
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(488).EventEmitter;
	var inherits = __webpack_require__(489);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(490);
	Stream.Writable = __webpack_require__(503);
	Stream.Duplex = __webpack_require__(504);
	Stream.Transform = __webpack_require__(505);
	Stream.PassThrough = __webpack_require__(506);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 488 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 489 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(487); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(491);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(498);
	exports.Duplex = __webpack_require__(497);
	exports.Transform = __webpack_require__(501);
	exports.PassThrough = __webpack_require__(502);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(311)))

/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(492);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(465);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(488).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(487);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(488).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(462).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(493);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(494);
	util.inherits = __webpack_require__(489);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(495);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(496);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(497);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(500).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(497);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(500).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(311)))

/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(311)))

/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(462);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 495 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(462).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(493);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(492);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(494);
	util.inherits = __webpack_require__(489);
	/*</replacement>*/
	
	var Readable = __webpack_require__(491);
	var Writable = __webpack_require__(498);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(492);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(494);
	util.inherits = __webpack_require__(489);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(499)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(487);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(488).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(462).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(493);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(497);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(497);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = Buffer.isBuffer(chunk);
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    chunk = decodeChunk(state, chunk, encoding);
	    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(311), __webpack_require__(309).setImmediate))

/***/ },
/* 499 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(462).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(497);
	
	/*<replacement>*/
	var util = __webpack_require__(494);
	util.inherits = __webpack_require__(489);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(501);
	
	/*<replacement>*/
	var util = __webpack_require__(494);
	util.inherits = __webpack_require__(489);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(498)


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(497)


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(501)


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(502)


/***/ },
/* 507 */
/***/ function(module, exports) {

	exports['aes-128-ecb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-192-ecb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-256-ecb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 0,
	  mode: 'ECB',
	  type: 'block'
	};
	exports['aes-128-cbc'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-192-cbc'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes-256-cbc'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CBC',
	  type: 'block'
	};
	exports['aes128'] = exports['aes-128-cbc'];
	exports['aes192'] = exports['aes-192-cbc'];
	exports['aes256'] = exports['aes-256-cbc'];
	exports['aes-128-cfb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-192-cfb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-256-cfb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CFB',
	  type: 'stream'
	};
	exports['aes-128-ofb'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-192-ofb'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-256-ofb'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'OFB',
	  type: 'stream'
	};
	exports['aes-128-ctr'] = {
	  cipher: 'AES',
	  key: 128,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-192-ctr'] = {
	  cipher: 'AES',
	  key: 192,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};
	exports['aes-256-ctr'] = {
	  cipher: 'AES',
	  key: 256,
	  iv: 16,
	  mode: 'CTR',
	  type: 'stream'
	};

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = function (crypto, password, keyLen, ivLen) {
	  keyLen = keyLen/8;
	  ivLen = ivLen || 0;
	  var ki = 0;
	  var ii = 0;
	  var key = new Buffer(keyLen);
	  var iv = new Buffer(ivLen);
	  var addmd = 0;
	  var md, md_buf;
	  var i;
	  while (true) {
	    md = crypto.createHash('md5');
	    if(addmd++ > 0) {
	       md.update(md_buf);
	    }
	    md.update(password);
	    md_buf = md.digest();
	    i = 0;
	    if(keyLen > 0) {
	      while(true) {
	        if(keyLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	        key[ki++] = md_buf[i];
	        keyLen--;
	        i++;
	       }
	    }
	    if(ivLen > 0 && i !== md_buf.length) {
	      while(true) {
	        if(ivLen === 0) {
	          break;
	        }
	        if(i === md_buf.length) {
	          break;
	        }
	       iv[ii++] = md_buf[i];
	       ivLen--;
	       i++;
	     }
	   }
	   if(keyLen === 0 && ivLen === 0) {
	      break;
	    }
	  }
	  for(i=0;i<md_buf.length;i++) {
	    md_buf[i] = 0;
	  }
	  return {
	    key: key,
	    iv: iv
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(485);
	var Transform = __webpack_require__(486);
	var inherits = __webpack_require__(489);
	
	inherits(StreamCipher, Transform);
	module.exports = StreamCipher;
	function StreamCipher(mode, key, iv, decrypt) {
	  if (!(this instanceof StreamCipher)) {
	    return new StreamCipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  this._cache = new Buffer('');
	  this._secCache = new Buffer('');
	  this._decrypt = decrypt;
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	StreamCipher.prototype._transform = function (chunk, _, next) {
	  next(null, this._mode.encrypt(this, chunk, this._decrypt));
	};
	StreamCipher.prototype._flush = function (next) {
	  this._cipher.scrub();
	  next();
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 510 */
/***/ function(module, exports) {

	exports.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block);
	};
	exports.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block);
	};

/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	var xor = __webpack_require__(512);
	exports.encrypt = function (self, block) {
	  var data = xor(block, self._prev);
	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev;
	};
	exports.decrypt = function (self, block) {
	  var pad = self._prev;
	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);
	  return xor(out, pad);
	};

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = xor;
	function xor(a, b) {
	  var len = Math.min(a.length, b.length);
	  var out = new Buffer(len);
	  var i = -1;
	  while (++i < len) {
	    out.writeUInt8(a[i] ^ b[i], i);
	  }
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(512);
	exports.encrypt = function (self, data, decrypt) {
	  var out = new Buffer('');
	  var len;
	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = new Buffer('');
	    }
	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
	      break;
	    }
	  }
	  return out;
	};
	function encryptStart(self, data, decrypt) {
	  var len = data.length;
	  var out = xor(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer.concat([self._prev, decrypt?data:out]);
	  return out;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(512);
	function getBlock(self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(512);
	function getBlock(self) {
	  var out = self._cipher.encryptBlock(self._prev);
	  incr32(self._prev);
	  return out;
	}
	exports.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer.concat([self._cache, getBlock(self)]);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad);
	};
	function incr32(iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break;
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(485);
	var Transform = __webpack_require__(486);
	var inherits = __webpack_require__(489);
	var modes = __webpack_require__(507);
	var StreamCipher = __webpack_require__(509);
	var ebtk = __webpack_require__(508);
	
	inherits(Decipher, Transform);
	function Decipher(mode, key, iv) {
	  if (!(this instanceof Decipher)) {
	    return new Decipher(mode, key, iv);
	  }
	  Transform.call(this);
	  this._cache = new Splitter();
	  this._last = void 0;
	  this._cipher = new aes.AES(key);
	  this._prev = new Buffer(iv.length);
	  iv.copy(this._prev);
	  this._mode = mode;
	}
	Decipher.prototype._transform = function (data, _, next) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  while ((chunk = this._cache.get())) {
	    thing = this._mode.decrypt(this, chunk);
	    this.push(thing);
	  }
	  next();
	};
	Decipher.prototype._flush = function (next) {
	  var chunk = this._cache.flush();
	  if (!chunk) {
	    return next;
	  }
	
	  this.push(unpad(this._mode.decrypt(this, chunk)));
	
	  next();
	};
	
	function Splitter() {
	   if (!(this instanceof Splitter)) {
	    return new Splitter();
	  }
	  this.cache = new Buffer('');
	}
	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};
	
	Splitter.prototype.get = function () {
	  if (this.cache.length > 16) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out;
	  }
	  return null;
	};
	Splitter.prototype.flush = function () {
	  if (this.cache.length) {
	    return this.cache;
	  }
	};
	function unpad(last) {
	  var padded = last[15];
	  if (padded === 16) {
	    return;
	  }
	  return last.slice(0, 16 - padded);
	}
	
	var modelist = {
	  ECB: __webpack_require__(510),
	  CBC: __webpack_require__(511),
	  CFB: __webpack_require__(513),
	  OFB: __webpack_require__(514),
	  CTR: __webpack_require__(515)
	};
	
	module.exports = function (crypto) {
	  function createDecipheriv(suite, password, iv) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    if (typeof iv === 'string') {
	      iv = new Buffer(iv);
	    }
	    if (typeof password === 'string') {
	      password = new Buffer(password);
	    }
	    if (password.length !== config.key/8) {
	      throw new TypeError('invalid key length ' + password.length);
	    }
	    if (iv.length !== config.iv) {
	      throw new TypeError('invalid iv length ' + iv.length);
	    }
	    if (config.type === 'stream') {
	      return new StreamCipher(modelist[config.mode], password, iv, true);
	    }
	    return new Decipher(modelist[config.mode], password, iv);
	  }
	
	  function createDecipher (suite, password) {
	    var config = modes[suite];
	    if (!config) {
	      throw new TypeError('invalid suite type');
	    }
	    var keys = ebtk(crypto, password, config.key, config.iv);
	    return createDecipheriv(suite, keys.key, keys.iv);
	  }
	  return {
	    createDecipher: createDecipher,
	    createDecipheriv: createDecipheriv
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(462).Buffer))

/***/ },
/* 517 */
/***/ function(module, exports) {

	'use strict';
	
	// Taken from https://github.com/sindresorhus/decamelize/blob/95980ab6fb44c40eaca7792bdf93aff7c210c805/index.js
	function transformKey(key) {
	  return key.replace(/([a-z\d])([A-Z])/g, '$1_$2')
	    .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1_$2')
	    .toLowerCase();
	}
	
	module.exports = function (obj) {
	  return Object.keys(obj).reduce(function (newObj, key) {
	    var transformedKey = transformKey(key);
	
	    newObj[transformedKey] = obj[key];
	
	    return newObj;
	  }, {});
	};


/***/ },
/* 518 */
/***/ function(module, exports) {

	'use strict';
	
	function setup() {
	  return new Fraudnet();
	}
	
	function Fraudnet() {
	  this.sessionId = _generateSessionId();
	  this._beaconId = _generateBeaconId(this.sessionId);
	
	  this._parameterBlock = _createParameterBlock(this.sessionId, this._beaconId);
	  this._thirdPartyBlock = _createThirdPartyBlock();
	}
	
	Fraudnet.prototype.teardown = function () {
	  this._thirdPartyBlock.parentNode.removeChild(this._thirdPartyBlock);
	};
	
	function _generateSessionId() {
	  var i;
	  var id = '';
	
	  for (i = 0; i < 32; i++) {
	    id += Math.floor(Math.random() * 16).toString(16);
	  }
	
	  return id;
	}
	
	function _generateBeaconId(sessionId) {
	  var timestamp = new Date().getTime() / 1000;
	
	  return 'https://b.stats.paypal.com/counter.cgi' +
	    '?i=127.0.0.1' +
	    '&p=' + sessionId +
	    '&t=' + timestamp +
	    '&a=14';
	}
	
	function _createParameterBlock(sessionId, beaconId) {
	  var el = document.body.appendChild(document.createElement('script'));
	
	  el.type = 'application/json';
	  el.setAttribute('fncls', 'fnparams-dede7cc5-15fd-4c75-a9f4-36c430ee3a99');
	  el.text = JSON.stringify({
	    f: sessionId,
	    s: 'BRAINTREE_SIGNIN',
	    b: beaconId
	  });
	
	  return el;
	}
	
	function _createThirdPartyBlock() {
	  var dom, doc;
	  var scriptBaseURL = 'https://www.paypalobjects.com/webstatic/r/fb/';
	  var iframe = document.createElement('iframe');
	
	  iframe.src = 'about:blank';
	  iframe.title = '';
	  iframe.role = 'presentation'; // a11y
	  (iframe.frameElement || iframe).style.cssText = 'width: 0; height: 0; border: 0; position: absolute; z-index: -999';
	  document.body.appendChild(iframe);
	
	  try {
	    doc = iframe.contentWindow.document;
	  } catch (e) {
	    dom = document.domain;
	    iframe.src = 'javascript:var d=document.open();d.domain="' + dom + '";void(0);'; // eslint-disable-line no-script-url
	    doc = iframe.contentWindow.document;
	  }
	
	  doc.open()._l = function () {
	    var js = this.createElement('script');
	
	    if (dom) {
	      this.domain = dom;
	    }
	    js.id = 'js-iframe-async';
	    js.src = scriptBaseURL + 'fb-all-prod.pp.min.js';
	    this.body.appendChild(js);
	  };
	
	  function listener() { doc._l(); }
	
	  if (iframe.addEventListener) {
	    iframe.addEventListener('load', listener, false);
	  } else if (iframe.attachEvent) {
	    iframe.attachEvent('onload', listener);
	  } else {
	    doc.write('<body onload="document._l();">');
	  }
	
	  doc.close();
	
	  return iframe;
	}
	
	module.exports = {
	  setup: setup
	};


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  DATA_COLLECTOR_KOUNT_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'DATA_COLLECTOR_KOUNT_NOT_ENABLED',
	    message: 'Kount is not enabled for this merchant.'
	  },
	  DATA_COLLECTOR_KOUNT_ERROR: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'DATA_COLLECTOR_KOUNT_ERROR'
	  },
	  DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'DATA_COLLECTOR_REQUIRES_CREATE_OPTIONS',
	    message: 'Data Collector must be created with Kount and/or PayPal.'
	  }
	};


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/american-express
	 * @description This module is for use with Amex Express Checkout. To accept American Express cards, use Hosted Fields.
	 */
	
	var BraintreeError = __webpack_require__(378);
	var AmericanExpress = __webpack_require__(521);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link AmericanExpress} instance. If no callback is provided, `create` returns a promise that resolves with the {@link AmericanExpress} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating American Express.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and American Express (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  return Promise.resolve(new AmericanExpress(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(522);
	var assign = __webpack_require__(387).assign;
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @class
	 * @param {object} options Options
	 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/american-express.create|braintree.american-express.create} instead.</strong>
	 * @classdesc This class allows you use a nonce to interact with American Express Checkout. To accept American Express cards, use Hosted Fields.
	 */
	function AmericanExpress(options) {
	  this._client = options.client;
	}
	
	/**
	 * Gets the rewards balance associated with a Braintree nonce.
	 * @public
	 * @param {object} options Request options
	 * @param {string} options.nonce An existing Braintree nonce.
	 * @param {callback} [callback] The second argument, <code>data</code>, is the returned server data. If no callback is provided, `getRewardsBalance` returns a promise that resolves with the server data.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * var americanExpress = require('braintree-web/american-express');
	 *
	 * americanExpress.create({client: clientInstance}, function (createErr, americanExpressInstance) {
	 *   var options = {nonce: existingBraintreeNonce};
	 *   americanExpressInstance.getRewardsBalance(options, function (getErr, payload) {
	 *     if (getErr || payload.error) {
	 *       // Handle error
	 *       return;
	 *     }
	 *
	 *     console.log('Rewards amount: ' + payload.rewardsAmount);
	 *   });
	 * });
	 */
	AmericanExpress.prototype.getRewardsBalance = function (options) {
	  var nonce = options.nonce;
	  var data;
	
	  if (!nonce) {
	    return Promise.reject(new BraintreeError({
	      type: errors.AMEX_NONCE_REQUIRED.type,
	      code: errors.AMEX_NONCE_REQUIRED.code,
	      message: 'getRewardsBalance must be called with a nonce.'
	    }));
	  }
	
	  data = assign({
	    _meta: {source: 'american-express'},
	    paymentMethodNonce: nonce
	  }, options);
	
	  delete data.nonce;
	
	  return this._client.request({
	    method: 'get',
	    endpoint: 'payment_methods/amex_rewards_balance',
	    data: data
	  }).catch(function (err) {
	    return Promise.reject(new BraintreeError({
	      type: errors.AMEX_NETWORK_ERROR.type,
	      code: errors.AMEX_NETWORK_ERROR.code,
	      message: 'A network error occurred when getting the American Express rewards balance.',
	      details: {
	        originalError: err
	      }
	    }));
	  });
	};
	
	/**
	 * Gets the Express Checkout nonce profile given a nonce from American Express.
	 * @public
	 * @param {object} options Request options
	 * @param {string} options.nonce An existing nonce from American Express (note that this is <em>not</em> a nonce from Braintree).
	 * @param {callback} [callback] The second argument, <code>data</code>, is the returned server data. If no callback is provided, `getExpressCheckoutProfile` returns a promise that resolves with the server data.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * var americanExpress = require('braintree-web/american-express');
	 *
	 * americanExpress.create({client: clientInstance}, function (createErr, americanExpressInstance) {
	 *   var options = {nonce: existingAmericanExpressNonce};
	 *   americanExpressInstance.getExpressCheckoutProfile(options, function (getErr, payload) {
	 *     if (getErr) {
	 *       // Handle error
	 *       return;
	 *     }
	 *
	 *     console.log('Number of cards: ' + payload.amexExpressCheckoutCards.length);
	 *   });
	 * });
	 */
	AmericanExpress.prototype.getExpressCheckoutProfile = function (options) {
	  if (!options.nonce) {
	    return Promise.reject(new BraintreeError({
	      type: errors.AMEX_NONCE_REQUIRED.type,
	      code: errors.AMEX_NONCE_REQUIRED.code,
	      message: 'getExpressCheckoutProfile must be called with a nonce.'
	    }));
	  }
	
	  return this._client.request({
	    method: 'get',
	    endpoint: 'payment_methods/amex_express_checkout_cards/' + options.nonce,
	    data: {
	      _meta: {source: 'american-express'},
	      paymentMethodNonce: options.nonce
	    }
	  }).catch(function (err) {
	    return Promise.reject(new BraintreeError({
	      type: errors.AMEX_NETWORK_ERROR.type,
	      code: errors.AMEX_NETWORK_ERROR.code,
	      message: 'A network error occurred when getting the American Express Checkout nonce profile.',
	      details: {
	        originalError: err
	      }
	    }));
	  });
	};
	
	module.exports = wrapPromise.wrapPrototype(AmericanExpress);


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  AMEX_NONCE_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'AMEX_NONCE_REQUIRED'
	  },
	  AMEX_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'AMEX_NETWORK_ERROR'
	  }
	};


/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/unionpay
	 * @description This module allows you to accept UnionPay payments. *It is currently in beta and is subject to change.*
	 */
	
	var UnionPay = __webpack_require__(524);
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var errors = __webpack_require__(526);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	* @static
	* @function create
	* @param {object} options Creation options:
	* @param {Client} options.client A {@link Client} instance.
	* @param {callback} [callback] The second argument, `data`, is the {@link UnionPay} instance. If no callback is provided, `create` returns a promise that resolves with the {@link UnionPay} instance.
	* @returns {Promise|void} Returns a promise if no callback is provided.
	* @example
	* braintree.unionpay.create({ client: clientInstance }, function (createErr, unionpayInstance) {
	*   if (createErr) {
	*     console.error(createErr);
	*     return;
	*   }
	*   // ...
	* });
	*/
	function create(options) {
	  var config, clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating UnionPay.'
	    }));
	  }
	
	  config = options.client.getConfiguration();
	  clientVersion = config.analyticsMetadata.sdkVersion;
	
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and UnionPay (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (!config.gatewayConfiguration.unionPay || config.gatewayConfiguration.unionPay.enabled !== true) {
	    return Promise.reject(new BraintreeError(errors.UNIONPAY_NOT_ENABLED));
	  }
	
	  analytics.sendEvent(options.client, 'unionpay.initialized');
	
	  return Promise.resolve(new UnionPay(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var analytics = __webpack_require__(411);
	var BraintreeError = __webpack_require__(378);
	var Bus = __webpack_require__(433);
	var constants = __webpack_require__(525);
	var useMin = __webpack_require__(438);
	var convertMethodsToError = __webpack_require__(441);
	var errors = __webpack_require__(526);
	var events = constants.events;
	var iFramer = __webpack_require__(423);
	var methods = __webpack_require__(440);
	var VERSION = "3.14.0";
	var uuid = __webpack_require__(384);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @class
	 * @param {object} options See {@link module:braintree-web/unionpay.create|unionpay.create}.
	 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/unionpay.create|braintree-web.unionpay.create} instead.</strong>
	 * @classdesc This class represents a UnionPay component. Instances of this class have methods for {@link UnionPay#fetchCapabilities fetching capabilities} of UnionPay cards, {@link UnionPay#enroll enrolling} a UnionPay card, and {@link UnionPay#tokenize tokenizing} a UnionPay card.
	 */
	function UnionPay(options) {
	  this._options = options;
	}
	
	/**
	 * @typedef {object} UnionPay~fetchCapabilitiesPayload
	 * @property {boolean} isUnionPay Determines if this card is a UnionPay card.
	 * @property {boolean} isDebit Determines if this card is a debit card. This property is only present if `isUnionPay` is `true`.
	 * @property {object} unionPay UnionPay specific properties. This property is only present if `isUnionPay` is `true`.
	 * @property {boolean} unionPay.supportsTwoStepAuthAndCapture Determines if the card allows for an authorization, but settling the transaction later.
	 * @property {boolean} unionPay.isSupported Determines if Braintree can process this UnionPay card. When false, Braintree cannot process this card and the user should use a different card.
	 */
	
	/**
	 * Fetches the capabilities of a card, including whether or not the SMS enrollment process is required.
	 * @public
	 * @param {object} options UnionPay {@link UnionPay#fetchCapabilities fetchCapabilities} options
	 * @param {object} [options.card] The card from which to fetch capabilities. Note that this will only have one property, `number`. Required if you are not using the `hostedFields` option.
	 * @param {string} options.card.number Card number.
	 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay#fetchCapabilitiesPayload fetchCapabilitiesPayload}. If no callback is provided, `fetchCapabilities` returns a promise that resolves with a {@link UnionPay#fetchCapabilitiesPayload fetchCapabilitiesPayload}.
	 * @example <caption>With raw card data</caption>
	 * unionpayInstance.fetchCapabilities({
	 *   card: {
	 *     number: '4111111111111111'
	 *   }
	 * }, function (fetchErr, cardCapabilities) {
	 *   if (fetchErr) {
	 *     console.error(fetchErr);
	 *     return;
	 *   }
	 *
	 *   if (cardCapabilities.isUnionPay) {
	 *     if (cardCapabilities.unionPay && !cardCapabilities.unionPay.isSupported) {
	 *       // Braintree cannot process this UnionPay card.
	 *       // Ask the user for a different card.
	 *       return;
	 *     }
	 *
	 *     if (cardCapabilities.isDebit) {
	 *       // CVV and expiration date are not required
	 *     } else {
	 *       // CVV and expiration date are required
	 *     }
	 *
	 *     // Show mobile phone number field for enrollment
	 *   }
	 * });
	 * @example <caption>With Hosted Fields</caption>
	 * // Fetch capabilities on `validityChange` inside of the Hosted Fields `create` callback
	 * hostedFieldsInstance.on('validityChange', function (event) {
	 *   // Only attempt to fetch capabilities when a valid card number has been entered
	 *   if (event.emittedBy === 'number' && event.fields.number.isValid) {
	 *     unionpayInstance.fetchCapabilities({
	 *       hostedFields: hostedFieldsInstance
	 *     }, function (fetchErr, cardCapabilities) {
	 *       if (fetchErr) {
	 *         console.error(fetchErr);
	 *         return;
	 *       }
	 *
	 *       if (cardCapabilities.isUnionPay) {
	 *         if (cardCapabilities.unionPay && !cardCapabilities.unionPay.isSupported) {
	 *           // Braintree cannot process this UnionPay card.
	 *           // Ask the user for a different card.
	 *           return;
	 *         }
	 *         if (cardCapabilities.isDebit) {
	 *           // CVV and expiration date are not required
	 *           // Hide the containers with your `cvv` and `expirationDate` fields
	 *         } else {
	 *           // CVV and expiration date are required
	 *         }
	 *       } else {
	 *         // Not a UnionPay card
	 *         // When form is complete, tokenize using your Hosted Fields instance
	 *       }
	 *
	 *       // Show your own mobile country code and phone number inputs for enrollment
	 *     });
	 *   });
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	UnionPay.prototype.fetchCapabilities = function (options) {
	  var self = this;
	  var client = this._options.client;
	  var cardNumber = options.card ? options.card.number : null;
	  var hostedFields = options.hostedFields;
	
	  if (cardNumber && hostedFields) {
	    return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
	  } else if (cardNumber) {
	    return client.request({
	      method: 'get',
	      endpoint: 'payment_methods/credit_cards/capabilities',
	      data: {
	        _meta: {source: 'unionpay'},
	        creditCard: {
	          number: cardNumber
	        }
	      }
	    }).then(function (response) {
	      analytics.sendEvent(client, 'unionpay.capabilities-received');
	      return response;
	    }).catch(function (err) {
	      var status = err.details && err.details.httpStatus;
	
	      analytics.sendEvent(client, 'unionpay.capabilities-failed');
	
	      if (status === 403) {
	        return Promise.reject(err);
	      }
	      return Promise.reject(new BraintreeError({
	        type: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.type,
	        code: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.code,
	        message: errors.UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR.message,
	        details: {
	          originalError: err
	        }
	      }));
	    });
	  } else if (hostedFields) {
	    if (!hostedFields._bus) {
	      return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
	    }
	
	    return new Promise(function (resolve, reject) {
	      self._initializeHostedFields(function () {
	        self._bus.emit(events.HOSTED_FIELDS_FETCH_CAPABILITIES, {hostedFields: hostedFields}, function (response) {
	          if (response.err) {
	            reject(new BraintreeError(response.err));
	            return;
	          }
	
	          resolve(response.payload);
	        });
	      });
	    });
	  }
	
	  return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
	};
	
	/**
	 * @typedef {object} UnionPay~enrollPayload
	 * @property {string} enrollmentId UnionPay enrollment ID. This value should be passed to `tokenize`.
	 * @property {boolean} smsCodeRequired UnionPay `smsCodeRequired` flag.
	 * </p><b>true</b> - the user will receive an SMS code that needs to be supplied for tokenization.
	 * </p><b>false</b> - the card can be immediately tokenized.
	 */
	
	/**
	 * Enrolls a UnionPay card. Use {@link UnionPay#fetchCapabilities|fetchCapabilities} to determine if the SMS enrollment process is required.
	 * @public
	 * @param {object} options UnionPay enrollment options:
	 * @param {object} [options.card] The card to enroll. Required if you are not using the `hostedFields` option.
	 * @param {string} options.card.number The card number.
	 * @param {string} [options.card.expirationDate] The card's expiration date. May be in the form `MM/YY` or `MM/YYYY`. When defined `expirationMonth` and `expirationYear` are ignored.
	 * @param {string} [options.card.expirationMonth] The card's expiration month. This should be used with the `expirationYear` parameter. When `expirationDate` is defined this parameter is ignored.
	 * @param {string} [options.card.expirationYear] The card's expiration year. This should be used with the `expirationMonth` parameter. When `expirationDate` is defined this parameter is ignored.
	 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
	 * @param {object} options.mobile The mobile information collected from the customer.
	 * @param {string} options.mobile.countryCode The country code of the customer's mobile phone number.
	 * @param {string} options.mobile.number The customer's mobile phone number.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay~enrollPayload|enrollPayload}. If no callback is provided, `enroll` returns a promise that resolves with {@link UnionPay~enrollPayload|enrollPayload}.
	 * @example <caption>With raw card data</caption>
	 * unionpayInstance.enroll({
	 *   card: {
	 *     number: '4111111111111111',
	 *     expirationMonth: '12',
	 *     expirationYear: '2038'
	 *   },
	 *   mobile: {
	 *     countryCode: '62',
	 *     number: '111111111111'
	 *   }
	 * }, function (enrollErr, response) {
	 *   if (enrollErr) {
	 *      console.error(enrollErr);
	 *      return;
	 *   }
	 *
	 *   if (response.smsCodeRequired) {
	 *     // If smsCodeRequired, wait for SMS auth code from customer
	 *     // Then use response.enrollmentId during {@link UnionPay#tokenize}
	 *   } else {
	 *     // SMS code is not required from the user.
	 *     // {@link UnionPay#tokenize} can be called immediately
	 * });
	 * @example <caption>With Hosted Fields</caption>
	 * unionpayInstance.enroll({
	 *   hostedFields: hostedFields,
	 *   mobile: {
	 *     countryCode: '62',
	 *     number: '111111111111'
	 *   }
	 * }, function (enrollErr, response) {
	 *   if (enrollErr) {
	 *     console.error(enrollErr);
	 *     return;
	 *   }
	 *
	 *   if (response.smsCodeRequired) {
	 *     // If smsCodeRequired, wait for SMS auth code from customer
	 *     // Then use response.enrollmentId during {@link UnionPay#tokenize}
	 *   } else {
	 *     // SMS code is not required from the user.
	 *     // {@link UnionPay#tokenize} can be called immediately
	 *   }
	 * });
	 * @returns {void}
	 */
	UnionPay.prototype.enroll = function (options) {
	  var self = this;
	  var client = this._options.client;
	  var card = options.card;
	  var mobile = options.mobile;
	  var hostedFields = options.hostedFields;
	  var data;
	
	  if (!mobile) {
	    return Promise.reject(new BraintreeError(errors.UNIONPAY_MISSING_MOBILE_PHONE_DATA));
	  }
	
	  if (hostedFields) {
	    if (!hostedFields._bus) {
	      return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
	    } else if (card) {
	      return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
	    }
	
	    return new Promise(function (resolve, reject) {
	      self._initializeHostedFields(function () {
	        self._bus.emit(events.HOSTED_FIELDS_ENROLL, {hostedFields: hostedFields, mobile: mobile}, function (response) {
	          if (response.err) {
	            reject(new BraintreeError(response.err));
	            return;
	          }
	
	          resolve(response.payload);
	        });
	      });
	    });
	  } else if (card && card.number) {
	    data = {
	      _meta: {source: 'unionpay'},
	      unionPayEnrollment: {
	        number: card.number,
	        mobileCountryCode: mobile.countryCode,
	        mobileNumber: mobile.number
	      }
	    };
	
	    if (card.expirationDate) {
	      data.unionPayEnrollment.expirationDate = card.expirationDate;
	    } else if (card.expirationMonth || card.expirationYear) {
	      if (card.expirationMonth && card.expirationYear) {
	        data.unionPayEnrollment.expirationYear = card.expirationYear;
	        data.unionPayEnrollment.expirationMonth = card.expirationMonth;
	      } else {
	        return Promise.reject(new BraintreeError(errors.UNIONPAY_EXPIRATION_DATE_INCOMPLETE));
	      }
	    }
	
	    return client.request({
	      method: 'post',
	      endpoint: 'union_pay_enrollments',
	      data: data
	    }).then(function (response) {
	      analytics.sendEvent(client, 'unionpay.enrollment-succeeded');
	      return {
	        enrollmentId: response.unionPayEnrollmentId,
	        smsCodeRequired: response.smsCodeRequired
	      };
	    }).catch(function (err) {
	      var error;
	      var status = err.details && err.details.httpStatus;
	
	      if (status === 403) {
	        error = err;
	      } else if (status < 500) {
	        error = new BraintreeError(errors.UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID);
	        error.details = {originalError: err};
	      } else {
	        error = new BraintreeError(errors.UNIONPAY_ENROLLMENT_NETWORK_ERROR);
	        error.details = {originalError: err};
	      }
	
	      analytics.sendEvent(client, 'unionpay.enrollment-failed');
	      return Promise.reject(error);
	    });
	  }
	
	  return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
	};
	
	/**
	 * @typedef {object} UnionPay~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {string} type Always <code>CreditCard</code>.
	 * @property {object} details Additional account details:
	 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
	 * @property {string} details.lastTwo Last two digits of card number.
	 * @property {string} description A human-readable description.
	 */
	
	/**
	 * Tokenizes a UnionPay card and returns a nonce payload.
	 * @public
	 * @param {object} options UnionPay tokenization options:
	 * @param {object} [options.card] The card to enroll. Required if you are not using the `hostedFields` option.
	 * @param {string} options.card.number The card number.
	 * @param {string} [options.card.expirationDate] The card's expiration date. May be in the form `MM/YY` or `MM/YYYY`. When defined `expirationMonth` and `expirationYear` are ignored.
	 * @param {string} [options.card.expirationMonth] The card's expiration month. This should be used with the `expirationYear` parameter. When `expirationDate` is defined this parameter is ignored.
	 * @param {string} [options.card.expirationYear] The card's expiration year. This should be used with the `expirationMonth` parameter. When `expirationDate` is defined this parameter is ignored.
	 * @param {string} [options.card.cvv] The card's security number.
	 * @param {HostedFields} [options.hostedFields] The Hosted Fields instance used to collect card data. Required if you are not using the `card` option.
	 * @param {string} options.enrollmentId The enrollment ID from {@link UnionPay#enroll}.
	 * @param {string} [options.smsCode] The SMS code received from the user if {@link UnionPay#enroll} payload have `smsCodeRequired`. if `smsCodeRequired` is false, smsCode should not be passed.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link UnionPay~tokenizePayload|tokenizePayload}. If no callback is provided, `tokenize` returns a promise that resolves with a {@link UnionPay~tokenizePayload|tokenizePayload}.
	 * @example <caption>With raw card data</caption>
	 * unionpayInstance.tokenize({
	 *   card: {
	 *     number: '4111111111111111',
	 *     expirationMonth: '12',
	 *     expirationYear: '2038',
	 *     cvv: '123'
	 *   },
	 *   enrollmentId: enrollResponse.enrollmentId, // Returned from enroll
	 *   smsCode: '11111' // Received by customer's phone, if SMS enrollment was required. Otherwise it should be omitted
	 * }, function (tokenizeErr, response) {
	 *   if (tokenizeErr) {
	 *     console.error(tokenizeErr);
	 *     return;
	 *   }
	 *
	 *   // Send response.nonce to your server
	 * });
	 * @example <caption>With Hosted Fields</caption>
	 * unionpayInstance.tokenize({
	 *   hostedFields: hostedFieldsInstance,
	 *   enrollmentId: enrollResponse.enrollmentId, // Returned from enroll
	 *   smsCode: '11111' // Received by customer's phone, if SMS enrollment was required. Otherwise it should be omitted
	 * }, function (tokenizeErr, response) {
	 *   if (tokenizeErr) {
	 *     console.error(tokenizeErr);
	 *     return;
	 *   }
	 *
	 *   // Send response.nonce to your server
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	UnionPay.prototype.tokenize = function (options) {
	  var data;
	  var self = this;
	  var client = this._options.client;
	  var card = options.card;
	  var hostedFields = options.hostedFields;
	
	  if (card && hostedFields) {
	    return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES));
	  } else if (card) {
	    data = {
	      _meta: {source: 'unionpay'},
	      creditCard: {
	        number: options.card.number,
	        options: {
	          unionPayEnrollment: {
	            id: options.enrollmentId
	          }
	        }
	      }
	    };
	
	    if (options.smsCode) {
	      data.creditCard.options.unionPayEnrollment.smsCode = options.smsCode;
	    }
	
	    if (card.expirationDate) {
	      data.creditCard.expirationDate = card.expirationDate;
	    } else if (card.expirationMonth && card.expirationYear) {
	      data.creditCard.expirationYear = card.expirationYear;
	      data.creditCard.expirationMonth = card.expirationMonth;
	    }
	
	    if (options.card.cvv) {
	      data.creditCard.cvv = options.card.cvv;
	    }
	
	    return client.request({
	      method: 'post',
	      endpoint: 'payment_methods/credit_cards',
	      data: data
	    }).then(function (response) {
	      var tokenizedCard = response.creditCards[0];
	
	      delete tokenizedCard.consumed;
	      delete tokenizedCard.threeDSecureInfo;
	
	      analytics.sendEvent(client, 'unionpay.nonce-received');
	      return tokenizedCard;
	    }).catch(function (err) {
	      var error;
	      var status = err.details && err.details.httpStatus;
	
	      analytics.sendEvent(client, 'unionpay.nonce-failed');
	
	      if (status === 403) {
	        error = err;
	      } else if (status < 500) {
	        error = new BraintreeError(errors.UNIONPAY_FAILED_TOKENIZATION);
	        error.details = {originalError: err};
	      } else {
	        error = new BraintreeError(errors.UNIONPAY_TOKENIZATION_NETWORK_ERROR);
	        error.details = {originalError: err};
	      }
	
	      return Promise.reject(error);
	    });
	  } else if (hostedFields) {
	    if (!hostedFields._bus) {
	      return Promise.reject(new BraintreeError(errors.UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID));
	    }
	
	    return new Promise(function (resolve, reject) {
	      self._initializeHostedFields(function () {
	        self._bus.emit(events.HOSTED_FIELDS_TOKENIZE, options, function (response) {
	          if (response.err) {
	            reject(new BraintreeError(response.err));
	            return;
	          }
	
	          resolve(response.payload);
	        });
	      });
	    });
	  }
	
	  return Promise.reject(new BraintreeError(errors.UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED));
	};
	
	/**
	 * Cleanly remove anything set up by {@link module:braintree-web/unionpay.create|create}. This only needs to be called when using UnionPay with Hosted Fields.
	 * @public
	 * @param {callback} [callback] Called on completion. If no callback is provided, returns a promise.
	 * @example
	 * unionpayInstance.teardown();
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	UnionPay.prototype.teardown = function () {
	  if (this._bus) {
	    this._hostedFieldsFrame.parentNode.removeChild(this._hostedFieldsFrame);
	    this._bus.teardown();
	  }
	
	  convertMethodsToError(this, methods(UnionPay.prototype));
	
	  return Promise.resolve();
	};
	
	UnionPay.prototype._initializeHostedFields = function (callback) {
	  var assetsUrl, isDebug;
	  var componentId = uuid();
	
	  if (this._bus) {
	    callback();
	    return;
	  }
	
	  assetsUrl = this._options.client.getConfiguration().gatewayConfiguration.assetsUrl;
	  isDebug = this._options.client.getConfiguration().isDebug;
	
	  this._bus = new Bus({
	    channel: componentId,
	    merchantUrl: location.href
	  });
	  this._hostedFieldsFrame = iFramer({
	    name: constants.HOSTED_FIELDS_FRAME_NAME + '_' + componentId,
	    src: assetsUrl + '/web/' + VERSION + '/html/unionpay-hosted-fields-frame' + useMin(isDebug) + '.html',
	    height: 0,
	    width: 0
	  });
	
	  this._bus.on(Bus.events.CONFIGURATION_REQUEST, function (reply) {
	    reply(this._options.client);
	
	    callback();
	  }.bind(this));
	
	  document.body.appendChild(this._hostedFieldsFrame);
	};
	
	module.exports = wrapPromise.wrapPrototype(UnionPay);


/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enumerate = __webpack_require__(379);
	
	module.exports = {
	  events: enumerate([
	    'HOSTED_FIELDS_FETCH_CAPABILITIES',
	    'HOSTED_FIELDS_ENROLL',
	    'HOSTED_FIELDS_TOKENIZE'
	  ], 'union-pay:'),
	  HOSTED_FIELDS_FRAME_NAME: 'braintreeunionpayhostedfields'
	};


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  UNIONPAY_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_NOT_ENABLED',
	    message: 'UnionPay is not enabled for this merchant.'
	  },
	  UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_HOSTED_FIELDS_INSTANCE_INVALID',
	    message: 'Found an invalid Hosted Fields instance. Please use a valid Hosted Fields instance.'
	  },
	  UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_HOSTED_FIELDS_INSTANCE_REQUIRED',
	    message: 'Could not find the Hosted Fields instance.'
	  },
	  UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_CARD_OR_HOSTED_FIELDS_INSTANCE_REQUIRED',
	    message: 'A card or a Hosted Fields instance is required. Please supply a card or a Hosted Fields instance.'
	  },
	  UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_CARD_AND_HOSTED_FIELDS_INSTANCES',
	    message: 'Please supply either a card or a Hosted Fields instance, not both.'
	  },
	  UNIONPAY_EXPIRATION_DATE_INCOMPLETE: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_EXPIRATION_DATE_INCOMPLETE',
	    message: 'You must supply expiration month and year or neither.'
	  },
	  UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'UNIONPAY_ENROLLMENT_CUSTOMER_INPUT_INVALID',
	    message: 'Enrollment failed due to user input error.'
	  },
	  UNIONPAY_ENROLLMENT_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'UNIONPAY_ENROLLMENT_NETWORK_ERROR',
	    message: 'Could not enroll UnionPay card.'
	  },
	  UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'UNIONPAY_FETCH_CAPABILITIES_NETWORK_ERROR',
	    message: 'Could not fetch card capabilities.'
	  },
	  UNIONPAY_TOKENIZATION_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'UNIONPAY_TOKENIZATION_NETWORK_ERROR',
	    message: 'A tokenization network error occurred.'
	  },
	  UNIONPAY_MISSING_MOBILE_PHONE_DATA: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'UNIONPAY_MISSING_MOBILE_PHONE_DATA',
	    message: 'A `mobile` with `countryCode` and `number` is required.'
	  },
	  UNIONPAY_FAILED_TOKENIZATION: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'UNIONPAY_FAILED_TOKENIZATION',
	    message: 'The supplied card data failed tokenization.'
	  }
	};


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/vault-manager
	 * @description Manages customer's payment methods.
	 */
	
	var BraintreeError = __webpack_require__(378);
	var VaultManager = __webpack_require__(528);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} callback The second argument, `data`, is the {@link VaultManager} instance.
	 * @returns {void}
	 */
	function create(options) {
	  var clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Vault Manager.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Vault Manager (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  return Promise.resolve(new VaultManager(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @typedef {array} VaultManager~fetchPaymentMethodsPayload The customer's payment methods.
	 * @property {object} paymentMethod The payment method object.
	 * @property {string} paymentMethod.nonce A nonce that can be sent to your server to transact on the payment method.
	 * @property {boolean} paymentMethod.default Whether or not this is the default payment method for the customer.
	 * @property {object} paymentMethod.details Any additional details about the payment method. Varies depending on the type of payment method.
	 * @property {string} paymentMethod.type A constant indicating the type of payment method.
	 * @property {?string} paymentMethod.description Additional description about the payment method.
	 *
	 */
	
	/**
	 * @class
	 * @param {object} options Options
	 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/vault-manager.create|braintree.vault-manager.create} instead.</strong>
	 * @classdesc This class allows you to manage a customer's payment methods on the client.
	 */
	function VaultManager(options) {
	  this._client = options.client;
	}
	
	/**
	 * Fetches payment methods owned by the customer whose id was used to generate the client token used to create the {@link module:braintree-web/client|client}.
	 * @public
	 * @param {object} [options] Options for fetching payment methods.
	 * @param {boolean} [options.defaultFirst = false] If `true`, the payment methods will be returned with the default payment method for the customer first. Otherwise, the payment methods will be returned with the most recently used payment method first.
	 * @param {callback} [callback] The second argument is a {@link VaultManager~fetchPaymentMethodsPayload|fetchPaymentMehodsPayload}. This is also what is resolved by the promise if no callback is provided.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * vaultManagerInstance.fetchPaymentMethods(function (err, paymentMethods) {
	 *   paymentMethods.forEach(function (paymentMethod) {
	 *     // add payment method to UI
	 *     // paymentMethod.nonce <- transactable nonce associated with payment method
	 *     // paymentMethod.details <- object with additional information about payment method
	 *     // paymentMethod.type <- a constant signifying the type
	 *   });
	 * });
	 */
	VaultManager.prototype.fetchPaymentMethods = function (options) {
	  var defaultFirst;
	
	  options = options || {};
	
	  defaultFirst = options.defaultFirst === true ? 1 : 0;
	
	  return this._client.request({
	    endpoint: 'payment_methods',
	    method: 'get',
	    data: {
	      defaultFirst: defaultFirst
	    }
	  }).then(function (paymentMethodsPayload) {
	    return paymentMethodsPayload.paymentMethods.map(formatPaymentMethodPayload);
	  });
	};
	
	function formatPaymentMethodPayload(paymentMethod) {
	  var formattedPaymentMethod = {
	    nonce: paymentMethod.nonce,
	    'default': paymentMethod.default,
	    details: paymentMethod.details,
	    type: paymentMethod.type
	  };
	
	  if (paymentMethod.description) {
	    formattedPaymentMethod.description = paymentMethod.description;
	  }
	
	  return formattedPaymentMethod;
	}
	
	module.exports = wrapPromise.wrapPrototype(VaultManager);


/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * @module braintree-web/apple-pay
	 * @description Accept Apple Pay on the Web. *This component is currently in beta and is subject to change.*
	 */
	
	var BraintreeError = __webpack_require__(378);
	var ApplePay = __webpack_require__(530);
	var analytics = __webpack_require__(411);
	var sharedErrors = __webpack_require__(404);
	var errors = __webpack_require__(531);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link ApplePay} instance. If no callback is provided, `create` returns a promise that resolves with the {@link ApplePay} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Apple Pay.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Apple Pay (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (!options.client.getConfiguration().gatewayConfiguration.applePayWeb) {
	    return Promise.reject(new BraintreeError(errors.APPLE_PAY_NOT_ENABLED));
	  }
	
	  analytics.sendEvent(options.client, 'applepay.initialized');
	
	  return Promise.resolve(new ApplePay(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var errors = __webpack_require__(531);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * An Apple Pay Payment Authorization Event object.
	 * @typedef {object} ApplePayPaymentAuthorizedEvent
	 * @external ApplePayPaymentAuthorizedEvent
	 * @see {@link https://developer.apple.com/reference/applepayjs/applepaypaymentauthorizedevent ApplePayPaymentAuthorizedEvent}
	 */
	
	/**
	 * An Apple Pay Payment Request object.
	 * @typedef {object} ApplePayPaymentRequest
	 * @external ApplePayPaymentRequest
	 * @see {@link https://developer.apple.com/reference/applepayjs/1916082-applepay_js_data_types/paymentrequest PaymentRequest}
	 */
	
	/**
	 * @class
	 * @param {object} options Options
	 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/apple-pay.create|braintree.applePay.create} instead.</strong>
	 * @classdesc This class represents an Apple Pay component. Instances of this class have methods for validating the merchant server and tokenizing payments.
	 */
	function ApplePay(options) {
	  this._client = options.client;
	  /**
	   * @name ApplePay#merchantIdentifier
	   * @description A special merchant ID which represents the merchant association with Braintree. Required when using `ApplePaySession.canMakePaymentsWithActiveCard`.
	   * @example
	   * var promise = ApplePaySession.canMakePaymentsWithActiveCard(applePayInstance.merchantIdentifier);
	   * promise.then(function (canMakePaymentsWithActiveCard) {
	   *   if (canMakePaymentsWithActiveCard) {
	   *     // Set up Apple Pay buttons
	   *   }
	   * });
	   */
	  Object.defineProperty(this, 'merchantIdentifier', {
	    value: this._client.getConfiguration().gatewayConfiguration.applePayWeb.merchantIdentifier,
	    configurable: false,
	    writable: false
	  });
	}
	
	/**
	 * Merges a payment request with Braintree defaults to return an {external:ApplePayPaymentRequest}.
	 *
	 * The following properties are assigned to `paymentRequest` if not already defined. Their default values come from the Braintree gateway.
	 * - `countryCode`
	 * - `currencyCode`
	 * - `merchantCapabilities`
	 * - `supportedNetworks`
	 * @public
	 * @param {external:ApplePayPaymentRequest} paymentRequest The payment request details to apply on top of those from Braintree.
	 * @returns {external:ApplePayPaymentRequest} The decorated `paymentRequest` object.
	 * @example
	 * var applePay = require('braintree-web/apple-pay');
	 *
	 * applePay.create({client: clientInstance}, function (applePayErr, applePayInstance) {
	 *   if (applePayErr) {
	 *     // Handle error here
	 *     return;
	 *   }
	 *
	 *   var paymentRequest = applePayInstance.createPaymentRequest({
	 *     total: {
	 *       label: 'My Company',
	 *       amount: '19.99'
	 *     }
	 *   });
	 *
	 *   var session = new ApplePaySession(1, paymentRequest);
	 *
	 *   // ...
	 */
	ApplePay.prototype.createPaymentRequest = function (paymentRequest) {
	  var applePay = this._client.getConfiguration().gatewayConfiguration.applePayWeb;
	  var defaults = {
	    countryCode: applePay.countryCode,
	    currencyCode: applePay.currencyCode,
	    merchantCapabilities: applePay.merchantCapabilities || ['supports3DS'],
	    supportedNetworks: applePay.supportedNetworks.map(function (network) {
	      return network === 'mastercard' ? 'masterCard' : network;
	    })
	  };
	
	  return Object.assign({}, defaults, paymentRequest);
	};
	
	/**
	 * Validates your merchant website, as required by `ApplePaySession` before payment can be authorized.
	 * @public
	 * @param {object} options Options
	 * @param {string} options.validationURL The validationURL fram an `ApplePayValidateMerchantEvent`.
	 * @param {string} options.displayName The canonical name for your store. Use a non-localized name. This parameter should be a UTF-8 string that is a maximum of 128 characters. The system may display this name to the user.
	 * @param {callback} [callback] The second argument, <code>data</code>, is the Apple Pay merchant session object. If no callback is provided, `performValidation` returns a promise.
	 * Pass the merchant session to your Apple Pay session's `completeMerchantValidation` method.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * var applePay = require('braintree-web/apple-pay');
	 *
	 * applePay.create({client: clientInstance}, function (applePayErr, applePayInstance) {
	 *   if (applePayErr) {
	 *     // Handle error here
	 *     return;
	 *   }
	 *
	 *   var paymentRequest = applePayInstance.createPaymentRequest({
	 *     total: {
	 *       label: 'My Company',
	 *       amount: '19.99'
	 *     }
	 *   });
	 *   var session = new ApplePaySession(1, paymentRequest);
	 *
	 *   session.onvalidatemerchant = function (event) {
	 *     applePayInstance.performValidation({
	 *       validationURL: event.validationURL,
	 *       displayName: 'My Great Store'
	 *     }, function (validationErr, validationData) {
	 *       if (validationErr) {
	 *         console.error(validationErr);
	 *         session.abort();
	 *         return;
	 *       }
	 *
	 *       session.completeMerchantValidation(validationData);
	 *     });
	 *   };
	 * });
	 */
	ApplePay.prototype.performValidation = function (options) {
	  var applePayWebSession;
	  var self = this;
	
	  if (!options || !options.validationURL) {
	    return Promise.reject(new BraintreeError(errors.APPLE_PAY_VALIDATION_URL_REQUIRED));
	  }
	
	  applePayWebSession = {
	    validationUrl: options.validationURL,
	    domainName: options.domainName || global.location.hostname,
	    merchantIdentifier: options.merchantIdentifier || this.merchantIdentifier
	  };
	
	  if (options.displayName != null) {
	    applePayWebSession.displayName = options.displayName;
	  }
	
	  return this._client.request({
	    method: 'post',
	    endpoint: 'apple_pay_web/sessions',
	    data: {
	      _meta: {source: 'apple-pay'},
	      applePayWebSession: applePayWebSession
	    }
	  }).then(function (response) {
	    analytics.sendEvent(self._client, 'applepay.performValidation.succeeded');
	    return Promise.resolve(response);
	  }).catch(function (err) {
	    analytics.sendEvent(self._client, 'applepay.performValidation.failed');
	
	    if (err.code === 'CLIENT_REQUEST_ERROR') {
	      return Promise.reject(new BraintreeError({
	        type: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.type,
	        code: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.code,
	        message: errors.APPLE_PAY_MERCHANT_VALIDATION_FAILED.message,
	        details: {
	          originalError: err.details.originalError
	        }
	      }));
	    }
	
	    return Promise.reject(new BraintreeError({
	      type: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.type,
	      code: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.code,
	      message: errors.APPLE_PAY_MERCHANT_VALIDATION_NETWORK.message,
	      details: {
	        originalError: err
	      }
	    }));
	  });
	};
	
	/**
	 * Tokenizes an Apple Pay payment. This will likely be called in your `ApplePaySession`'s `onpaymentauthorized` callback.
	 * @public
	 * @param {object} options Options
	 * @param {object} options.token The `payment.token` property of an {@link external:ApplePayPaymentAuthorizedEvent}.
	 * @param {callback} [callback] The second argument, <code>data</code>, is the tokenized payload. If no callback is provided, `tokenize` returns a promise that resolves with the tokenized payload.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * var applePay = require('braintree-web/apple-pay');
	 *
	 * applePay.create({client: clientInstance}, function (applePayErr, applePayInstance) {
	 *   if (applePayErr) {
	 *     // Handle error here
	 *     return;
	 *   }
	 *
	 *   var paymentRequest = applePayInstance.createPaymentRequest({
	 *     total: {
	 *       label: 'My Company',
	 *       amount: '19.99'
	 *     }
	 *   });
	 *   var session = new ApplePaySession(1, paymentRequest);
	 *
	 *   session.onpaymentauthorized = function (event) {
	 *     applePayInstance.tokenize({
	 *       token: event.payment.token
	 *     }, function (tokenizeErr, tokenizedPayload) {
	 *       if (tokenizeErr) {
	 *         session.completePayment(ApplePaySession.STATUS_FAILURE);
	 *         return;
	 *       }
	 *       session.completePayment(ApplePaySession.STATUS_SUCCESS);
	 *
	 *       // Send the tokenizedPayload to your server here!
	 *     });
	 *   };
	 *
	 *   // ...
	 * });
	 */
	ApplePay.prototype.tokenize = function (options) {
	  var self = this;
	
	  if (!options.token) {
	    return Promise.reject(new BraintreeError(errors.APPLE_PAY_PAYMENT_TOKEN_REQUIRED));
	  }
	
	  return this._client.request({
	    method: 'post',
	    endpoint: 'payment_methods/apple_payment_tokens',
	    data: {
	      _meta: {
	        source: 'apple-pay'
	      },
	      applePaymentToken: Object.assign({}, options.token, {
	        // The gateway requires this key to be base64-encoded.
	        paymentData: btoa(JSON.stringify(options.token.paymentData))
	      })
	    }
	  }).then(function (response) {
	    analytics.sendEvent(self._client, 'applepay.tokenize.succeeded');
	    return Promise.resolve(response.applePayCards[0]);
	  }).catch(function (err) {
	    analytics.sendEvent(self._client, 'applepay.tokenize.failed');
	
	    return Promise.reject(new BraintreeError({
	      type: errors.APPLE_PAY_TOKENIZATION.type,
	      code: errors.APPLE_PAY_TOKENIZATION.code,
	      message: errors.APPLE_PAY_TOKENIZATION.message,
	      details: {
	        originalError: err
	      }
	    }));
	  });
	};
	
	module.exports = wrapPromise.wrapPrototype(ApplePay);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  APPLE_PAY_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'APPLE_PAY_NOT_ENABLED',
	    message: 'Apple Pay is not enabled for this merchant.'
	  },
	  APPLE_PAY_VALIDATION_URL_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'APPLE_PAY_VALIDATION_URL_REQUIRED',
	    message: 'performValidation must be called with a validationURL.'
	  },
	  APPLE_PAY_MERCHANT_VALIDATION_NETWORK: {
	    type: BraintreeError.types.NETWORK,
	    code: 'APPLE_PAY_MERCHANT_VALIDATION_NETWORK',
	    message: 'A network error occurred when validating the Apple Pay merchant.'
	  },
	  APPLE_PAY_MERCHANT_VALIDATION_FAILED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'APPLE_PAY_MERCHANT_VALIDATION_FAILED',
	    message: 'Make sure you have registered your domain name in the Braintree Control Panel.'
	  },
	  APPLE_PAY_PAYMENT_TOKEN_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'APPLE_PAY_PAYMENT_TOKEN_REQUIRED',
	    message: 'tokenize must be called with a payment token.'
	  },
	  APPLE_PAY_TOKENIZATION: {
	    type: BraintreeError.types.NETWORK,
	    code: 'APPLE_PAY_TOKENIZATION',
	    message: 'A network error occurred when processing the Apple Pay payment.'
	  }
	};


/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/** @module braintree-web/three-d-secure */
	
	var ThreeDSecure = __webpack_require__(533);
	var isHTTPS = __webpack_require__(537).isHTTPS;
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var errors = __webpack_require__(535);
	var sharedErrors = __webpack_require__(404);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link ThreeDSecure} instance. If no callback is provided, it returns a promise that resolves the {@link ThreeDSecure} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * braintree.threeDSecure.create({
	 *   client: client
	 * }, callback);
	 */
	function create(options) {
	  var config, error, clientVersion, isProduction;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating 3D Secure.'
	    }));
	  }
	
	  config = options.client.getConfiguration();
	  clientVersion = config.analyticsMetadata.sdkVersion;
	
	  if (!config.gatewayConfiguration.threeDSecureEnabled) {
	    error = errors.THREEDS_NOT_ENABLED;
	  } else if (config.analyticsMetadata.sdkVersion !== VERSION) {
	    error = {
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and 3D Secure (version ' + VERSION + ') components must be from the same SDK version.'
	    };
	  }
	
	  isProduction = config.gatewayConfiguration.environment === 'production';
	
	  if (isProduction && !isHTTPS()) {
	    error = errors.THREEDS_HTTPS_REQUIRED;
	  }
	
	  if (error) {
	    return Promise.reject(new BraintreeError(error));
	  }
	
	  analytics.sendEvent(options.client, 'threedsecure.initialized');
	
	  return Promise.resolve(new ThreeDSecure(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var methods = __webpack_require__(440);
	var convertMethodsToError = __webpack_require__(441);
	var constants = __webpack_require__(534);
	var useMin = __webpack_require__(438);
	var Bus = __webpack_require__(433);
	var uuid = __webpack_require__(384);
	var deferred = __webpack_require__(401);
	var errors = __webpack_require__(535);
	var events = __webpack_require__(536);
	var VERSION = "3.14.0";
	var iFramer = __webpack_require__(423);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	var IFRAME_HEIGHT = 400;
	var IFRAME_WIDTH = 400;
	
	/**
	 * @typedef {object} ThreeDSecure~verifyPayload
	 * @property {string} nonce The new payment method nonce produced by the 3D Secure lookup. The original nonce passed into {@link ThreeDSecure#verifyCard|verifyCard} was consumed. This new nonce should be used to transact on your server.
	 * @property {object} details Additional account details.
	 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
	 * @property {string} details.lastTwo Last two digits of card number.
	 * @property {string} description A human-readable description.
	 * @property {boolean} liabilityShiftPossible Indicates whether the card was eligible for 3D Secure.
	 * @property {boolean} liabilityShifted Indicates whether the liability for fraud has been shifted away from the merchant.
	 */
	
	/**
	 * @class
	 * @param {object} options 3D Secure {@link module:braintree-web/three-d-secure.create create} options
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/three-d-secure.create|braintree.threeDSecure.create} instead.</strong>
	 * @classdesc This class represents a ThreeDSecure component produced by {@link module:braintree-web/three-d-secure.create|braintree.threeDSecure.create}. Instances of this class have a method for launching a 3D Secure authentication flow.
	 */
	function ThreeDSecure(options) {
	  this._options = options;
	  this._assetsUrl = options.client.getConfiguration().gatewayConfiguration.assetsUrl;
	  this._isDebug = options.client.getConfiguration().isDebug;
	  this._client = options.client;
	}
	
	/**
	 * @callback ThreeDSecure~addFrameCallback
	 * @param {?BraintreeError} [err] `null` or `undefined` if there was no error.
	 * @param {HTMLIFrameElement} iframe An iframe element containing the bank's authentication page that you must put on your page.
	 * @description The callback used for options.addFrame in {@link ThreeDSecure#verifyCard|verifyCard}.
	 * @returns {void}
	 */
	
	/**
	 * @callback ThreeDSecure~removeFrameCallback
	 * @description The callback used for options.removeFrame in {@link ThreeDSecure#verifyCard|verifyCard}.
	 * @returns {void}
	 */
	
	/**
	 * Launch the 3D Secure login flow, returning a nonce payload.
	 * @public
	 * @param {object} options Options for card verification.
	 * @param {string} options.nonce A nonce referencing the card to be verified. For example, this can be a nonce that was returned by Hosted Fields.
	 * @param {number} options.amount The amount of the transaction in the current merchant account's currency. For example, if you are running a transaction of $123.45 US dollars, `amount` would be 123.45.
	 * @param {errback} options.addFrame This {@link ThreeDSecure~addFrameCallback|addFrameCallback} will be called when the bank frame needs to be added to your page.
	 * @param {callback} options.removeFrame This {@link ThreeDSecure~removeFrameCallback|removeFrameCallback} will be called when the bank frame needs to be removed from your page.
	 * @param {errback} [callback] The second argument, <code>data</code>, is a {@link ThreeDSecure~verifyPayload|verifyPayload}. If no callback is provided, it will return a promise that resolves {@link ThreeDSecure~verifyPayload|verifyPayload}.
	
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * <caption>Verifying an existing nonce with 3DS</caption>
	 * var my3DSContainer;
	 *
	 * threeDSecure.verifyCard({
	 *   nonce: existingNonce,
	 *   amount: 123.45,
	 *   addFrame: function (err, iframe) {
	 *     // Set up your UI and add the iframe.
	 *     my3DSContainer = document.createElement('div');
	 *     my3DSContainer.appendChild(iframe);
	 *     document.body.appendChild(my3DSContainer);
	 *   },
	 *   removeFrame: function () {
	 *     // Remove UI that you added in addFrame.
	 *     document.body.removeChild(my3DSContainer);
	 *   }
	 * }, function (err, payload) {
	 *   if (err) {
	 *     console.error(err);
	 *     return;
	 *   }
	 *
	 *   if (payload.liabilityShifted) {
	 *     // Liablity has shifted
	 *     submitNonceToServer(payload.nonce);
	 *   } else if (payload.liabilityShiftPossible) {
	 *     // Liablity may still be shifted
	 *     // Decide if you want to submit the nonce
	 *   } else {
	 *     // Liablity has not shifted and will not shift
	 *     // Decide if you want to submit the nonce
	 *   }
	 * });
	 */
	ThreeDSecure.prototype.verifyCard = function (options) {
	  var url, addFrame, removeFrame, error, errorOption;
	  var self = this;
	
	  options = options || {};
	
	  if (this._verifyCardInProgress === true) {
	    error = errors.THREEDS_AUTHENTICATION_IN_PROGRESS;
	  } else if (!options.nonce) {
	    errorOption = 'a nonce';
	  } else if (!options.amount) {
	    errorOption = 'an amount';
	  } else if (typeof options.addFrame !== 'function') {
	    errorOption = 'an addFrame function';
	  } else if (typeof options.removeFrame !== 'function') {
	    errorOption = 'a removeFrame function';
	  }
	
	  if (errorOption) {
	    error = {
	      type: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.type,
	      code: errors.THREEDS_MISSING_VERIFY_CARD_OPTION.code,
	      message: 'verifyCard options must include ' + errorOption + '.'
	    };
	  }
	
	  if (error) {
	    return Promise.reject(new BraintreeError(error));
	  }
	
	  this._verifyCardInProgress = true;
	
	  addFrame = deferred(options.addFrame);
	  removeFrame = deferred(options.removeFrame);
	
	  url = 'payment_methods/' + options.nonce + '/three_d_secure/lookup';
	
	  return this._client.request({
	    endpoint: url,
	    method: 'post',
	    data: {amount: options.amount}
	  }).then(function (response) {
	    self._lookupPaymentMethod = response.paymentMethod;
	
	    return new Promise(function (resolve, reject) {
	      self._verifyCardCallback = function (verifyErr, payload) {
	        self._verifyCardInProgress = false;
	
	        if (verifyErr) {
	          reject(verifyErr);
	        } else {
	          resolve(payload);
	        }
	      };
	
	      self._handleLookupResponse({
	        lookupResponse: response,
	        addFrame: addFrame,
	        removeFrame: removeFrame
	      });
	    });
	  }).catch(function (err) {
	    self._verifyCardInProgress = false;
	    return Promise.reject(err);
	  });
	};
	
	/**
	 * Cancel the 3DS flow and return the verification payload if available.
	 * @public
	 * @param {errback} [callback] The second argument is a {@link ThreeDSecure~verifyPayload|verifyPayload}. If there is no verifyPayload (the initial lookup did not complete), an error will be returned. If no callback is passed, `cancelVerifyCard` will return a promise.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * threeDSecure.cancelVerifyCard(function (err, verifyPayload) {
	 *   if (err) {
	 *     // Handle error
	 *     console.log(err.message); // No verification payload available
	 *     return;
	 *   }
	 *
	 *   verifyPayload.nonce; // The nonce returned from the 3ds lookup call
	 *   verifyPayload.liabilityShifted; // boolean
	 *   verifyPayload.liabilityShiftPossible; // boolean
	 * });
	 */
	ThreeDSecure.prototype.cancelVerifyCard = function () {
	  this._verifyCardInProgress = false;
	
	  if (!this._lookupPaymentMethod) {
	    return Promise.reject(new BraintreeError(errors.THREEDS_NO_VERIFICATION_PAYLOAD));
	  }
	
	  return Promise.resolve(this._lookupPaymentMethod);
	};
	
	ThreeDSecure.prototype._handleLookupResponse = function (options) {
	  var lookupResponse = options.lookupResponse;
	
	  if (lookupResponse.lookup && lookupResponse.lookup.acsUrl && lookupResponse.lookup.acsUrl.length > 0) {
	    options.addFrame(null, this._createIframe({
	      response: lookupResponse.lookup,
	      removeFrame: options.removeFrame
	    }));
	  } else {
	    this._verifyCardCallback(null, {
	      nonce: lookupResponse.paymentMethod.nonce,
	      verificationDetails: lookupResponse.threeDSecureInfo
	    });
	  }
	};
	
	ThreeDSecure.prototype._createIframe = function (options) {
	  var url, authenticationCompleteBaseUrl;
	  var parentURL = window.location.href;
	  var response = options.response;
	
	  this._bus = new Bus({
	    channel: uuid(),
	    merchantUrl: location.href
	  });
	
	  authenticationCompleteBaseUrl = this._assetsUrl + '/web/' + VERSION + '/html/three-d-secure-authentication-complete-frame.html?channel=' + encodeURIComponent(this._bus.channel) + '&';
	
	  if (parentURL.indexOf('#') > -1) {
	    parentURL = parentURL.split('#')[0];
	  }
	
	  this._bus.on(Bus.events.CONFIGURATION_REQUEST, function (reply) {
	    reply({
	      acsUrl: response.acsUrl,
	      pareq: response.pareq,
	      termUrl: response.termUrl + '&three_d_secure_version=' + VERSION + '&authentication_complete_base_url=' + encodeURIComponent(authenticationCompleteBaseUrl),
	      md: response.md,
	      parentUrl: parentURL
	    });
	  });
	
	  this._bus.on(events.AUTHENTICATION_COMPLETE, function (data) {
	    this._handleAuthResponse(data, options);
	  }.bind(this));
	
	  url = this._assetsUrl + '/web/' + VERSION + '/html/three-d-secure-bank-frame' + useMin(this._isDebug) + '.html';
	
	  this._bankIframe = iFramer({
	    src: url,
	    height: IFRAME_HEIGHT,
	    width: IFRAME_WIDTH,
	    name: constants.LANDING_FRAME_NAME + '_' + this._bus.channel
	  });
	
	  return this._bankIframe;
	};
	
	ThreeDSecure.prototype._handleAuthResponse = function (data, options) {
	  var authResponse = JSON.parse(data.auth_response);
	
	  this._bus.teardown();
	
	  options.removeFrame();
	
	  // This also has to be in a setTimeout so it executes after the `removeFrame`.
	  deferred(function () {
	    if (authResponse.success) {
	      this._verifyCardCallback(null, this._formatAuthResponse(authResponse.paymentMethod, authResponse.threeDSecureInfo));
	    } else if (authResponse.threeDSecureInfo && authResponse.threeDSecureInfo.liabilityShiftPossible) {
	      this._verifyCardCallback(null, this._formatAuthResponse(this._lookupPaymentMethod, authResponse.threeDSecureInfo));
	    } else {
	      this._verifyCardCallback(new BraintreeError({
	        type: BraintreeError.types.UNKNOWN,
	        code: 'UNKNOWN_AUTH_RESPONSE',
	        message: authResponse.error.message
	      }));
	    }
	  }.bind(this))();
	};
	
	ThreeDSecure.prototype._formatAuthResponse = function (paymentMethod, threeDSecureInfo) {
	  return {
	    nonce: paymentMethod.nonce,
	    details: paymentMethod.details,
	    description: paymentMethod.description,
	    liabilityShifted: threeDSecureInfo.liabilityShifted,
	    liabilityShiftPossible: threeDSecureInfo.liabilityShiftPossible
	  };
	};
	
	/**
	 * Cleanly remove anything set up by {@link module:braintree-web/three-d-secure.create|create}.
	 * @public
	 * @param {callback} [callback] Called on completion. If no callback is passed, `teardown` will return a promise.
	 * @example
	 * threeDSecure.teardown();
	 * @example <caption>With callback</caption>
	 * threeDSecure.teardown(function () {
	 *   // teardown is complete
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	ThreeDSecure.prototype.teardown = function () {
	  var iframeParent;
	
	  convertMethodsToError(this, methods(ThreeDSecure.prototype));
	
	  analytics.sendEvent(this._options.client, 'threedsecure.teardown-completed');
	
	  if (this._bus) {
	    this._bus.teardown();
	  }
	
	  if (this._bankIframe) {
	    iframeParent = this._bankIframe.parentNode;
	
	    if (iframeParent) {
	      iframeParent.removeChild(this._bankIframe);
	    }
	  }
	
	  return Promise.resolve();
	};
	
	module.exports = wrapPromise.wrapPrototype(ThreeDSecure);


/***/ },
/* 534 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  LANDING_FRAME_NAME: 'braintreethreedsecurelanding'
	};


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  THREEDS_AUTHENTICATION_IN_PROGRESS: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'THREEDS_AUTHENTICATION_IN_PROGRESS',
	    message: 'Cannot call verifyCard while existing authentication is in progress.'
	  },
	  THREEDS_MISSING_VERIFY_CARD_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'THREEDS_MISSING_VERIFY_CARD_OPTION'
	  },
	  THREEDS_NO_VERIFICATION_PAYLOAD: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'THREEDS_NO_VERIFICATION_PAYLOAD',
	    message: 'No verification payload available.'
	  },
	  THREEDS_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'THREEDS_NOT_ENABLED',
	    message: '3D Secure is not enabled for this merchant.'
	  },
	  THREEDS_HTTPS_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'THREEDS_HTTPS_REQUIRED',
	    message: '3D Secure requires HTTPS.'
	  },
	  THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN: {
	    type: BraintreeError.types.INTERNAL,
	    code: 'THREEDS_TERM_URL_REQUIRES_BRAINTREE_DOMAIN',
	    message: 'Term Url must be on a Braintree domain.'
	  }
	};


/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enumerate = __webpack_require__(379);
	
	module.exports = enumerate([
	  'AUTHENTICATION_COMPLETE'
	], 'threedsecure:');


/***/ },
/* 537 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	function isHTTPS(protocol) {
	  protocol = protocol || global.location.protocol;
	  return protocol === 'https:';
	}
	
	module.exports = {
	  isHTTPS: isHTTPS
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module braintree-web/us-bank-account
	 * @description This module is for accepting payments of US bank accounts.
	 */
	
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(539);
	var USBankAccount = __webpack_require__(540);
	var VERSION = "3.14.0";
	var sharedErrors = __webpack_require__(404);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link USBankAccount} instance. If no callback is provided, `create` returns a promise that resolves with the {@link USBankAccount} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var clientVersion, braintreeApi, usBankAccount;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating US Bank Account.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and US Bank Account (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  braintreeApi = options.client.getConfiguration().gatewayConfiguration.braintreeApi;
	  if (!braintreeApi) {
	    return Promise.reject(new BraintreeError(sharedErrors.BRAINTREE_API_ACCESS_RESTRICTED));
	  }
	
	  usBankAccount = options.client.getConfiguration().gatewayConfiguration.usBankAccount;
	  if (!usBankAccount) {
	    return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_NOT_ENABLED));
	  }
	
	  return Promise.resolve(new USBankAccount(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  US_BANK_ACCOUNT_OPTION_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'US_BANK_ACCOUNT_OPTION_REQUIRED'
	  },
	  US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS'
	  },
	  US_BANK_ACCOUNT_LOGIN_LOAD_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'US_BANK_ACCOUNT_LOGIN_LOAD_FAILED',
	    message: 'Bank login flow failed to load.'
	  },
	  US_BANK_ACCOUNT_LOGIN_CLOSED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'US_BANK_ACCOUNT_LOGIN_CLOSED',
	    message: 'Customer closed bank login flow before authorizing.'
	  },
	  US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE',
	    message: 'Another bank login tokenization request is active.'
	  },
	  US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR: {
	    type: BraintreeError.types.NETWORK,
	    code: 'US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR',
	    message: 'A tokenization network error occurred.'
	  },
	  US_BANK_ACCOUNT_FAILED_TOKENIZATION: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'US_BANK_ACCOUNT_FAILED_TOKENIZATION',
	    message: 'The supplied data failed tokenization.'
	  },
	  US_BANK_ACCOUNT_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'US_BANK_ACCOUNT_NOT_ENABLED',
	    message: 'US bank account is not enabled.'
	  },
	  US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED',
	    message: 'Bank login is not enabled.'
	  }
	};


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var constants = __webpack_require__(541);
	var errors = __webpack_require__(539);
	var sharedErrors = __webpack_require__(404);
	var analytics = __webpack_require__(411);
	var once = __webpack_require__(382);
	var convertMethodsToError = __webpack_require__(441);
	var methods = __webpack_require__(440);
	var camelCaseToSnakeCase = __webpack_require__(517);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @typedef {object} USBankAccount~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {string} type The payment method type, always `us_bank_account`.
	 * @property {object} details Additional account details. Currently empty.
	 */
	
	/**
	 * @class
	 * @param {object} options See {@link module:braintree-web/us-bank-account.create|us-bank-account.create}.
	 * @classdesc This class represents a US Bank Account component. Instances of this class can tokenize raw bank details or present a bank login. <strong>You cannot use this constructor directly. Use {@link module:braintree-web/us-bank-account.create|braintree.us-bank-account.create} instead.</strong>
	 */
	function USBankAccount(options) {
	  this._client = options.client;
	
	  this._isTokenizingBankLogin = false;
	
	  analytics.sendEvent(this._client, 'usbankaccount.initialized');
	}
	
	/**
	 * Tokenizes bank information to return a payment method nonce. You can tokenize bank details by providing information like account and routing numbers. You can also tokenize with a bank login UI that prompts the customer to log into their bank account.
	 * @public
	 * @param {object} options All tokenization options for the US Bank Account component.
	 * @param {string} options.mandateText A string for proof of customer authorization. For example, `'I authorize Braintree to debit my bank account on behalf of My Online Store.'`.
	 * @param {object} [options.bankDetails] Bank detail information (such as account and routing numbers). `bankDetails` or `bankLogin` option must be provided.
	 * @param {string} options.bankDetails.routingNumber The customer's bank routing number, such as `'307075259'`.
	 * @param {string} options.bankDetails.accountNumber The customer's bank account number, such as `'999999999'`.
	 * @param {string} options.bankDetails.accountType The customer's bank account type. Must be `'checking'` or `'savings'`.
	 * @param {string} options.bankDetails.ownershipType The customer's bank account ownership type. Must be `'personal'` or `'business'`.
	 * @param {string} [options.bankDetails.firstName] The customer's first name. Required when account ownership type is `personal`.
	 * @param {string} [options.bankDetails.lastName] The customer's last name. Required when account ownership type is `personal`.
	 * @param {string} [options.bankDetails.businessName] The customer's business name. Required when account ownership type is `business`.
	 * @param {object} options.bankDetails.billingAddress The customer's billing address.
	 * @param {string} options.bankDetails.billingAddress.streetAddress The street address for the customer's billing address, such as `'123 Fake St'`.
	 * @param {string} [options.bankDetails.billingAddress.extendedAddress] The extended street address for the customer's billing address, such as `'Apartment B'`.
	 * @param {string} options.bankDetails.billingAddress.locality The locality for the customer's billing address. This is typically a city, such as `'San Francisco'`.
	 * @param {string} options.bankDetails.billingAddress.region The region for the customer's billing address. This is typically a state, such as `'CA'`.
	 * @param {string} options.bankDetails.billingAddress.postalCode The postal code for the customer's billing address. This is typically a ZIP code, such as `'94119'`.
	 * @param {object} [options.bankLogin] Bank login information. `bankLogin` or `bankDetails` option must be provided.
	 * @param {string} options.bankLogin.displayName Display name for the bank login UI, such as `'My Store'`.
	 * @param {string} options.bankLogin.ownershipType The customer's bank account ownership type. Must be `'personal'` or `'business'`.
	 * @param {string} [options.bankLogin.firstName] The customer's first name. Required when account ownership type is `personal`.
	 * @param {string} [options.bankLogin.lastName] The customer's last name. Required when account ownership type is `personal`.
	 * @param {string} [options.bankLogin.businessName] The customer's business name. Required when account ownership type is `business`.
	 * @param {object} options.bankLogin.billingAddress The customer's billing address.
	 * @param {string} options.bankLogin.billingAddress.streetAddress The street address for the customer's billing address, such as `'123 Fake St'`.
	 * @param {string} [options.bankLogin.billingAddress.extendedAddress] The extended street address for the customer's billing address, such as `'Apartment B'`.
	 * @param {string} options.bankLogin.billingAddress.locality The locality for the customer's billing address. This is typically a city, such as `'San Francisco'`.
	 * @param {string} options.bankLogin.billingAddress.region The region for the customer's billing address. This is typically a state, such as `'CA'`.
	 * @param {string} options.bankLogin.billingAddress.postalCode The postal code for the customer's billing address. This is typically a ZIP code, such as `'94119'`.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link USBankAccount~tokenizePayload|tokenizePayload}. If no callback is provided, `tokenize` returns a promise that resolves with {@link USBankAccount~tokenizePayload|tokenizePayload}.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * <caption>Tokenizing raw bank details</caption>
	 * var routingNumberInput = document.querySelector('input[name="routing-number"]');
	 * var accountNumberInput = document.querySelector('input[name="account-number"]');
	 * var accountTypeInput = document.querySelector('input[name="account-type"]:checked');
	 * var ownershipTypeInput = document.querySelector('input[name="ownership-type"]:checked');
	 * var firstNameInput = document.querySelector('input[name="first-name"]');
	 * var lastNameInput = document.querySelector('input[name="last-name"]');
	 * var businessNameInput = document.querySelector('input[name="business-name"]');
	 * var billingAddressStreetInput = document.querySelector('input[name="street-address"]');
	 * var billingAddressExtendedInput = document.querySelector('input[name="extended-address"]');
	 * var billingAddressLocalityInput = document.querySelector('input[name="locality"]');
	 * var billingAddressRegionSelect = document.querySelector('select[name="region"]');
	 * var billingAddressPostalInput = document.querySelector('input[name="postal-code"]');
	 *
	 * submitButton.addEventListener('click', function (event) {
	 *   var bankDetails = {
	 *     routingNumber: routingNumberInput.value,
	 *     accountNumber: accountNumberInput.value,
	 *     accountType: accountTypeInput.value,
	 *     ownershipType: ownershipTypeInput.value,
	 *     billingAddress: {
	 *       streetAddress: billingAddressStreetInput.value,
	 *       extendedAddress: billingAddressExtendedInput.value,
	 *       locality: billingAddressLocalityInput.value,
	 *       region: billingAddressRegionSelect.value,
	 *       postalCode: billingAddressPostalInput.value
	 *     }
	 *   };
	 *
	 *   if (bankDetails.ownershipType === 'personal') {
	 *     bankDetails.firstName = firstNameInput.value;
	 *     bankDetails.lastName = lastNameInput.value;
	 *   } else {
	 *     bankDetails.businessName = businessNameInput.value;
	 *   }
	 *
	 *   event.preventDefault();
	 *
	 *   usBankAccountInstance.tokenize({
	 *     bankDetails: bankDetails,
	 *     mandateText: 'I authorize Braintree to debit my bank account on behalf of My Online Store.'
	 *   }, function (tokenizeErr, tokenizedPayload) {
	 *     if (tokenizeErr) {
	 *       console.error('There was an error tokenizing the bank details.');
	 *       return;
	 *     }
	 *
	 *     // Send tokenizePayload.nonce to your server here!
	 *   });
	 * });
	 * @example
	 * <caption>Tokenizing with bank login UI</caption>
	 * var ownershipTypeInput = document.querySelector('input[name="ownership-type"]:checked');
	 * var firstNameInput = document.querySelector('input[name="first-name"]');
	 * var lastNameInput = document.querySelector('input[name="last-name"]');
	 * var businessNameInput = document.querySelector('input[name="business-name"]');
	 * var billingAddressStreetInput = document.querySelector('input[name="street-address"]');
	 * var billingAddressExtendedInput = document.querySelector('input[name="extended-address"]');
	 * var billingAddressLocalityInput = document.querySelector('input[name="locality"]');
	 * var billingAddressRegionSelect = document.querySelector('select[name="region"]');
	 * var billingAddressPostalInput = document.querySelector('input[name="postal-code"]');
	 *
	 * bankLoginButton.addEventListener('click', function (event) {
	 *   var bankLogin = {
	 *     displayName: 'My Online Store',
	 *     ownershipType: ownershipTypeInput.value,
	 *     billingAddress: {
	 *       streetAddress: billingAddressStreetInput.value,
	 *       extendedAddress: billingAddressExtendedInput.value,
	 *       locality: billingAddressLocalityInput.value,
	 *       region: billingAddressRegionSelect.value,
	 *       postalCode: billingAddressPostalInput.value
	 *     }
	 *   }
	 *   event.preventDefault();
	 *
	 *   if (bankLogin.ownershipType === 'personal') {
	 *     bankLogin.firstName = firstNameInput.value;
	 *     bankLogin.lastName = lastNameInput.value;
	 *   } else {
	 *     bankLogin.businessName = businessNameInput.value;
	 *   }
	 *
	 *   usBankAccountInstance.tokenize({
	 *     bankLogin: bankLogin,
	 *     mandateText: 'I authorize Braintree to debit my bank account on behalf of My Online Store.'
	 *   }, function (tokenizeErr, tokenizedPayload) {
	 *     if (tokenizeErr) {
	 *       console.error('There was an error tokenizing the bank details.');
	 *       return;
	 *     }
	 *
	 *     // Send tokenizePayload.nonce to your server here!
	 *   });
	 * });
	 */
	USBankAccount.prototype.tokenize = function (options) {
	  options = options || {};
	
	  if (!options.mandateText) {
	    return Promise.reject(new BraintreeError({
	      type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
	      code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
	      message: 'mandateText property is required.'
	    }));
	  }
	
	  if (options.bankDetails && options.bankLogin) {
	    return Promise.reject(new BraintreeError({
	      type: errors.US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS.type,
	      code: errors.US_BANK_ACCOUNT_MUTUALLY_EXCLUSIVE_OPTIONS.code,
	      message: 'tokenize must be called with bankDetails or bankLogin, not both.'
	    }));
	  } else if (options.bankDetails) {
	    return this._tokenizeBankDetails(options);
	  } else if (options.bankLogin) {
	    return this._tokenizeBankLogin(options);
	  }
	
	  return Promise.reject(new BraintreeError({
	    type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
	    code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
	    message: 'tokenize must be called with bankDetails or bankLogin.'
	  }));
	};
	
	USBankAccount.prototype._tokenizeBankDetails = function (options) {
	  var client = this._client;
	  var bankDetails = options.bankDetails;
	
	  return client.request({
	    method: 'POST',
	    endpoint: 'tokens',
	    api: 'braintreeApi',
	    data: camelCaseToSnakeCase({
	      type: 'us_bank_account',
	      routingNumber: bankDetails.routingNumber,
	      accountNumber: bankDetails.accountNumber,
	      firstName: bankDetails.firstName,
	      lastName: bankDetails.lastName,
	      businessName: bankDetails.businessName,
	      accountType: bankDetails.accountType,
	      ownershipType: bankDetails.ownershipType,
	      billingAddress: camelCaseToSnakeCase(bankDetails.billingAddress || {}),
	      achMandate: {
	        text: options.mandateText
	      }
	    })
	  }).then(function (response) {
	    analytics.sendEvent(client, 'usbankaccount.bankdetails.tokenization.succeeded');
	
	    return Promise.resolve(formatTokenizeResponse(response));
	  }).catch(function (err) {
	    var error = errorFrom(err);
	
	    analytics.sendEvent(client, 'usbankaccount.bankdetails.tokenization.failed');
	
	    return Promise.reject(error);
	  });
	};
	
	USBankAccount.prototype._tokenizeBankLogin = function (options) {
	  var self = this;
	  var client = this._client;
	  var gatewayConfiguration = client.getConfiguration().gatewayConfiguration;
	  var isProduction = gatewayConfiguration.environment === 'production';
	  var plaidConfig = gatewayConfiguration.usBankAccount.plaid;
	
	  if (!options.bankLogin.displayName) {
	    return Promise.reject(new BraintreeError({
	      type: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.type,
	      code: errors.US_BANK_ACCOUNT_OPTION_REQUIRED.code,
	      message: 'displayName property is required when using bankLogin.'
	    }));
	  }
	
	  if (!plaidConfig) {
	    return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_BANK_LOGIN_NOT_ENABLED));
	  }
	
	  if (this._isTokenizingBankLogin) {
	    return Promise.reject(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_REQUEST_ACTIVE));
	  }
	  this._isTokenizingBankLogin = true;
	
	  return new Promise(function (resolve, reject) {
	    self._loadPlaid(function (plaidLoadErr, plaid) {
	      if (plaidLoadErr) {
	        reject(plaidLoadErr);
	        return;
	      }
	
	      plaid.create({
	        clientName: options.bankLogin.displayName,
	        env: isProduction ? 'production' : 'tartan',
	        key: isProduction ? plaidConfig.publicKey : 'test_key',
	        product: 'auth',
	        selectAccount: true,
	        onExit: function () {
	          self._isTokenizingBankLogin = false;
	
	          analytics.sendEvent(client, 'usbankaccount.banklogin.tokenization.closed.by-user');
	
	          reject(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_CLOSED));
	        },
	        onSuccess: function (publicToken, metadata) {
	          client.request({
	            method: 'POST',
	            endpoint: 'tokens',
	            api: 'braintreeApi',
	            data: camelCaseToSnakeCase({
	              type: 'plaid_public_token',
	              publicToken: publicToken,
	              accountId: metadata.account_id,
	              achMandate: {
	                text: options.mandateText
	              },
	              ownershipType: options.bankLogin.ownershipType,
	              firstName: options.bankLogin.firstName,
	              lastName: options.bankLogin.lastName,
	              businessName: options.bankLogin.businessName,
	              billingAddress: camelCaseToSnakeCase(options.bankLogin.billingAddress || {})
	            })
	          }).then(function (response) {
	            self._isTokenizingBankLogin = false;
	
	            analytics.sendEvent(client, 'usbankaccount.banklogin.tokenization.succeeded');
	
	            resolve(formatTokenizeResponse(response));
	          }).catch(function (tokenizeErr) {
	            var error;
	
	            self._isTokenizingBankLogin = false;
	            error = errorFrom(tokenizeErr);
	
	            analytics.sendEvent(client, 'usbankaccount.banklogin.tokenization.failed');
	
	            reject(error);
	          });
	        }
	      }).open();
	
	      analytics.sendEvent(client, 'usbankaccount.banklogin.tokenization.started');
	    });
	  });
	};
	
	function errorFrom(err) {
	  var error;
	  var status = err.details && err.details.httpStatus;
	
	  if (status === 401) {
	    error = new BraintreeError(sharedErrors.BRAINTREE_API_ACCESS_RESTRICTED);
	  } else if (status < 500) {
	    error = new BraintreeError(errors.US_BANK_ACCOUNT_FAILED_TOKENIZATION);
	  } else {
	    error = new BraintreeError(errors.US_BANK_ACCOUNT_TOKENIZATION_NETWORK_ERROR);
	  }
	  error.details = {originalError: err};
	  return error;
	}
	
	function formatTokenizeResponse(response) {
	  return {
	    nonce: response.data.id,
	    details: {},
	    description: response.data.description,
	    type: response.data.type
	  };
	}
	
	USBankAccount.prototype._loadPlaid = function (callback) {
	  var existingScript, script;
	
	  callback = once(callback);
	
	  if (global.Plaid) {
	    callback(null, global.Plaid);
	    return;
	  }
	
	  existingScript = document.querySelector('script[src="' + constants.PLAID_LINK_JS + '"]');
	
	  if (existingScript) {
	    addLoadListeners(existingScript, callback);
	  } else {
	    script = document.createElement('script');
	
	    script.src = constants.PLAID_LINK_JS;
	    script.async = true;
	
	    addLoadListeners(script, callback);
	
	    document.body.appendChild(script);
	
	    this._plaidScript = script;
	  }
	};
	
	function addLoadListeners(script, callback) {
	  function loadHandler() {
	    var readyState = this.readyState; // eslint-disable-line no-invalid-this
	
	    if (!readyState || readyState === 'loaded' || readyState === 'complete') {
	      removeLoadListeners();
	      callback(null, global.Plaid);
	    }
	  }
	
	  function errorHandler() {
	    script.parentNode.removeChild(script);
	
	    callback(new BraintreeError(errors.US_BANK_ACCOUNT_LOGIN_LOAD_FAILED));
	  }
	
	  function removeLoadListeners() {
	    script.removeEventListener('error', errorHandler);
	    script.removeEventListener('load', loadHandler);
	    script.removeEventListener('readystatechange', loadHandler);
	  }
	
	  script.addEventListener('error', errorHandler);
	  script.addEventListener('load', loadHandler);
	  script.addEventListener('readystatechange', loadHandler);
	}
	
	/**
	 * Cleanly tear down anything set up by {@link module:braintree-web/us-bank-account.create|create}.
	 * @public
	 * @param {callback} [callback] Called once teardown is complete. No data is returned if teardown completes successfully.
	 * @example
	 * usBankAccountInstance.teardown();
	 * @example <caption>With callback</caption>
	 * usBankAccountInstance.teardown(function () {
	 *   // teardown is complete
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	USBankAccount.prototype.teardown = function () {
	  if (this._plaidScript) {
	    document.body.removeChild(this._plaidScript);
	  }
	
	  convertMethodsToError(this, methods(USBankAccount.prototype));
	
	  return Promise.resolve();
	};
	
	module.exports = wrapPromise.wrapPrototype(USBankAccount);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 541 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  PLAID_LINK_JS: 'https://cdn.plaid.com/link/v2/stable/link-initialize.js'
	};


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * @module braintree-web/visa-checkout
	 * @description Processes Visa Checkout. *This component is currently in beta and is subject to change.*
	 */
	
	var BraintreeError = __webpack_require__(378);
	var VisaCheckout = __webpack_require__(543);
	var analytics = __webpack_require__(411);
	var sharedErrors = __webpack_require__(404);
	var errors = __webpack_require__(544);
	var VERSION = "3.14.0";
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link VisaCheckout} instance. If no callback is provided, `create` returns a promise that resolves with the {@link VisaCheckout} instance.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var clientVersion;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Visa Checkout.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Visa Checkout (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (!options.client.getConfiguration().gatewayConfiguration.visaCheckout) {
	    return Promise.reject(new BraintreeError(errors.VISA_CHECKOUT_NOT_ENABLED));
	  }
	
	  analytics.sendEvent(options.client, 'visacheckout.initialized');
	
	  return Promise.resolve(new VisaCheckout(options));
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	var analytics = __webpack_require__(411);
	var errors = __webpack_require__(544);
	var jsonClone = __webpack_require__(397);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	var cardTypeTransformMap = {
	  Visa: 'VISA',
	  MasterCard: 'MASTERCARD',
	  Discover: 'DISCOVER',
	  'American Express': 'AMEX'
	};
	
	/**
	 * Visa Checkout Address object.
	 * @typedef {object} VisaCheckout~Address
	 * @property {string} countryCode The customer's country code.
	 * @property {string} extendedAddress The customer's extended address.
	 * @property {string} firstName The customer's first name.
	 * @property {string} lastName The customer's last name.
	 * @property {string} locality The customer's locality.
	 * @property {string} postalCode The customer's postal code.
	 * @property {string} region The customer's region.
	 * @property {string} streetAddress The customer's street address.
	 * @property {string} phoneNumber The customer's phone number.
	 */
	
	/**
	 * Visa Checkout UserData object.
	 * @typedef {object} VisaCheckout~UserData
	 * @property {string} userEmail The customer's email address.
	 * @property {string} userFirstName The customer's first name.
	 * @property {string} userLastName The customer's last name.
	 * @property {string} userFullName The customer's full name.
	 * @property {string} userName The customer's username.
	 */
	
	/**
	 * Visa Checkout tokenize payload.
	 * @typedef {object} VisaCheckout~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {object} details Additional account details.
	 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
	 * @property {string} details.lastTwo Last two digits of card number.
	 * @property {string} description A human-readable description.
	 * @property {string} type The payment method type, always `VisaCheckoutCard`.
	 * @property {VisaCheckout~Address} billingAddress The customer's billing address.
	 * @property {VisaCheckout~Address} shippingAddress The customer's shipping address.
	 * @property {VisaCheckout~UserData} userData Information about the customer.
	 */
	
	/**
	 * @class
	 * @param {object} options The Visa Checkout {@link module:braintree-web/visa-checkout.create create} options.
	 * @description <strong>Do not use this constructor directly. Use {@link module:braintree-web/visa-checkout.create|braintree-web.visa-checkout.create} instead.</strong>
	 * @classdesc This class represents a Visa Checkout component produced by {@link module:braintree-web/visa-checkout.create|braintree-web/visa-checkout.create}. Instances of this class have methods for interacting with Visa Checkout's JavaScript library.
	 */
	function VisaCheckout(options) {
	  this._client = options.client;
	}
	
	function transformCardTypes(cardTypes) {
	  return cardTypes.reduce(function (acc, type) {
	    if (cardTypeTransformMap.hasOwnProperty(type)) {
	      return acc.concat(cardTypeTransformMap[type]);
	    }
	
	    return acc;
	  }, []);
	}
	
	/**
	 * Creates an `initOptions` object from the passed `options`, applying properties that Braintree needs to transact Visa Checkout.
	 *
	 * Braintree will apply these properties if they do not exist on the given `options`:
	 *  - `apikey`
	 *  - `externalClientId`
	 *  - `settings.payment.cardBrands`
	 *
	 * Braintree will overwrite `settings.dataLevel = 'FULL'` to access the full payment method.
	 * @public
	 * @param {object} options The base `initOptions` that will be used to init Visa Checkout.
	 * @param {string} [options.apikey] The API key used to initialize Visa Checkout. When not supplied, Braintree will set this property.
	 * @param {string} [options.externalClientId] The external client ID key used to initialize Visa Checkout. When not supplied, Braintree will set this property.
	 * @param {object} [options.settings] The settings object used to initialize Visa Checkout.
	 * @param {string} [options.settings.dataLevel] The data level used to initialize Visa Checkout. Braintree will overwrite this property to 'FULL'.
	 * @param {object} [options.settings.payment] The payment object used to initialize Visa Checkout.
	 * @param {string[]} [options.settings.payment.cardBrands] The card brands that Visa Checkout will allow the customer to pay with. When not supplied, Braintree will set this property.
	 * @returns {object} `initOptions` The `initOptions` that Visa Checkout should be initialized with.
	 * @example
	 * <caption>Applying Braintree properties to initOptions</caption>
	 * var baseInitOptions = {
	 *    paymentRequest: {
	 *      currencyCode: 'USD',
	 *      subtotal: '1.00',
	 *      total: '1.00'
	 *    }
	 *  };
	 *
	 *  var initOptions = visaCheckoutInstance.createInitOptions(baseInitOptions);
	 *
	 *  console.log('initOptions with Braintree properties', initOptions);
	 *
	 *  V.init(initOptions);
	 */
	VisaCheckout.prototype.createInitOptions = function (options) {
	  var initOptions;
	  var gatewayConfiguration = this._client.getConfiguration().gatewayConfiguration;
	  var visaCheckoutConfiguration = gatewayConfiguration.visaCheckout;
	
	  if (!options) {
	    throw new BraintreeError(errors.VISA_CHECKOUT_INIT_OPTIONS_REQUIRED);
	  }
	
	  initOptions = jsonClone(options);
	  initOptions.apikey = initOptions.apikey || visaCheckoutConfiguration.apikey;
	  initOptions.externalClientId = initOptions.externalClientId || visaCheckoutConfiguration.externalClientId;
	  initOptions.settings = initOptions.settings || {};
	  initOptions.settings.dataLevel = 'FULL';
	  initOptions.settings.payment = initOptions.settings.payment || {};
	
	  if (!initOptions.settings.payment.cardBrands) {
	    initOptions.settings.payment.cardBrands = transformCardTypes(gatewayConfiguration.visaCheckout.supportedCardTypes);
	  }
	
	  return initOptions;
	};
	
	/**
	 * Tokenizes the Visa Checkout payload, returning a payment method nonce.
	 * @public
	 * @param {object} payment The object that Visa Checkout supplies on `payment.success`.
	 * @param {string} payment.callid Visa Checkout transaction ID associated with this payment.
	 * @param {string} payment.encKey The encrypted key used to decrypt the payment data.
	 * @param {string} payment.encPaymentData The encrypted payment data.
	 * @param {callback} [callback] The second argument, <code>tokenizePayload</code> is a {@link VisaCheckout~tokenizePayload|tokenizePayload}. If no callback is provided, `tokenize` returns a promise that resolves with the {@link VisaCheckout~tokenizePayload|tokenizePayload}.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * V.on('payment.success', function (payment) {
	 *   visaCheckoutInstance.tokenize(payment, function (err, tokenizePayload) {
	 *     if (err) {
	 *       console.error('There was an error tokenizing Visa Checkout', err);
	 *       return;
	 *     }
	 *     console.log('Send tokenizePayload.nonce to your server here!', tokenizePayload);
	 *   });
	 * });
	 */
	VisaCheckout.prototype.tokenize = function (payment) {
	  var self = this;
	
	  if (!payment.callid || !payment.encKey || !payment.encPaymentData) {
	    return Promise.reject(new BraintreeError(errors.VISA_CHECKOUT_PAYMENT_REQUIRED));
	  }
	
	  return this._client.request({
	    method: 'post',
	    endpoint: 'payment_methods/visa_checkout_cards',
	    data: {
	      _meta: {
	        source: 'visa-checkout'
	      },
	      visaCheckoutCard: {
	        callId: payment.callid,
	        encryptedPaymentData: payment.encPaymentData,
	        encryptedKey: payment.encKey
	      }
	    }
	  }).then(function (response) {
	    analytics.sendEvent(self._client, 'visacheckout.tokenize.succeeded');
	    return response.visaCheckoutCards[0];
	  }).catch(function (err) {
	    analytics.sendEvent(self._client, 'visacheckout.tokenize.failed');
	    return Promise.reject(new BraintreeError({
	      type: errors.VISA_CHECKOUT_TOKENIZATION.type,
	      code: errors.VISA_CHECKOUT_TOKENIZATION.code,
	      message: errors.VISA_CHECKOUT_TOKENIZATION.message,
	      details: {
	        originalError: err
	      }
	    }));
	  });
	};
	
	module.exports = wrapPromise.wrapPrototype(VisaCheckout);


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  VISA_CHECKOUT_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'VISA_CHECKOUT_NOT_ENABLED',
	    message: 'Visa Checkout is not enabled for this merchant.'
	  },
	  VISA_CHECKOUT_INIT_OPTIONS_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'VISA_CHECKOUT_INIT_OPTIONS_REQUIRED',
	    message: 'initOptions requires an object.'
	  },
	  VISA_CHECKOUT_PAYMENT_REQUIRED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'VISA_CHECKOUT_PAYMENT_REQUIRED',
	    message: 'tokenize requires callid, encKey, and encPaymentData.'
	  },
	  VISA_CHECKOUT_TOKENIZATION: {
	    type: BraintreeError.types.NETWORK,
	    code: 'VISA_CHECKOUT_TOKENIZATION',
	    message: 'A network error occurred when processing the Visa Checkout payment.'
	  }
	};


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	/** @module braintree-web/masterpass
	 * @description Processes Masterpass. *This component is currently in beta and is subject to change.*
	 */
	
	var BraintreeError = __webpack_require__(378);
	var browserDetection = __webpack_require__(427);
	var Masterpass = __webpack_require__(546);
	var VERSION = "3.14.0";
	var errors = __webpack_require__(547);
	var sharedErrors = __webpack_require__(404);
	var Promise = __webpack_require__(399);
	var wrapPromise = __webpack_require__(406);
	
	/**
	 * @static
	 * @function create
	 * @param {object} options Creation options:
	 * @param {Client} options.client A {@link Client} instance.
	 * @param {callback} [callback] The second argument, `data`, is the {@link Masterpass} instance. If no callback is passed in, the create function returns a promise that resolves the {@link Masterpass} instance.
	 * @example
	 * braintree.masterpass.create({
	 *   client: clientInstance
	 * }, function (createErr, masterpassInstance) {
	 *   if (createErr) {
	 *     if (createErr.code === 'MASTERPASS_BROWSER_NOT_SUPPORTED') {
	 *       console.error('This browser is not supported.');
	 *     } else {
	 *       console.error('Error!', createErr);
	 *     }
	 *     return;
	 *   }
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	function create(options) {
	  var masterpassInstance, clientVersion, configuration;
	
	  if (options.client == null) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INSTANTIATION_OPTION_REQUIRED.type,
	      code: sharedErrors.INSTANTIATION_OPTION_REQUIRED.code,
	      message: 'options.client is required when instantiating Masterpass.'
	    }));
	  }
	
	  clientVersion = options.client.getConfiguration().analyticsMetadata.sdkVersion;
	  if (clientVersion !== VERSION) {
	    return Promise.reject(new BraintreeError({
	      type: sharedErrors.INCOMPATIBLE_VERSIONS.type,
	      code: sharedErrors.INCOMPATIBLE_VERSIONS.code,
	      message: 'Client (version ' + clientVersion + ') and Masterpass (version ' + VERSION + ') components must be from the same SDK version.'
	    }));
	  }
	
	  if (!isSupported()) {
	    return Promise.reject(new BraintreeError(errors.MASTERPASS_BROWSER_NOT_SUPPORTED));
	  }
	
	  configuration = options.client.getConfiguration().gatewayConfiguration;
	  if (!configuration.masterpass) {
	    return Promise.reject(new BraintreeError(errors.MASTERPASS_NOT_ENABLED));
	  }
	
	  masterpassInstance = new Masterpass(options);
	
	  return masterpassInstance._initialize();
	}
	
	/**
	 * @static
	 * @function isSupported
	 * @description Returns true if Masterpass supports this browser.
	 * @example
	 * if (braintree.masterpass.isSupported()) {
	 *   // Add Masterpass button to the page
	 * } else {
	 *   // Hide Masterpass payment option
	 * }
	 * @returns {Boolean} Returns true if Masterpass supports this browser.
	 */
	function isSupported() {
	  return Boolean(global.popupBridge || browserDetection.supportsPopups());
	}
	
	module.exports = {
	  create: wrapPromise(create),
	  isSupported: isSupported,
	  /**
	   * @description The current version of the SDK, i.e. `{@pkg version}`.
	   * @type {string}
	   */
	  VERSION: VERSION
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var Promise = __webpack_require__(399);
	var frameService = __webpack_require__(414);
	var BraintreeError = __webpack_require__(378);
	var errors = __webpack_require__(547);
	var VERSION = "3.14.0";
	var methods = __webpack_require__(440);
	var wrapPromise = __webpack_require__(406);
	var analytics = __webpack_require__(411);
	var convertMethodsToError = __webpack_require__(441);
	var convertToBraintreeError = __webpack_require__(393);
	var constants = __webpack_require__(548);
	
	var INTEGRATION_TIMEOUT_MS = __webpack_require__(398).INTEGRATION_TIMEOUT_MS;
	
	/**
	 * Masterpass Address object.
	 * @typedef {object} Masterpass~Address
	 * @property {string} countryCodeAlpha2 The customer's country code.
	 * @property {string} extendedAddress The customer's extended address.
	 * @property {string} locality The customer's locality.
	 * @property {string} postalCode The customer's postal code.
	 * @property {string} region The customer's region.
	 * @property {string} streetAddress The customer's street address.
	 */
	
	/**
	 * @typedef {object} Masterpass~tokenizePayload
	 * @property {string} nonce The payment method nonce.
	 * @property {string} description The human readable description.
	 * @property {string} type The payment method type, always `MasterpassCard`.
	 * @property {object} details Additional account details.
	 * @property {string} details.cardType Type of card, ex: Visa, MasterCard.
	 * @property {string} details.lastTwo Last two digits of card number.
	 * @property {Masterpass~Address} billingAddress The customer's billing address.
	 * @property {Masterpass~Address} shippingAddress The customer's shipping address.
	 */
	
	/**
	 * @class
	 * @param {object} options see {@link module:braintree-web/masterpass.create|masterpass.create}
	 * @description <strong>You cannot use this constructor directly. Use {@link module:braintree-web/masterpass.create|braintree.masterpass.create} instead.</strong>
	 * @classdesc This class represents an Masterpass component. Instances of this class have methods for launching a new window to process a transaction with Masterpass.
	 */
	function Masterpass(options) {
	  var configuration = options.client.getConfiguration();
	
	  this._client = options.client;
	  this._assetsUrl = configuration.gatewayConfiguration.assetsUrl + '/web/' + VERSION;
	  this._isDebug = configuration.isDebug;
	  this._authInProgress = false;
	  if (global.popupBridge && typeof global.popupBridge.getReturnUrlPrefix === 'function') {
	    this._callbackUrl = global.popupBridge.getReturnUrlPrefix() + 'return';
	  } else {
	    this._callbackUrl = this._assetsUrl + '/html/masterpass-redirect-frame' + (this._isDebug ? '' : '.min') + '.html';
	  }
	}
	
	Masterpass.prototype._initialize = function () {
	  var self = this;
	
	  return new Promise(function (resolve) {
	    var failureTimeout = setTimeout(function () {
	      analytics.sendEvent(self._client, 'masterpass.load.timed-out');
	    }, INTEGRATION_TIMEOUT_MS);
	
	    frameService.create({
	      name: constants.LANDING_FRAME_NAME,
	      height: constants.POPUP_HEIGHT,
	      width: constants.POPUP_WIDTH,
	      dispatchFrameUrl: self._assetsUrl + '/html/dispatch-frame' + (self._isDebug ? '' : '.min') + '.html',
	      openFrameUrl: self._assetsUrl + '/html/masterpass-landing-frame' + (self._isDebug ? '' : '.min') + '.html'
	    }, function (service) {
	      self._frameService = service;
	      clearTimeout(failureTimeout);
	      analytics.sendEvent(self._client, 'masterpass.load.succeeded');
	      resolve(self);
	    });
	  });
	};
	
	/**
	 * Launches the Masterpass flow and returns a nonce payload. Only one Masterpass flow should be active at a time. One way to achieve this is to disable your Masterpass button while the flow is open.
	 * @public
	 * @param {object} options All options for initiating the Masterpass payment flow.
	 * @param {string} options.currencyCode The currency code to process the payment.
	 * @param {string} options.subtotal The amount to authorize for the transaction.
	 * @param {object} options.config All configuration parameters accepted by Masterpass lightbox, except `function` data type. These options will override the values set by Braintree server. Please see {@link Masterpass Lightbox Parameters|https://developer.mastercard.com/page/masterpass-lightbox-parameters} for more information.
	 * @param {callback} [callback] The second argument, <code>data</code>, is a {@link Masterpass~tokenizePayload|tokenizePayload}. If no callback is provided, the method will return a Promise that resolves with a {@link Masterpass~tokenizePayload|tokenizePayload}.
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 * @example
	 * button.addEventListener('click', function () {
	 *   // Disable the button so that we don't attempt to open multiple popups.
	 *   button.setAttribute('disabled', 'disabled');
	 *
	 *   // Because tokenize opens a new window, this must be called
	 *   // as a result of a user action, such as a button click.
	 *   masterpassInstance.tokenize({
	 *     currencyCode: 'USD',
	 *     subtotal: '10.00'
	 *   }).then(function (payload) {
	 *     button.removeAttribute('disabled');
	 *     // Submit payload.nonce to your server
	 *   }).catch(function (tokenizeError) {
	 *     button.removeAttribute('disabled');
	 *     // Handle flow errors or premature flow closure
	 *
	 *     switch (tokenizeErr.code) {
	 *       case 'MASTERPASS_POPUP_CLOSED':
	 *         console.error('Customer closed Masterpass popup.');
	 *         break;
	 *       case 'MASTERPASS_ACCOUNT_TOKENIZATION_FAILED':
	 *         console.error('Masterpass tokenization failed. See details:', tokenizeErr.details);
	 *         break;
	 *       case 'MASTERPASS_FLOW_FAILED':
	 *         console.error('Unable to initialize Masterpass flow. Are your options correct?', tokenizeErr.details);
	 *         break;
	 *       default:
	 *         console.error('Error!', tokenizeErr);
	 *     }
	 *   });
	 * });
	 */
	Masterpass.prototype.tokenize = function (options) {
	  var self = this;
	
	  if (!options || hasMissingOption(options)) {
	    return Promise.reject(new BraintreeError(errors.MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION));
	  }
	
	  if (self._authInProgress) {
	    return Promise.reject(new BraintreeError(errors.MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS));
	  }
	
	  return new Promise(function (resolve, reject) {
	    self._navigateFrameToLoadingPage(options).catch(reject);
	    // This MUST happen after _navigateFrameToLoadingPage for Metro browsers to work.
	    self._frameService.open(self._createFrameOpenHandler(resolve, reject));
	  });
	};
	
	Masterpass.prototype._navigateFrameToLoadingPage = function (options) {
	  var self = this;
	
	  this._authInProgress = true;
	
	  return this._client.request({
	    method: 'post',
	    endpoint: 'masterpass/request_token',
	    data: {
	      requestToken: {
	        originUrl: global.location.protocol + '//' + global.location.hostname,
	        subtotal: options.subtotal,
	        currencyCode: options.currencyCode,
	        callbackUrl: this._callbackUrl
	      }
	    }
	  }).then(function (response) {
	    var redirectUrl = self._assetsUrl + '/html/masterpass-loading-frame' + (self._isDebug ? '' : '.min') + '.html?';
	    var gatewayConfiguration = self._client.getConfiguration().gatewayConfiguration;
	    var config = options.config || {};
	    var queryParams;
	
	    queryParams = {
	      environment: gatewayConfiguration.environment,
	      requestToken: response.requestToken,
	      callbackUrl: self._callbackUrl,
	      merchantCheckoutId: gatewayConfiguration.masterpass.merchantCheckoutId,
	      allowedCardTypes: gatewayConfiguration.masterpass.supportedNetworks
	    };
	
	    Object.keys(config).forEach(function (key) {
	      if (typeof config[key] !== 'function') {
	        queryParams[key] = config[key];
	      }
	    });
	
	    redirectUrl += Object.keys(queryParams).map(function (key) {
	      return key + '=' + queryParams[key];
	    }).join('&');
	
	    self._frameService.redirect(redirectUrl);
	  }).catch(function (err) {
	    var status = err.details && err.details.httpStatus;
	
	    self._closeWindow();
	
	    if (status === 422) {
	      return Promise.reject(convertToBraintreeError(err, errors.MASTERPASS_INVALID_PAYMENT_OPTION));
	    }
	
	    return Promise.reject(convertToBraintreeError(err, errors.MASTERPASS_FLOW_FAILED));
	  });
	};
	
	Masterpass.prototype._createFrameOpenHandler = function (resolve, reject) {
	  var self = this;
	
	  if (global.popupBridge) {
	    return function (popupBridgeErr, payload) {
	      self._authInProgress = false;
	
	      if (popupBridgeErr) {
	        analytics.sendEvent(self._client, 'masterpass.tokenization.closed-popupbridge.by-user');
	        reject(convertToBraintreeError(popupBridgeErr, errors.MASTERPASS_POPUP_CLOSED));
	        return;
	      } else if (!payload.queryItems) {
	        analytics.sendEvent(self._client, 'masterpass.tokenization.failed-popupbridge');
	        reject(new BraintreeError(errors.MASTERPASS_FLOW_FAILED));
	        return;
	      }
	
	      self._tokenizeMasterpass(payload.queryItems).then(resolve).catch(reject);
	    };
	  }
	
	  return function (frameServiceErr, payload) {
	    if (frameServiceErr) {
	      self._authInProgress = false;
	
	      if (frameServiceErr.code === 'FRAME_SERVICE_FRAME_CLOSED') {
	        analytics.sendEvent(self._client, 'masterpass.tokenization.closed.by-user');
	        reject(new BraintreeError(errors.MASTERPASS_POPUP_CLOSED));
	        return;
	      }
	
	      if (frameServiceErr.code === 'FRAME_SERVICE_FRAME_OPEN_FAILED') {
	        analytics.sendEvent(self._client, 'masterpass.tokenization.failed.to-open');
	        reject(new BraintreeError(errors.MASTERPASS_POPUP_OPEN_FAILED));
	        return;
	      }
	
	      analytics.sendEvent(self._client, 'masterpass.tokenization.failed');
	      self._closeWindow();
	      reject(convertToBraintreeError(frameServiceErr, errors.MASTERPASS_FLOW_FAILED));
	      return;
	    }
	
	    self._tokenizeMasterpass(payload).then(resolve).catch(reject);
	  };
	};
	
	Masterpass.prototype._tokenizeMasterpass = function (payload) {
	  var self = this;
	
	  if (payload.mpstatus !== 'success') {
	    analytics.sendEvent(self._client, 'masterpass.tokenization.closed.by-user');
	    self._closeWindow();
	    return Promise.reject(new BraintreeError(errors.MASTERPASS_POPUP_CLOSED));
	  }
	
	  return self._client.request({
	    endpoint: 'payment_methods/masterpass_cards',
	    method: 'post',
	    data: {
	      masterpassCard: {
	        checkoutResourceUrl: payload.checkout_resource_url,
	        requestToken: payload.oauth_token,
	        verifierToken: payload.oauth_verifier
	      }
	    }
	  }).then(function (response) {
	    self._closeWindow();
	    if (global.popupBridge) {
	      analytics.sendEvent(self._client, 'masterpass.tokenization.success-popupbridge');
	    } else {
	      analytics.sendEvent(self._client, 'masterpass.tokenization.success');
	    }
	    return response.masterpassCards[0];
	  }).catch(function (tokenizeErr) {
	    self._closeWindow();
	    if (global.popupBridge) {
	      analytics.sendEvent(self._client, 'masterpass.tokenization.failed-popupbridge');
	    } else {
	      analytics.sendEvent(self._client, 'masterpass.tokenization.failed');
	    }
	
	    return Promise.reject(convertToBraintreeError(tokenizeErr, errors.MASTERPASS_ACCOUNT_TOKENIZATION_FAILED));
	  });
	};
	
	Masterpass.prototype._closeWindow = function () {
	  this._authInProgress = false;
	  this._frameService.close();
	};
	
	/**
	 * Cleanly tear down anything set up by {@link module:braintree-web/masterpass.create|create}.
	 * @public
	 * @param {callback} [callback] Called on completion. If no callback is provided, `teardown` returns a promise.
	 * @example
	 * masterpassInstance.teardown();
	 * @example <caption>With callback</caption>
	 * masterpassInstance.teardown(function () {
	 *   // teardown is complete
	 * });
	 * @returns {Promise|void} Returns a promise if no callback is provided.
	 */
	Masterpass.prototype.teardown = function () {
	  var self = this;
	
	  return new Promise(function (resolve) {
	    self._frameService.teardown();
	
	    convertMethodsToError(self, methods(Masterpass.prototype));
	
	    analytics.sendEvent(self._client, 'masterpass.teardown-completed');
	
	    resolve();
	  });
	};
	
	function hasMissingOption(options) {
	  var i, option;
	
	  for (i = 0; i < constants.REQUIRED_OPTIONS_FOR_TOKENIZE.length; i++) {
	    option = constants.REQUIRED_OPTIONS_FOR_TOKENIZE[i];
	
	    if (!options.hasOwnProperty(option)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	module.exports = wrapPromise.wrapPrototype(Masterpass);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var BraintreeError = __webpack_require__(378);
	
	module.exports = {
	  MASTERPASS_BROWSER_NOT_SUPPORTED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'MASTERPASS_BROWSER_NOT_SUPPORTED',
	    message: 'Browser is not supported.'
	  },
	  MASTERPASS_NOT_ENABLED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'MASTERPASS_NOT_ENABLED',
	    message: 'Masterpass is not enabled for this merchant.'
	  },
	  MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'MASTERPASS_TOKENIZE_MISSING_REQUIRED_OPTION',
	    message: 'Missing required option for tokenize.'
	  },
	  MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'MASTERPASS_TOKENIZATION_ALREADY_IN_PROGRESS',
	    message: 'Masterpass tokenization is already in progress.'
	  },
	  MASTERPASS_ACCOUNT_TOKENIZATION_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'MASTERPASS_ACCOUNT_TOKENIZATION_FAILED',
	    message: 'Could not tokenize user\'s Masterpass account.'
	  },
	  MASTERPASS_POPUP_OPEN_FAILED: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'MASTERPASS_POPUP_OPEN_FAILED',
	    message: 'Masterpass popup failed to open. Make sure to tokenize in response to a user action, such as a click.'
	  },
	  MASTERPASS_POPUP_CLOSED: {
	    type: BraintreeError.types.CUSTOMER,
	    code: 'MASTERPASS_POPUP_CLOSED',
	    message: 'Customer closed Masterpass popup before authorizing.'
	  },
	  MASTERPASS_INVALID_PAYMENT_OPTION: {
	    type: BraintreeError.types.MERCHANT,
	    code: 'MASTERPASS_INVALID_PAYMENT_OPTION',
	    message: 'Masterpass payment options are invalid.'
	  },
	  MASTERPASS_FLOW_FAILED: {
	    type: BraintreeError.types.NETWORK,
	    code: 'MASTERPASS_FLOW_FAILED',
	    message: 'Could not initialize Masterpass flow.'
	  }
	};
	


/***/ },
/* 548 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  LANDING_FRAME_NAME: 'braintreemasterpasslanding',
	  POPUP_WIDTH: 450,
	  POPUP_HEIGHT: 660,
	  REQUIRED_OPTIONS_FOR_TOKENIZE: [
	    'subtotal',
	    'currencyCode'
	  ]
	};


/***/ },
/* 549 */
/***/ function(module, exports) {

	module.exports = "<div class=\"userWrapper\">\n    <h1 class=\"title\">Account</h1>\n    <div class=\"userTabs\" *ngIf=\"ps.userObject.customer_id\">\n        <span data-show=\"_settings\" class=\"tab\">Settings</span>\n        <span data-show=\"_payment\" class=\"tab activeTab\">Payment</span>\n        <span data-show=\"_transactionhistory\" class=\"tab\">Transaction History</span>\n    </div>\n    <div class=\"userSettings\" *ngIf=\"!ps.userObect?.customer_id && !ps.userObject?.email\">\n        <form id=\"nonceForm\" action=\"\" class=\"emailConfirm\">\n            <h2>Please confirm your email before you can purchase tickets:</h2>\n            <input id=\"emailInput\" type=\"text\">\n            <button (click)=\"updateEmail()\">Submit</button>\n        </form>\n    </div>\n    <div class=\"userSettings _settings _userpanel\" *ngIf=\"ps.userObject.customer_id\" style=\"display: none;\">\n        <form id=\"nonceForm\" action=\"\" class=\"emailConfirm\">\n            <h2>Update Email</h2>\n            <input id=\"emailInput\" type=\"text\" [attr.value]=\"ps.userObject.email\">\n            <button (click)=\"updateEmail()\">Submit</button>\n        </form>\n    </div>\n    <div class=\"paymentOptions _payment _userpanel\">\n        <div class=\"paymentOption\" *ngIf=\"ps.userObject.customer_id\">\n            <span class=\"deletePO\" (click)=\"deletePaymentMethod()\">DELETE</span>\n            <h1><i class=\"fa fa-cc-visa\"></i> Card ending in {{ps.userObject.card_digits}}</h1>\n        </div>\n        <div (click)=\"cardNewWindow()\" *ngIf=\"!ps.userObject?.customer_id && ps.userObject?.email\" class=\"paymentOption newPO\">\n            <i class=\"fa fa-plus\"></i>\n            <h2>Add Payment Option</h2>\n        </div>\n        <div (click)=\"cardNewWindow()\" *ngIf=\"!ps.userObject?.customer_id && ps.userObject?.email\" class=\"paymentOption newPO\">\n            <i class=\"fa fa-plus\"></i>\n            <div id=\"paypal-button\"></div>\n        </div>\n    </div>\n    <ng-container *ngIf=\"ps.userObject.customer_id\">\n        <table class=\"transactionHistory _transactionhistory _userpanel\" style=\"display: none;\">\n            <tr>\n                <th>Event</th>\n                <th>Total</th>\n                <th>Order Placed</th>\n            </tr>\n            <tr *ngFor=\"let t of transactions\">\n                <td>Event #1</td>\n                <td>{{t.amount}} + {{t.serviceFeeAmount ? t.serviceFeeAmount : 0}} Service Fee</td>\n                <td>April 23, 2017 8:37PM</td>\n            </tr>\n        </table>\n    </ng-container>\n    <button class=\"deleteProfile\" (click)=\"deleteAccount()\"><i class=\"fa fa-times-circle\"></i> Delete Profile</button>\n</div>\n";

/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var MainComponent = (function () {
	    function MainComponent(backendService, ps) {
	        this.backendService = backendService;
	        this.ps = ps;
	        // Styling jQuery on pageload
	        $(document).ready(function () {
	            // Nu-Ricks logo shadow effect
	            var shadowState;
	            $("#header").mousemove(function (e) {
	                var width = $(e.currentTarget).width();
	                var height = $(e.currentTarget).height();
	                var shadowx = e.pageX / width * 10;
	                var shadowy = e.pageY / height * 10;
	                shadowState = shadowx + "px " + shadowy + "px white";
	                $(e.currentTarget).find(".title").css("text-shadow", shadowState);
	            });
	            // Animate scroll to anchor
	            $("a[href*='#']").click(function (e) {
	                e.preventDefault();
	                $("html, body").animate({
	                    scrollTop: $($.attr(e.currentTarget, "href")).offset().top
	                }, 500);
	            });
	        });
	    }
	    MainComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.backendService.getGlobalTickets()
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                var tickets = response.tickets;
	                for (var i = 0; i < tickets.length; ++i) {
	                    _this.backendService.getEventInfoFromID(tickets[i].EventId)
	                        .subscribe(function (response) {
	                        _this.ps.globalUserObject.events.push(response);
	                    });
	                }
	            }
	        });
	    };
	    MainComponent = __decorate([
	        core_1.Component({
	            selector: 'app',
	            template: __webpack_require__(551)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _b) || Object])
	    ], MainComponent);
	    return MainComponent;
	    var _a, _b;
	}());
	exports.MainComponent = MainComponent;


/***/ },
/* 551 */
/***/ function(module, exports) {

	module.exports = "<a href=\"#about\" class=\"navAbout\">About Us</a>\n<a href=\"#contact\" class=\"navContact\">Contact Us</a>\n<div class=\"mainWrapper\">\n\t<div id=\"header\">\n\t\t<img class=\"splash\" [src]=\"'res/main_banner.jpg'\">\n\t\t<div>\n\t\t\t<h1 class=\"title\">Nu-Ricks</h1>\n\t\t</div>\n\t\t<a href=\"#about\"><i class=\"fa fa-chevron-down\"></i></a>\n\t</div>\n\t<div id=\"about\">\n\t\t<h1 class=\"title\">About Us</h1>\n\t\t<hr>\n\t\t<h2>NU-Ricks is the highest volume independent live music company in the SF Bay Area.</h2>\n\t\t<h1>Artists</h1>\n\t\t<p>NU-Ricks enables artists to grow their networks, get on stage and build a performance resume all while making money while performing.</p>\n\t\t<h1>Venues</h1>\n\t\t<p>NU-Ricks can drive foot traffic to your venue. This leads to increased bar sales, better notoriety, and repeat customers.</p>\n\t\t<h1>Labels</h1>\n\t\t<p>Ensure your artists gain the necessary exposure and notoriety they deserve. With our promotional strategies, you can be assured that your artist will be treated and promoted in the most professional of manners.</p>\n\t\t<hr>\n\t\t<a href=\"#upcoming\"><i class=\"fa fa-chevron-down\"></i></a>\n\t</div>\n\t<div id=\"contact\">\n\t\t<h1 class=\"title\">Contact Us</h1>\n\t\t<hr>\n\t\t<h1>Email: some@email.com</h1>\n\t\t<h1>Phone: 123-555-2355</h1>\n\t\t<h1>Other stuff</h1>\n\t\t<hr>\n\t</div>\n</div>\n";

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(4), __webpack_require__(25), __webpack_require__(23), __webpack_require__(8), __webpack_require__(140), __webpack_require__(171), __webpack_require__(238));
		else if(typeof define === 'function' && define.amd)
			define(["@angular/core", "@angular/http", "@angular/common", "rxjs/Observable", "rxjs/add/observable/throw", "rxjs/add/operator/catch", "rxjs/add/operator/map"], factory);
		else if(typeof exports === 'object')
			exports["angular2-markdown.umd"] = factory(require("@angular/core"), require("@angular/http"), require("@angular/common"), require("rxjs/Observable"), require("rxjs/add/observable/throw"), require("rxjs/add/operator/catch"), require("rxjs/add/operator/map"));
		else
			root["angular2-markdown.umd"] = factory(root["@angular/core"], root["@angular/http"], root["@angular/common"], root["rxjs/Observable"], root["rxjs/add/observable/throw"], root["rxjs/add/operator/catch"], root["rxjs/add/operator/map"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_24__, __WEBPACK_EXTERNAL_MODULE_25__, __WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_28__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			i: moduleId,
	/******/ 			l: false,
	/******/ 			exports: {}
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.l = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// identity function for calling harmony imports with the correct context
	/******/ 	__webpack_require__.i = function(value) { return value; };
	/******/
	/******/ 	// define getter function for harmony exports
	/******/ 	__webpack_require__.d = function(exports, name, getter) {
	/******/ 		if(!__webpack_require__.o(exports, name)) {
	/******/ 			Object.defineProperty(exports, name, {
	/******/ 				configurable: false,
	/******/ 				enumerable: true,
	/******/ 				get: getter
	/******/ 			});
	/******/ 		}
	/******/ 	};
	/******/
	/******/ 	// getDefaultExport function for compatibility with non-harmony modules
	/******/ 	__webpack_require__.n = function(module) {
	/******/ 		var getter = module && module.__esModule ?
	/******/ 			function getDefault() { return module['default']; } :
	/******/ 			function getModuleExports() { return module; };
	/******/ 		__webpack_require__.d(getter, 'a', getter);
	/******/ 		return getter;
	/******/ 	};
	/******/
	/******/ 	// Object.prototype.hasOwnProperty.call
	/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "/";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(__webpack_require__.s = 29);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_0__;
	
	/***/ }),
	/* 1 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(2);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_http__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__ = __webpack_require__(25);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_marked__ = __webpack_require__(9);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_marked___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_marked__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_throw__ = __webpack_require__(26);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_throw___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_rxjs_add_observable_throw__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_catch__ = __webpack_require__(27);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_catch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_rxjs_add_operator_catch__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_map__ = __webpack_require__(28);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_rxjs_add_operator_map__);
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkdownService; });
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	
	
	
	
	
	
	
	var MarkdownService = (function () {
	    function MarkdownService(http) {
	        this.http = http;
	        this.extendRenderer();
	        this.setMarkedOptions();
	    }
	    //get the content from remote resource
	    MarkdownService.prototype.getContent = function (path) {
	        return this.http.get(path)
	            .map(this.extractData)
	            .catch(this.handleError);
	    };
	    // handle data
	    MarkdownService.prototype.extractData = function (res) {
	        return res.text() || '';
	    };
	    //handle error
	    MarkdownService.prototype.handleError = function (error) {
	        var errMsg;
	        if (error instanceof __WEBPACK_IMPORTED_MODULE_1__angular_http__["Response"]) {
	            var body = error.json() || '';
	            var err = body.error || JSON.stringify(body);
	            errMsg = error.status + " - " + (error.statusText || '') + " " + err;
	        }
	        else {
	            errMsg = error.message ? error.message : error.toString();
	        }
	        console.error(errMsg);
	        return __WEBPACK_IMPORTED_MODULE_2_rxjs_Observable__["Observable"].throw(errMsg);
	    };
	    // extend marked render to support todo checkbox
	    MarkdownService.prototype.extendRenderer = function () {
	        this.renderer = new __WEBPACK_IMPORTED_MODULE_3_marked__["Renderer"]();
	        this.renderer.listitem = function (text) {
	            if (/^\s*\[[x ]\]\s*/.test(text)) {
	                text = text
	                    .replace(/^\s*\[ \]\s*/, '<input type="checkbox" style=" vertical-align: middle; margin: 0 0.2em 0.25em -1.6em; font-size: 16px; " disabled> ')
	                    .replace(/^\s*\[x\]\s*/, '<input type="checkbox" style=" vertical-align: middle; margin: 0 0.2em 0.25em -1.6em; font-size: 16px; " checked disabled> ');
	                return '<li style="list-style: none">' + text + '</li>';
	            }
	            else {
	                return '<li>' + text + '</li>';
	            }
	        };
	    };
	    MarkdownService.prototype.setMarkedOptions = function () {
	        __WEBPACK_IMPORTED_MODULE_3_marked__["setOptions"]({
	            renderer: this.renderer,
	            gfm: true,
	            tables: true,
	            breaks: false,
	            pedantic: false,
	            sanitize: false,
	            smartLists: true,
	            smartypants: false
	        });
	    };
	    // comple markdown to html
	    MarkdownService.prototype.compile = function (data) {
	        return __WEBPACK_IMPORTED_MODULE_3_marked__(data);
	    };
	    return MarkdownService;
	}());
	MarkdownService = __decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
	    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__angular_http__["Http"]])
	], MarkdownService);
	
	
	
	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;
	
	/***/ }),
	/* 3 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http__ = __webpack_require__(2);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_http__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__markdown_service__ = __webpack_require__(1);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__prism_languages__ = __webpack_require__(8);
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkdownComponent; });
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	
	
	
	
	var MarkdownComponent = (function () {
	    function MarkdownComponent(mdService, el, http) {
	        this.mdService = mdService;
	        this.el = el;
	        this.http = http;
	        this.changeLog = [];
	    }
	    MarkdownComponent.prototype.ngOnInit = function () {
	    };
	    Object.defineProperty(MarkdownComponent.prototype, "path", {
	        set: function (value) {
	            this._path = value;
	            this.onPathChange();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MarkdownComponent.prototype, "data", {
	        set: function (value) {
	            this._data = value;
	            this.onDataChange(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // on input
	    MarkdownComponent.prototype.onDataChange = function (data) {
	        this.el.nativeElement.innerHTML = this.mdService.compile(data);
	        Prism.highlightAll(false);
	    };
	    /**
	     *  After view init
	     */
	    MarkdownComponent.prototype.ngAfterViewInit = function () {
	        if (this._path) {
	            this.onPathChange();
	        }
	        else {
	            this.processRaw();
	        }
	    };
	    MarkdownComponent.prototype.processRaw = function () {
	        this._md = this.prepare(this.el.nativeElement.innerHTML);
	        this.el.nativeElement.innerHTML = this.mdService.compile(this._md);
	        Prism.highlightAll(false);
	    };
	    /**
	     * get remote conent;
	     */
	    MarkdownComponent.prototype.onPathChange = function () {
	        var _this = this;
	        this._ext = this._path && this._path.split('.').splice(-1).join();
	        this.mdService.getContent(this._path)
	            .subscribe(function (data) {
	            _this._md = _this._ext !== 'md' ? '```' + _this._ext + '\n' + data + '\n```' : data;
	            _this.el.nativeElement.innerHTML = _this.mdService.compile(_this.prepare(_this._md));
	            Prism.highlightAll(false);
	        }, function (err) { return _this.handleError; });
	    };
	    /**
	     * catch http error
	     */
	    MarkdownComponent.prototype.handleError = function (error) {
	        console.error('An error occurred', error); // for demo purposes only
	        return Promise.reject(error.message || error);
	    };
	    /**
	     * Prepare string
	     */
	    MarkdownComponent.prototype.prepare = function (raw) {
	        var _this = this;
	        if (!raw) {
	            return '';
	        }
	        if (this._ext === 'md' || !this.path) {
	            var isCodeBlock_1 = false;
	            return raw.split('\n').map(function (line) {
	                if (_this.trimLeft(line).substring(0, 3) === "```") {
	                    isCodeBlock_1 = !isCodeBlock_1;
	                }
	                return isCodeBlock_1 ? line : line.trim();
	            }).join('\n');
	        }
	        return raw.replace(/\"/g, '\'');
	    };
	    /**
	     * Trim left whitespace
	     */
	    MarkdownComponent.prototype.trimLeft = function (line) {
	        return line.replace(/^\s+|\s+$/g, '');
	    };
	    return MarkdownComponent;
	}());
	__decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
	    __metadata("design:type", String),
	    __metadata("design:paramtypes", [String])
	], MarkdownComponent.prototype, "path", null);
	__decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
	    __metadata("design:type", String),
	    __metadata("design:paramtypes", [String])
	], MarkdownComponent.prototype, "data", null);
	MarkdownComponent = __decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
	        selector: 'markdown,[Markdown]',
	        template: '<ng-content></ng-content>',
	        styles: [
	            ".token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string {\n            background: none;\n        }"
	        ]
	    }),
	    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__markdown_service__["a" /* MarkdownService */],
	        __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"],
	        __WEBPACK_IMPORTED_MODULE_1__angular_http__["Http"]])
	], MarkdownComponent);
	
	
	
	/***/ }),
	/* 4 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_core__);
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkdownConfig; });
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	
	var MarkdownConfig = (function () {
	    function MarkdownConfig() {
	    }
	    return MarkdownConfig;
	}());
	MarkdownConfig = __decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])()
	], MarkdownConfig);
	
	
	
	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {
	
	var g;
	
	// This works in non-strict mode
	g = (function() {
		return this;
	})();
	
	try {
		// This works if eval is allowed (see CSP)
		g = g || Function("return this")() || (1,eval)("this");
	} catch(e) {
		// This works if the window reference is available
		if(typeof window === "object")
			g = window;
	}
	
	// g can still be undefined, but nothing to do about it...
	// We return undefined, instead of nothing here, so it's
	// easier to handle this case. if(!global) { ...}
	
	module.exports = g;
	
	
	/***/ }),
	/* 6 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__markdown_component__ = __webpack_require__(3);
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__markdown_component__["a"]; });
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__markdown_module__ = __webpack_require__(7);
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_1__markdown_module__["a"]; });
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__markdown_service__ = __webpack_require__(1);
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_2__markdown_service__["a"]; });
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__markdown_config__ = __webpack_require__(4);
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__markdown_config__["a"]; });
	
	
	
	
	
	
	/***/ }),
	/* 7 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(24);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__angular_common__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_http__ = __webpack_require__(2);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_http___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__angular_http__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__markdown_component__ = __webpack_require__(3);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__markdown_service__ = __webpack_require__(1);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__markdown_config__ = __webpack_require__(4);
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkdownModule; });
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	
	
	
	
	
	
	var MarkdownModule = MarkdownModule_1 = (function () {
	    function MarkdownModule() {
	    }
	    MarkdownModule.forRoot = function () {
	        return {
	            ngModule: MarkdownModule_1,
	            providers: [__WEBPACK_IMPORTED_MODULE_5__markdown_config__["a" /* MarkdownConfig */]]
	        };
	    };
	    return MarkdownModule;
	}());
	MarkdownModule = MarkdownModule_1 = __decorate([
	    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"])({
	        imports: [__WEBPACK_IMPORTED_MODULE_0__angular_common__["CommonModule"], __WEBPACK_IMPORTED_MODULE_2__angular_http__["HttpModule"]],
	        declarations: [__WEBPACK_IMPORTED_MODULE_3__markdown_component__["a" /* MarkdownComponent */]],
	        providers: [__WEBPACK_IMPORTED_MODULE_4__markdown_service__["a" /* MarkdownService */]],
	        exports: [__WEBPACK_IMPORTED_MODULE_3__markdown_component__["a" /* MarkdownComponent */]],
	        entryComponents: [__WEBPACK_IMPORTED_MODULE_3__markdown_component__["a" /* MarkdownComponent */]]
	    })
	], MarkdownModule);
	
	var MarkdownModule_1;
	
	
	/***/ }),
	/* 8 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prismjs_prism__ = __webpack_require__(23);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_prismjs_prism___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_prismjs_prism__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prismjs_components_prism_c__ = __webpack_require__(10);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prismjs_components_prism_c___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prismjs_components_prism_c__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prismjs_components_prism_cpp__ = __webpack_require__(11);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prismjs_components_prism_cpp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prismjs_components_prism_cpp__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prismjs_components_prism_csharp__ = __webpack_require__(12);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prismjs_components_prism_csharp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prismjs_components_prism_csharp__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_prismjs_components_prism_css__ = __webpack_require__(13);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_prismjs_components_prism_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_prismjs_components_prism_css__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_prismjs_components_prism_diff__ = __webpack_require__(14);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_prismjs_components_prism_diff___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_prismjs_components_prism_diff__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_prismjs_components_prism_java__ = __webpack_require__(15);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_prismjs_components_prism_java___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_prismjs_components_prism_java__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_prismjs_components_prism_javascript__ = __webpack_require__(16);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_prismjs_components_prism_javascript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_prismjs_components_prism_javascript__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_prismjs_components_prism_perl__ = __webpack_require__(17);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_prismjs_components_prism_perl___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_prismjs_components_prism_perl__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_prismjs_components_prism_php__ = __webpack_require__(18);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_prismjs_components_prism_php___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_prismjs_components_prism_php__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_prismjs_components_prism_python__ = __webpack_require__(19);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_prismjs_components_prism_python___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_prismjs_components_prism_python__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_prismjs_components_prism_sass__ = __webpack_require__(20);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_prismjs_components_prism_sass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_prismjs_components_prism_sass__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_prismjs_components_prism_scss__ = __webpack_require__(21);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_prismjs_components_prism_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_prismjs_components_prism_scss__);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_prismjs_components_prism_typescript__ = __webpack_require__(22);
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_prismjs_components_prism_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_prismjs_components_prism_typescript__);
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * marked - a markdown parser
	 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
	 * https://github.com/chjj/marked
	 */
	
	;(function() {
	
	/**
	 * Block-Level Grammar
	 */
	
	var block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: noop,
	  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
	  nptable: noop,
	  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
	  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
	  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
	  table: noop,
	  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
	  text: /^[^\n]+/
	};
	
	block.bullet = /(?:[*+-]|\d+\.)/;
	block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
	block.item = replace(block.item, 'gm')
	  (/bull/g, block.bullet)
	  ();
	
	block.list = replace(block.list)
	  (/bull/g, block.bullet)
	  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
	  ('def', '\\n+(?=' + block.def.source + ')')
	  ();
	
	block.blockquote = replace(block.blockquote)
	  ('def', block.def)
	  ();
	
	block._tag = '(?!(?:'
	  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
	  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
	  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
	
	block.html = replace(block.html)
	  ('comment', /<!--[\s\S]*?-->/)
	  ('closed', /<(tag)[\s\S]+?<\/\1>/)
	  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
	  (/tag/g, block._tag)
	  ();
	
	block.paragraph = replace(block.paragraph)
	  ('hr', block.hr)
	  ('heading', block.heading)
	  ('lheading', block.lheading)
	  ('blockquote', block.blockquote)
	  ('tag', '<' + block._tag)
	  ('def', block.def)
	  ();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
	  paragraph: /^/,
	  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
	});
	
	block.gfm.paragraph = replace(block.paragraph)
	  ('(?!', '(?!'
	    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
	    + block.list.source.replace('\\1', '\\3') + '|')
	  ();
	
	/**
	 * GFM + Tables Block Grammar
	 */
	
	block.tables = merge({}, block.gfm, {
	  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
	  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
	});
	
	/**
	 * Block Lexer
	 */
	
	function Lexer(options) {
	  this.tokens = [];
	  this.tokens.links = {};
	  this.options = options || marked.defaults;
	  this.rules = block.normal;
	
	  if (this.options.gfm) {
	    if (this.options.tables) {
	      this.rules = block.tables;
	    } else {
	      this.rules = block.gfm;
	    }
	  }
	}
	
	/**
	 * Expose Block Rules
	 */
	
	Lexer.rules = block;
	
	/**
	 * Static Lex Method
	 */
	
	Lexer.lex = function(src, options) {
	  var lexer = new Lexer(options);
	  return lexer.lex(src);
	};
	
	/**
	 * Preprocessing
	 */
	
	Lexer.prototype.lex = function(src) {
	  src = src
	    .replace(/\r\n|\r/g, '\n')
	    .replace(/\t/g, '    ')
	    .replace(/\u00a0/g, ' ')
	    .replace(/\u2424/g, '\n');
	
	  return this.token(src, true);
	};
	
	/**
	 * Lexing
	 */
	
	Lexer.prototype.token = function(src, top, bq) {
	  var src = src.replace(/^ +$/gm, '')
	    , next
	    , loose
	    , cap
	    , bull
	    , b
	    , item
	    , space
	    , i
	    , l;
	
	  while (src) {
	    // newline
	    if (cap = this.rules.newline.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[0].length > 1) {
	        this.tokens.push({
	          type: 'space'
	        });
	      }
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      cap = cap[0].replace(/^ {4}/gm, '');
	      this.tokens.push({
	        type: 'code',
	        text: !this.options.pedantic
	          ? cap.replace(/\n+$/, '')
	          : cap
	      });
	      continue;
	    }
	
	    // fences (gfm)
	    if (cap = this.rules.fences.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'code',
	        lang: cap[2],
	        text: cap[3] || ''
	      });
	      continue;
	    }
	
	    // heading
	    if (cap = this.rules.heading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[1].length,
	        text: cap[2]
	      });
	      continue;
	    }
	
	    // table no leading pipe (gfm)
	    if (top && (cap = this.rules.nptable.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i].split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // lheading
	    if (cap = this.rules.lheading.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'heading',
	        depth: cap[2] === '=' ? 1 : 2,
	        text: cap[1]
	      });
	      continue;
	    }
	
	    // hr
	    if (cap = this.rules.hr.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'hr'
	      });
	      continue;
	    }
	
	    // blockquote
	    if (cap = this.rules.blockquote.exec(src)) {
	      src = src.substring(cap[0].length);
	
	      this.tokens.push({
	        type: 'blockquote_start'
	      });
	
	      cap = cap[0].replace(/^ *> ?/gm, '');
	
	      // Pass `top` to keep the current
	      // "toplevel" state. This is exactly
	      // how markdown.pl works.
	      this.token(cap, top, true);
	
	      this.tokens.push({
	        type: 'blockquote_end'
	      });
	
	      continue;
	    }
	
	    // list
	    if (cap = this.rules.list.exec(src)) {
	      src = src.substring(cap[0].length);
	      bull = cap[2];
	
	      this.tokens.push({
	        type: 'list_start',
	        ordered: bull.length > 1
	      });
	
	      // Get each top-level item.
	      cap = cap[0].match(this.rules.item);
	
	      next = false;
	      l = cap.length;
	      i = 0;
	
	      for (; i < l; i++) {
	        item = cap[i];
	
	        // Remove the list item's bullet
	        // so it is seen as the next token.
	        space = item.length;
	        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
	
	        // Outdent whatever the
	        // list item contains. Hacky.
	        if (~item.indexOf('\n ')) {
	          space -= item.length;
	          item = !this.options.pedantic
	            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	            : item.replace(/^ {1,4}/gm, '');
	        }
	
	        // Determine whether the next list item belongs here.
	        // Backpedal if it does not belong in this list.
	        if (this.options.smartLists && i !== l - 1) {
	          b = block.bullet.exec(cap[i + 1])[0];
	          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
	            src = cap.slice(i + 1).join('\n') + src;
	            i = l - 1;
	          }
	        }
	
	        // Determine whether item is loose or not.
	        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	        // for discount behavior.
	        loose = next || /\n\n(?!\s*$)/.test(item);
	        if (i !== l - 1) {
	          next = item.charAt(item.length - 1) === '\n';
	          if (!loose) loose = next;
	        }
	
	        this.tokens.push({
	          type: loose
	            ? 'loose_item_start'
	            : 'list_item_start'
	        });
	
	        // Recurse.
	        this.token(item, false, bq);
	
	        this.tokens.push({
	          type: 'list_item_end'
	        });
	      }
	
	      this.tokens.push({
	        type: 'list_end'
	      });
	
	      continue;
	    }
	
	    // html
	    if (cap = this.rules.html.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: this.options.sanitize
	          ? 'paragraph'
	          : 'html',
	        pre: !this.options.sanitizer
	          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	        text: cap[0]
	      });
	      continue;
	    }
	
	    // def
	    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.links[cap[1].toLowerCase()] = {
	        href: cap[2],
	        title: cap[3]
	      };
	      continue;
	    }
	
	    // table (gfm)
	    if (top && (cap = this.rules.table.exec(src))) {
	      src = src.substring(cap[0].length);
	
	      item = {
	        type: 'table',
	        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
	        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
	      };
	
	      for (i = 0; i < item.align.length; i++) {
	        if (/^ *-+: *$/.test(item.align[i])) {
	          item.align[i] = 'right';
	        } else if (/^ *:-+: *$/.test(item.align[i])) {
	          item.align[i] = 'center';
	        } else if (/^ *:-+ *$/.test(item.align[i])) {
	          item.align[i] = 'left';
	        } else {
	          item.align[i] = null;
	        }
	      }
	
	      for (i = 0; i < item.cells.length; i++) {
	        item.cells[i] = item.cells[i]
	          .replace(/^ *\| *| *\| *$/g, '')
	          .split(/ *\| */);
	      }
	
	      this.tokens.push(item);
	
	      continue;
	    }
	
	    // top-level paragraph
	    if (top && (cap = this.rules.paragraph.exec(src))) {
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'paragraph',
	        text: cap[1].charAt(cap[1].length - 1) === '\n'
	          ? cap[1].slice(0, -1)
	          : cap[1]
	      });
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      // Top-level should never reach here.
	      src = src.substring(cap[0].length);
	      this.tokens.push({
	        type: 'text',
	        text: cap[0]
	      });
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return this.tokens;
	};
	
	/**
	 * Inline-Level Grammar
	 */
	
	var inline = {
	  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
	  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
	  url: noop,
	  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
	  link: /^!?\[(inside)\]\(href\)/,
	  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
	  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
	  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
	  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
	  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
	  br: /^ {2,}\n(?!\s*$)/,
	  del: noop,
	  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
	};
	
	inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
	inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
	
	inline.link = replace(inline.link)
	  ('inside', inline._inside)
	  ('href', inline._href)
	  ();
	
	inline.reflink = replace(inline.reflink)
	  ('inside', inline._inside)
	  ();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: replace(inline.escape)('])', '~|])')(),
	  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
	  del: /^~~(?=\S)([\s\S]*?\S)~~/,
	  text: replace(inline.text)
	    (']|', '~]|')
	    ('|', '|https?://|')
	    ()
	});
	
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: replace(inline.br)('{2,}', '*')(),
	  text: replace(inline.gfm.text)('{2,}', '*')()
	});
	
	/**
	 * Inline Lexer & Compiler
	 */
	
	function InlineLexer(links, options) {
	  this.options = options || marked.defaults;
	  this.links = links;
	  this.rules = inline.normal;
	  this.renderer = this.options.renderer || new Renderer;
	  this.renderer.options = this.options;
	
	  if (!this.links) {
	    throw new
	      Error('Tokens array requires a `links` property.');
	  }
	
	  if (this.options.gfm) {
	    if (this.options.breaks) {
	      this.rules = inline.breaks;
	    } else {
	      this.rules = inline.gfm;
	    }
	  } else if (this.options.pedantic) {
	    this.rules = inline.pedantic;
	  }
	}
	
	/**
	 * Expose Inline Rules
	 */
	
	InlineLexer.rules = inline;
	
	/**
	 * Static Lexing/Compiling Method
	 */
	
	InlineLexer.output = function(src, links, options) {
	  var inline = new InlineLexer(links, options);
	  return inline.output(src);
	};
	
	/**
	 * Lexing/Compiling
	 */
	
	InlineLexer.prototype.output = function(src) {
	  var out = ''
	    , link
	    , text
	    , href
	    , cap;
	
	  while (src) {
	    // escape
	    if (cap = this.rules.escape.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += cap[1];
	      continue;
	    }
	
	    // autolink
	    if (cap = this.rules.autolink.exec(src)) {
	      src = src.substring(cap[0].length);
	      if (cap[2] === '@') {
	        text = cap[1].charAt(6) === ':'
	          ? this.mangle(cap[1].substring(7))
	          : this.mangle(cap[1]);
	        href = this.mangle('mailto:') + text;
	      } else {
	        text = escape(cap[1]);
	        href = text;
	      }
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // url (gfm)
	    if (!this.inLink && (cap = this.rules.url.exec(src))) {
	      src = src.substring(cap[0].length);
	      text = escape(cap[1]);
	      href = text;
	      out += this.renderer.link(href, null, text);
	      continue;
	    }
	
	    // tag
	    if (cap = this.rules.tag.exec(src)) {
	      if (!this.inLink && /^<a /i.test(cap[0])) {
	        this.inLink = true;
	      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	        this.inLink = false;
	      }
	      src = src.substring(cap[0].length);
	      out += this.options.sanitize
	        ? this.options.sanitizer
	          ? this.options.sanitizer(cap[0])
	          : escape(cap[0])
	        : cap[0]
	      continue;
	    }
	
	    // link
	    if (cap = this.rules.link.exec(src)) {
	      src = src.substring(cap[0].length);
	      this.inLink = true;
	      out += this.outputLink(cap, {
	        href: cap[2],
	        title: cap[3]
	      });
	      this.inLink = false;
	      continue;
	    }
	
	    // reflink, nolink
	    if ((cap = this.rules.reflink.exec(src))
	        || (cap = this.rules.nolink.exec(src))) {
	      src = src.substring(cap[0].length);
	      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	      link = this.links[link.toLowerCase()];
	      if (!link || !link.href) {
	        out += cap[0].charAt(0);
	        src = cap[0].substring(1) + src;
	        continue;
	      }
	      this.inLink = true;
	      out += this.outputLink(cap, link);
	      this.inLink = false;
	      continue;
	    }
	
	    // strong
	    if (cap = this.rules.strong.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.strong(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // em
	    if (cap = this.rules.em.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.em(this.output(cap[2] || cap[1]));
	      continue;
	    }
	
	    // code
	    if (cap = this.rules.code.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.codespan(escape(cap[2], true));
	      continue;
	    }
	
	    // br
	    if (cap = this.rules.br.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.br();
	      continue;
	    }
	
	    // del (gfm)
	    if (cap = this.rules.del.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.del(this.output(cap[1]));
	      continue;
	    }
	
	    // text
	    if (cap = this.rules.text.exec(src)) {
	      src = src.substring(cap[0].length);
	      out += this.renderer.text(escape(this.smartypants(cap[0])));
	      continue;
	    }
	
	    if (src) {
	      throw new
	        Error('Infinite loop on byte: ' + src.charCodeAt(0));
	    }
	  }
	
	  return out;
	};
	
	/**
	 * Compile Link
	 */
	
	InlineLexer.prototype.outputLink = function(cap, link) {
	  var href = escape(link.href)
	    , title = link.title ? escape(link.title) : null;
	
	  return cap[0].charAt(0) !== '!'
	    ? this.renderer.link(href, title, this.output(cap[1]))
	    : this.renderer.image(href, title, escape(cap[1]));
	};
	
	/**
	 * Smartypants Transformations
	 */
	
	InlineLexer.prototype.smartypants = function(text) {
	  if (!this.options.smartypants) return text;
	  return text
	    // em-dashes
	    .replace(/---/g, '\u2014')
	    // en-dashes
	    .replace(/--/g, '\u2013')
	    // opening singles
	    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	    // closing singles & apostrophes
	    .replace(/'/g, '\u2019')
	    // opening doubles
	    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	    // closing doubles
	    .replace(/"/g, '\u201d')
	    // ellipses
	    .replace(/\.{3}/g, '\u2026');
	};
	
	/**
	 * Mangle Links
	 */
	
	InlineLexer.prototype.mangle = function(text) {
	  if (!this.options.mangle) return text;
	  var out = ''
	    , l = text.length
	    , i = 0
	    , ch;
	
	  for (; i < l; i++) {
	    ch = text.charCodeAt(i);
	    if (Math.random() > 0.5) {
	      ch = 'x' + ch.toString(16);
	    }
	    out += '&#' + ch + ';';
	  }
	
	  return out;
	};
	
	/**
	 * Renderer
	 */
	
	function Renderer(options) {
	  this.options = options || {};
	}
	
	Renderer.prototype.code = function(code, lang, escaped) {
	  if (this.options.highlight) {
	    var out = this.options.highlight(code, lang);
	    if (out != null && out !== code) {
	      escaped = true;
	      code = out;
	    }
	  }
	
	  if (!lang) {
	    return '<pre><code>'
	      + (escaped ? code : escape(code, true))
	      + '\n</code></pre>';
	  }
	
	  return '<pre><code class="'
	    + this.options.langPrefix
	    + escape(lang, true)
	    + '">'
	    + (escaped ? code : escape(code, true))
	    + '\n</code></pre>\n';
	};
	
	Renderer.prototype.blockquote = function(quote) {
	  return '<blockquote>\n' + quote + '</blockquote>\n';
	};
	
	Renderer.prototype.html = function(html) {
	  return html;
	};
	
	Renderer.prototype.heading = function(text, level, raw) {
	  return '<h'
	    + level
	    + ' id="'
	    + this.options.headerPrefix
	    + raw.toLowerCase().replace(/[^\w]+/g, '-')
	    + '">'
	    + text
	    + '</h'
	    + level
	    + '>\n';
	};
	
	Renderer.prototype.hr = function() {
	  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	};
	
	Renderer.prototype.list = function(body, ordered) {
	  var type = ordered ? 'ol' : 'ul';
	  return '<' + type + '>\n' + body + '</' + type + '>\n';
	};
	
	Renderer.prototype.listitem = function(text) {
	  return '<li>' + text + '</li>\n';
	};
	
	Renderer.prototype.paragraph = function(text) {
	  return '<p>' + text + '</p>\n';
	};
	
	Renderer.prototype.table = function(header, body) {
	  return '<table>\n'
	    + '<thead>\n'
	    + header
	    + '</thead>\n'
	    + '<tbody>\n'
	    + body
	    + '</tbody>\n'
	    + '</table>\n';
	};
	
	Renderer.prototype.tablerow = function(content) {
	  return '<tr>\n' + content + '</tr>\n';
	};
	
	Renderer.prototype.tablecell = function(content, flags) {
	  var type = flags.header ? 'th' : 'td';
	  var tag = flags.align
	    ? '<' + type + ' style="text-align:' + flags.align + '">'
	    : '<' + type + '>';
	  return tag + content + '</' + type + '>\n';
	};
	
	// span level renderer
	Renderer.prototype.strong = function(text) {
	  return '<strong>' + text + '</strong>';
	};
	
	Renderer.prototype.em = function(text) {
	  return '<em>' + text + '</em>';
	};
	
	Renderer.prototype.codespan = function(text) {
	  return '<code>' + text + '</code>';
	};
	
	Renderer.prototype.br = function() {
	  return this.options.xhtml ? '<br/>' : '<br>';
	};
	
	Renderer.prototype.del = function(text) {
	  return '<del>' + text + '</del>';
	};
	
	Renderer.prototype.link = function(href, title, text) {
	  if (this.options.sanitize) {
	    try {
	      var prot = decodeURIComponent(unescape(href))
	        .replace(/[^\w:]/g, '')
	        .toLowerCase();
	    } catch (e) {
	      return '';
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
	      return '';
	    }
	  }
	  var out = '<a href="' + href + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += '>' + text + '</a>';
	  return out;
	};
	
	Renderer.prototype.image = function(href, title, text) {
	  var out = '<img src="' + href + '" alt="' + text + '"';
	  if (title) {
	    out += ' title="' + title + '"';
	  }
	  out += this.options.xhtml ? '/>' : '>';
	  return out;
	};
	
	Renderer.prototype.text = function(text) {
	  return text;
	};
	
	/**
	 * Parsing & Compiling
	 */
	
	function Parser(options) {
	  this.tokens = [];
	  this.token = null;
	  this.options = options || marked.defaults;
	  this.options.renderer = this.options.renderer || new Renderer;
	  this.renderer = this.options.renderer;
	  this.renderer.options = this.options;
	}
	
	/**
	 * Static Parse Method
	 */
	
	Parser.parse = function(src, options, renderer) {
	  var parser = new Parser(options, renderer);
	  return parser.parse(src);
	};
	
	/**
	 * Parse Loop
	 */
	
	Parser.prototype.parse = function(src) {
	  this.inline = new InlineLexer(src.links, this.options, this.renderer);
	  this.tokens = src.reverse();
	
	  var out = '';
	  while (this.next()) {
	    out += this.tok();
	  }
	
	  return out;
	};
	
	/**
	 * Next Token
	 */
	
	Parser.prototype.next = function() {
	  return this.token = this.tokens.pop();
	};
	
	/**
	 * Preview Next Token
	 */
	
	Parser.prototype.peek = function() {
	  return this.tokens[this.tokens.length - 1] || 0;
	};
	
	/**
	 * Parse Text Tokens
	 */
	
	Parser.prototype.parseText = function() {
	  var body = this.token.text;
	
	  while (this.peek().type === 'text') {
	    body += '\n' + this.next().text;
	  }
	
	  return this.inline.output(body);
	};
	
	/**
	 * Parse Current Token
	 */
	
	Parser.prototype.tok = function() {
	  switch (this.token.type) {
	    case 'space': {
	      return '';
	    }
	    case 'hr': {
	      return this.renderer.hr();
	    }
	    case 'heading': {
	      return this.renderer.heading(
	        this.inline.output(this.token.text),
	        this.token.depth,
	        this.token.text);
	    }
	    case 'code': {
	      return this.renderer.code(this.token.text,
	        this.token.lang,
	        this.token.escaped);
	    }
	    case 'table': {
	      var header = ''
	        , body = ''
	        , i
	        , row
	        , cell
	        , flags
	        , j;
	
	      // header
	      cell = '';
	      for (i = 0; i < this.token.header.length; i++) {
	        flags = { header: true, align: this.token.align[i] };
	        cell += this.renderer.tablecell(
	          this.inline.output(this.token.header[i]),
	          { header: true, align: this.token.align[i] }
	        );
	      }
	      header += this.renderer.tablerow(cell);
	
	      for (i = 0; i < this.token.cells.length; i++) {
	        row = this.token.cells[i];
	
	        cell = '';
	        for (j = 0; j < row.length; j++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(row[j]),
	            { header: false, align: this.token.align[j] }
	          );
	        }
	
	        body += this.renderer.tablerow(cell);
	      }
	      return this.renderer.table(header, body);
	    }
	    case 'blockquote_start': {
	      var body = '';
	
	      while (this.next().type !== 'blockquote_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.blockquote(body);
	    }
	    case 'list_start': {
	      var body = ''
	        , ordered = this.token.ordered;
	
	      while (this.next().type !== 'list_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.list(body, ordered);
	    }
	    case 'list_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.token.type === 'text'
	          ? this.parseText()
	          : this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'loose_item_start': {
	      var body = '';
	
	      while (this.next().type !== 'list_item_end') {
	        body += this.tok();
	      }
	
	      return this.renderer.listitem(body);
	    }
	    case 'html': {
	      var html = !this.token.pre && !this.options.pedantic
	        ? this.inline.output(this.token.text)
	        : this.token.text;
	      return this.renderer.html(html);
	    }
	    case 'paragraph': {
	      return this.renderer.paragraph(this.inline.output(this.token.text));
	    }
	    case 'text': {
	      return this.renderer.paragraph(this.parseText());
	    }
	  }
	};
	
	/**
	 * Helpers
	 */
	
	function escape(html, encode) {
	  return html
	    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#39;');
	}
	
	function unescape(html) {
		// explicitly match decimal, hex, and named HTML entities 
	  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	function replace(regex, opt) {
	  regex = regex.source;
	  opt = opt || '';
	  return function self(name, val) {
	    if (!name) return new RegExp(regex, opt);
	    val = val.source || val;
	    val = val.replace(/(^|[^\[])\^/g, '$1');
	    regex = regex.replace(name, val);
	    return self;
	  };
	}
	
	function noop() {}
	noop.exec = noop;
	
	function merge(obj) {
	  var i = 1
	    , target
	    , key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	
	/**
	 * Marked
	 */
	
	function marked(src, opt, callback) {
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	
	    var highlight = opt.highlight
	      , tokens
	      , pending
	      , i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt)
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    var done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      var out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    if (opt) opt = merge({}, marked.defaults, opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/chjj/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occured:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  return marked;
	};
	
	marked.defaults = {
	  gfm: true,
	  tables: true,
	  breaks: false,
	  pedantic: false,
	  sanitize: false,
	  sanitizer: null,
	  mangle: true,
	  smartLists: false,
	  silent: false,
	  highlight: null,
	  langPrefix: 'lang-',
	  smartypants: false,
	  headerPrefix: '',
	  renderer: new Renderer,
	  xhtml: false
	};
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.parse = marked;
	
	if (true) {
	  module.exports = marked;
	} else if (typeof define === 'function' && define.amd) {
	  define(function() { return marked; });
	} else {
	  this.marked = marked;
	}
	
	}).call(function() {
	  return this || (typeof window !== 'undefined' ? window : global);
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))
	
	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {
	
	Prism.languages.c = Prism.languages.extend('clike', {
		'keyword': /\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
		'operator': /\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,
		'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i
	});
	
	Prism.languages.insertBefore('c', 'string', {
		'macro': {
			// allow for multiline macro definitions
			// spaces after the # character compile fine with gcc
			pattern: /(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,
			lookbehind: true,
			alias: 'property',
			inside: {
				// highlight the path of the include statement as a string
				'string': {
					pattern: /(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,
					lookbehind: true
				},
				// highlight macro directives as keywords
				'directive': {
					pattern: /(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,
					lookbehind: true,
					alias: 'keyword'
				}
			}
		},
		// highlight predefined macros as constants
		'constant': /\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/
	});
	
	delete Prism.languages.c['class-name'];
	delete Prism.languages.c['boolean'];
	
	
	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {
	
	Prism.languages.cpp = Prism.languages.extend('c', {
		'keyword': /\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
		'boolean': /\b(true|false)\b/,
		'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
	});
	
	Prism.languages.insertBefore('cpp', 'keyword', {
		'class-name': {
			pattern: /(class\s+)[a-z0-9_]+/i,
			lookbehind: true
		}
	});
	
	/***/ }),
	/* 12 */
	/***/ (function(module, exports) {
	
	Prism.languages.csharp = Prism.languages.extend('clike', {
		'keyword': /\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/,
		'string': [
			/@("|')(\1\1|\\\1|\\?(?!\1)[\s\S])*\1/,
			/("|')(\\?.)*?\1/
		],
		'number': /\b-?(0x[\da-f]+|\d*\.?\d+f?)\b/i
	});
	
	Prism.languages.insertBefore('csharp', 'keyword', {
		'generic-method': {
			pattern: /[a-z0-9_]+\s*<[^>\r\n]+?>\s*(?=\()/i,
			alias: 'function',
			inside: {
				keyword: Prism.languages.csharp.keyword,
				punctuation: /[<>(),.:]/
			}
		},
		'preprocessor': {
			pattern: /(^\s*)#.*/m,
			lookbehind: true,
			alias: 'property',
			inside: {
				// highlight preprocessor directives as keywords
				'directive': {
					pattern: /(\s*#)\b(define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,
					lookbehind: true,
					alias: 'keyword'
				}
			}
		}
	});
	
	
	/***/ }),
	/* 13 */
	/***/ (function(module, exports) {
	
	Prism.languages.css = {
		'comment': /\/\*[\w\W]*?\*\//,
		'atrule': {
			pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
		'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
		'string': {
			pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		'property': /(\b|\B)[\w-]+(?=\s*:)/i,
		'important': /\B!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:]/
	};
	
	Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'style': {
				pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
				lookbehind: true,
				inside: Prism.languages.css,
				alias: 'language-css'
			}
		});
		
		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /\s*style=("|').*?\1/i,
				inside: {
					'attr-name': {
						pattern: /^\s*style/i,
						inside: Prism.languages.markup.tag.inside
					},
					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
					'attr-value': {
						pattern: /.+/i,
						inside: Prism.languages.css
					}
				},
				alias: 'language-css'
			}
		}, Prism.languages.markup.tag);
	}
	
	/***/ }),
	/* 14 */
	/***/ (function(module, exports) {
	
	Prism.languages.diff = {
		'coord': [
			// Match all kinds of coord lines (prefixed by "+++", "---" or "***").
			/^(?:\*{3}|-{3}|\+{3}).*$/m,
			// Match "@@ ... @@" coord lines in unified diff.
			/^@@.*@@$/m,
			// Match coord lines in normal diff (starts with a number).
			/^\d+.*$/m
		],
	
		// Match inserted and deleted lines. Support both +/- and >/< styles.
		'deleted': /^[-<].*$/m,
		'inserted': /^[+>].*$/m,
	
		// Match "different" lines (prefixed with "!") in context diff.
		'diff': {
			'pattern': /^!(?!!).+$/m,
			'alias': 'important'
		}
	};
	
	
	/***/ }),
	/* 15 */
	/***/ (function(module, exports) {
	
	Prism.languages.java = Prism.languages.extend('clike', {
		'keyword': /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
		'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
		'operator': {
			pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
			lookbehind: true
		}
	});
	
	Prism.languages.insertBefore('java','function', {
		'annotation': {
			alias: 'punctuation',
			pattern: /(^|[^.])@\w+/,
			lookbehind: true
		}
	});
	
	
	/***/ }),
	/* 16 */
	/***/ (function(module, exports) {
	
	Prism.languages.javascript = Prism.languages.extend('clike', {
		'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
		'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
		'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
		'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
	});
	
	Prism.languages.insertBefore('javascript', 'keyword', {
		'regex': {
			pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
			lookbehind: true,
			greedy: true
		}
	});
	
	Prism.languages.insertBefore('javascript', 'string', {
		'template-string': {
			pattern: /`(?:\\\\|\\?[^\\])*?`/,
			greedy: true,
			inside: {
				'interpolation': {
					pattern: /\$\{[^}]+\}/,
					inside: {
						'interpolation-punctuation': {
							pattern: /^\$\{|\}$/,
							alias: 'punctuation'
						},
						rest: Prism.languages.javascript
					}
				},
				'string': /[\s\S]+/
			}
		}
	});
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'script': {
				pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
				lookbehind: true,
				inside: Prism.languages.javascript,
				alias: 'language-javascript'
			}
		});
	}
	
	Prism.languages.js = Prism.languages.javascript;
	
	/***/ }),
	/* 17 */
	/***/ (function(module, exports) {
	
	Prism.languages.perl = {
		'comment': [
			{
				// POD
				pattern: /(^\s*)=\w+[\s\S]*?=cut.*/m,
				lookbehind: true
			},
			{
				pattern: /(^|[^\\$])#.*/,
				lookbehind: true
			}
		],
		// TODO Could be nice to handle Heredoc too.
		'string': [
			// q/.../
			/\b(?:q|qq|qx|qw)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,
		
			// q a...a
			/\b(?:q|qq|qx|qw)\s+([a-zA-Z0-9])(?:[^\\]|\\[\s\S])*?\1/,
		
			// q(...)
			/\b(?:q|qq|qx|qw)\s*\((?:[^()\\]|\\[\s\S])*\)/,
		
			// q{...}
			/\b(?:q|qq|qx|qw)\s*\{(?:[^{}\\]|\\[\s\S])*\}/,
		
			// q[...]
			/\b(?:q|qq|qx|qw)\s*\[(?:[^[\]\\]|\\[\s\S])*\]/,
		
			// q<...>
			/\b(?:q|qq|qx|qw)\s*<(?:[^<>\\]|\\[\s\S])*>/,
	
			// "...", `...`
			/("|`)(?:[^\\]|\\[\s\S])*?\1/,
	
			// '...'
			// FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
			/'(?:[^'\\\r\n]|\\.)*'/
		],
		'regex': [
			// m/.../
			/\b(?:m|qr)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[msixpodualngc]*/,
		
			// m a...a
			/\b(?:m|qr)\s+([a-zA-Z0-9])(?:[^\\]|\\.)*?\1[msixpodualngc]*/,
		
			// m(...)
			/\b(?:m|qr)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngc]*/,
		
			// m{...}
			/\b(?:m|qr)\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngc]*/,
		
			// m[...]
			/\b(?:m|qr)\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngc]*/,
		
			// m<...>
			/\b(?:m|qr)\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngc]*/,
	
			// The lookbehinds prevent -s from breaking
			// FIXME We don't handle change of separator like s(...)[...]
			// s/.../.../
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s*([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\2(?:[^\\]|\\[\s\S])*?\2[msixpodualngcer]*/,
				lookbehind: true
			},
		
			// s a...a...a
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s+([a-zA-Z0-9])(?:[^\\]|\\[\s\S])*?\2(?:[^\\]|\\[\s\S])*?\2[msixpodualngcer]*/,
				lookbehind: true
			},
		
			// s(...)(...)
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s*\((?:[^()\\]|\\[\s\S])*\)\s*\((?:[^()\\]|\\[\s\S])*\)[msixpodualngcer]*/,
				lookbehind: true
			},
		
			// s{...}{...}
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s*\{(?:[^{}\\]|\\[\s\S])*\}\s*\{(?:[^{}\\]|\\[\s\S])*\}[msixpodualngcer]*/,
				lookbehind: true
			},
		
			// s[...][...]
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s*\[(?:[^[\]\\]|\\[\s\S])*\]\s*\[(?:[^[\]\\]|\\[\s\S])*\][msixpodualngcer]*/,
				lookbehind: true
			},
		
			// s<...><...>
			{
				pattern: /(^|[^-]\b)(?:s|tr|y)\s*<(?:[^<>\\]|\\[\s\S])*>\s*<(?:[^<>\\]|\\[\s\S])*>[msixpodualngcer]*/,
				lookbehind: true
			},
		
			// /.../
			// The look-ahead tries to prevent two divisions on
			// the same line from being highlighted as regex.
			// This does not support multi-line regex.
			/\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor|x)\b))/
		],
	
		// FIXME Not sure about the handling of ::, ', and #
		'variable': [
			// ${^POSTMATCH}
			/[&*$@%]\{\^[A-Z]+\}/,
			// $^V
			/[&*$@%]\^[A-Z_]/,
			// ${...}
			/[&*$@%]#?(?=\{)/,
			// $foo
			/[&*$@%]#?((::)*'?(?!\d)[\w$]+)+(::)*/i,
			// $1
			/[&*$@%]\d+/,
			// $_, @_, %!
			// The negative lookahead prevents from breaking the %= operator
			/(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
		],
		'filehandle': {
			// <>, <FOO>, _
			pattern: /<(?![<=])\S*>|\b_\b/,
			alias: 'symbol'
		},
		'vstring': {
			// v1.2, 1.2.3
			pattern: /v\d+(\.\d+)*|\d+(\.\d+){2,}/,
			alias: 'string'
		},
		'function': {
			pattern: /sub [a-z0-9_]+/i,
			inside: {
				keyword: /sub/
			}
		},
		'keyword': /\b(any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
		'number': /\b-?(0x[\dA-Fa-f](_?[\dA-Fa-f])*|0b[01](_?[01])*|(\d(_?\d)*)?\.?\d(_?\d)*([Ee][+-]?\d+)?)\b/,
		'operator': /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(lt|gt|le|ge|eq|ne|cmp|not|and|or|xor)\b/,
		'punctuation': /[{}[\];(),:]/
	};
	
	
	/***/ }),
	/* 18 */
	/***/ (function(module, exports) {
	
	/**
	 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
	 * Modified by Miles Johnson: http://milesj.me
	 *
	 * Supports the following:
	 * 		- Extends clike syntax
	 * 		- Support for PHP 5.3+ (namespaces, traits, generators, etc)
	 * 		- Smarter constant and function matching
	 *
	 * Adds the following new token classes:
	 * 		constant, delimiter, variable, function, package
	 */
	
	Prism.languages.php = Prism.languages.extend('clike', {
		'keyword': /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
		'constant': /\b[A-Z0-9_]{2,}\b/,
		'comment': {
			pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,
			lookbehind: true,
			greedy: true
		}
	});
	
	// Shell-like comments are matched after strings, because they are less
	// common than strings containing hashes...
	Prism.languages.insertBefore('php', 'class-name', {
		'shell-comment': {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true,
			alias: 'comment'
		}
	});
	
	Prism.languages.insertBefore('php', 'keyword', {
		'delimiter': /\?>|<\?(?:php)?/i,
		'variable': /\$\w+\b/i,
		'package': {
			pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
			lookbehind: true,
			inside: {
				punctuation: /\\/
			}
		}
	});
	
	// Must be defined after the function pattern
	Prism.languages.insertBefore('php', 'operator', {
		'property': {
			pattern: /(->)[\w]+/,
			lookbehind: true
		}
	});
	
	// Add HTML support of the markup language exists
	if (Prism.languages.markup) {
	
		// Tokenize all inline PHP blocks that are wrapped in <?php ?>
		// This allows for easy PHP + markup highlighting
		Prism.hooks.add('before-highlight', function(env) {
			if (env.language !== 'php') {
				return;
			}
	
			env.tokenStack = [];
	
			env.backupCode = env.code;
			env.code = env.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/ig, function(match) {
				env.tokenStack.push(match);
	
				return '{{{PHP' + env.tokenStack.length + '}}}';
			});
		});
	
		// Restore env.code for other plugins (e.g. line-numbers)
		Prism.hooks.add('before-insert', function(env) {
			if (env.language === 'php') {
				env.code = env.backupCode;
				delete env.backupCode;
			}
		});
	
		// Re-insert the tokens after highlighting
		Prism.hooks.add('after-highlight', function(env) {
			if (env.language !== 'php') {
				return;
			}
	
			for (var i = 0, t; t = env.tokenStack[i]; i++) {
				// The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
				env.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php').replace(/\$/g, '$$$$'));
			}
	
			env.element.innerHTML = env.highlightedCode;
		});
	
		// Wrap tokens in classes that are missing them
		Prism.hooks.add('wrap', function(env) {
			if (env.language === 'php' && env.type === 'markup') {
				env.content = env.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, "<span class=\"token php\">$1</span>");
			}
		});
	
		// Add the rules before all others
		Prism.languages.insertBefore('php', 'comment', {
			'markup': {
				pattern: /<[^?]\/?(.*?)>/,
				inside: Prism.languages.markup
			},
			'php': /\{\{\{PHP[0-9]+\}\}\}/
		});
	}
	
	
	/***/ }),
	/* 19 */
	/***/ (function(module, exports) {
	
	Prism.languages.python= {
		'triple-quoted-string': {
			pattern: /"""[\s\S]+?"""|'''[\s\S]+?'''/,
			alias: 'string'
		},
		'comment': {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true
		},
		'string': {
			pattern: /("|')(?:\\\\|\\?[^\\\r\n])*?\1/,
			greedy: true
		},
		'function' : {
			pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
			lookbehind: true
		},
		'class-name': {
			pattern: /(\bclass\s+)[a-z0-9_]+/i,
			lookbehind: true
		},
		'keyword' : /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
		'boolean' : /\b(?:True|False)\b/,
		'number' : /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
		'operator' : /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
		'punctuation' : /[{}[\];(),.:]/
	};
	
	
	/***/ }),
	/* 20 */
	/***/ (function(module, exports) {
	
	(function(Prism) {
		Prism.languages.sass = Prism.languages.extend('css', {
			// Sass comments don't need to be closed, only indented
			'comment': {
				pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,
				lookbehind: true
			}
		});
	
		Prism.languages.insertBefore('sass', 'atrule', {
			// We want to consume the whole line
			'atrule-line': {
				// Includes support for = and + shortcuts
				pattern: /^(?:[ \t]*)[@+=].+/m,
				inside: {
					'atrule': /(?:@[\w-]+|[+=])/m
				}
			}
		});
		delete Prism.languages.sass.atrule;
	
	
		var variable = /((\$[-_\w]+)|(#\{\$[-_\w]+\}))/i;
		var operator = [
			/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,
			{
				pattern: /(\s+)-(?=\s)/,
				lookbehind: true
			}
		];
	
		Prism.languages.insertBefore('sass', 'property', {
			// We want to consume the whole line
			'variable-line': {
				pattern: /^[ \t]*\$.+/m,
				inside: {
					'punctuation': /:/,
					'variable': variable,
					'operator': operator
				}
			},
			// We want to consume the whole line
			'property-line': {
				pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,
				inside: {
					'property': [
						/[^:\s]+(?=\s*:)/,
						{
							pattern: /(:)[^:\s]+/,
							lookbehind: true
						}
					],
					'punctuation': /:/,
					'variable': variable,
					'operator': operator,
					'important': Prism.languages.sass.important
				}
			}
		});
		delete Prism.languages.sass.property;
		delete Prism.languages.sass.important;
	
		// Now that whole lines for other patterns are consumed,
		// what's left should be selectors
		delete Prism.languages.sass.selector;
		Prism.languages.insertBefore('sass', 'punctuation', {
			'selector': {
				pattern: /([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,
				lookbehind: true
			}
		});
	
	}(Prism));
	
	/***/ }),
	/* 21 */
	/***/ (function(module, exports) {
	
	Prism.languages.scss = Prism.languages.extend('css', {
		'comment': {
			pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,
			lookbehind: true
		},
		'atrule': {
			pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		// url, compassified
		'url': /(?:[-a-z]+-)*url(?=\()/i,
		// CSS selector regex is not appropriate for Sass
		// since there can be lot more things (var, @ directive, nesting..)
		// a selector must start at the end of a property or after a brace (end of other rules or nesting)
		// it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
		// the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
		// can "pass" as a selector- e.g: proper#{$erty})
		// this one was hard to do, so please be careful if you edit this one :)
		'selector': {
			// Initial look-ahead is used to prevent matching of blank selectors
			pattern: /(?=\S)[^@;\{\}\(\)]?([^@;\{\}\(\)]|&|#\{\$[-_\w]+\})+(?=\s*\{(\}|\s|[^\}]+(:|\{)[^\}]+))/m,
			inside: {
				'parent': {
					pattern: /&/,
					alias: 'important'
				},
				'placeholder': /%[-_\w]+/,
				'variable': /\$[-_\w]+|#\{\$[-_\w]+\}/
			}
		}
	});
	
	Prism.languages.insertBefore('scss', 'atrule', {
		'keyword': [
			/@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,
			{
				pattern: /( +)(?:from|through)(?= )/,
				lookbehind: true
			}
		]
	});
	
	Prism.languages.scss.property = {
		pattern: /(?:[\w-]|\$[-_\w]+|#\{\$[-_\w]+\})+(?=\s*:)/i,
		inside: {
			'variable': /\$[-_\w]+|#\{\$[-_\w]+\}/
		}
	};
	
	Prism.languages.insertBefore('scss', 'important', {
		// var and interpolated vars
		'variable': /\$[-_\w]+|#\{\$[-_\w]+\}/
	});
	
	Prism.languages.insertBefore('scss', 'function', {
		'placeholder': {
			pattern: /%[-_\w]+/,
			alias: 'selector'
		},
		'statement': {
			pattern: /\B!(?:default|optional)\b/i,
			alias: 'keyword'
		},
		'boolean': /\b(?:true|false)\b/,
		'null': /\bnull\b/,
		'operator': {
			pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
			lookbehind: true
		}
	});
	
	Prism.languages.scss['atrule'].inside.rest = Prism.util.clone(Prism.languages.scss);
	
	/***/ }),
	/* 22 */
	/***/ (function(module, exports) {
	
	Prism.languages.typescript = Prism.languages.extend('javascript', {
		'keyword': /\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield|module|declare|constructor|string|Function|any|number|boolean|Array|enum)\b/
	});
	
	Prism.languages.ts = Prism.languages.typescript;
	
	/***/ }),
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {
	/* **********************************************
	     Begin prism-core.js
	********************************************** */
	
	var _self = (typeof window !== 'undefined')
		? window   // if in browser
		: (
			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
		);
	
	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 * MIT license http://www.opensource.org/licenses/mit-license.php/
	 * @author Lea Verou http://lea.verou.me
	 */
	
	var Prism = (function(){
	
	// Private helper vars
	var lang = /\blang(?:uage)?-(\w+)\b/i;
	var uniqueId = 0;
	
	var _ = _self.Prism = {
		util: {
			encode: function (tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
				} else if (_.util.type(tokens) === 'Array') {
					return tokens.map(_.util.encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},
	
			type: function (o) {
				return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
			},
	
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},
	
			// Deep clone a language definition (e.g. to extend it)
			clone: function (o) {
				var type = _.util.type(o);
	
				switch (type) {
					case 'Object':
						var clone = {};
	
						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = _.util.clone(o[key]);
							}
						}
	
						return clone;
	
					case 'Array':
						// Check for existence for IE8
						return o.map && o.map(function(v) { return _.util.clone(v); });
				}
	
				return o;
			}
		},
	
		languages: {
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);
	
				for (var key in redef) {
					lang[key] = redef[key];
				}
	
				return lang;
			},
	
			/**
			 * Insert a token before another token in a language literal
			 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
			 * we cannot just provide an object, we need anobject and a key.
			 * @param inside The key (or language id) of the parent
			 * @param before The key to insert before. If not provided, the function appends instead.
			 * @param insert Object with the key/value pairs to insert
			 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || _.languages;
				var grammar = root[inside];
	
				if (arguments.length == 2) {
					insert = arguments[1];
	
					for (var newToken in insert) {
						if (insert.hasOwnProperty(newToken)) {
							grammar[newToken] = insert[newToken];
						}
					}
	
					return grammar;
				}
	
				var ret = {};
	
				for (var token in grammar) {
	
					if (grammar.hasOwnProperty(token)) {
	
						if (token == before) {
	
							for (var newToken in insert) {
	
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}
	
						ret[token] = grammar[token];
					}
				}
	
				// Update references in other language definitions
				_.languages.DFS(_.languages, function(key, value) {
					if (value === root[inside] && key != inside) {
						this[key] = ret;
					}
				});
	
				return root[inside] = ret;
			},
	
			// Traverse a language definition with Depth First Search
			DFS: function(o, callback, type, visited) {
				visited = visited || {};
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);
	
						if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, null, visited);
						}
						else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
							visited[_.util.objId(o[i])] = true;
							_.languages.DFS(o[i], callback, i, visited);
						}
					}
				}
			}
		},
		plugins: {},
	
		highlightAll: function(async, callback) {
			var env = {
				callback: callback,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};
	
			_.hooks.run("before-highlightall", env);
	
			var elements = env.elements || document.querySelectorAll(env.selector);
	
			for (var i=0, element; element = elements[i++];) {
				_.highlightElement(element, async === true, env.callback);
			}
		},
	
		highlightElement: function(element, async, callback) {
			// Find language
			var language, grammar, parent = element;
	
			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}
	
			if (parent) {
				language = (parent.className.match(lang) || [,''])[1].toLowerCase();
				grammar = _.languages[language];
			}
	
			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
	
			// Set language on the parent, for styling
			parent = element.parentNode;
	
			if (/pre/i.test(parent.nodeName)) {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}
	
			var code = element.textContent;
	
			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};
	
			_.hooks.run('before-sanity-check', env);
	
			if (!env.code || !env.grammar) {
				if (env.code) {
					env.element.textContent = env.code;
				}
				_.hooks.run('complete', env);
				return;
			}
	
			_.hooks.run('before-highlight', env);
	
			if (async && _self.Worker) {
				var worker = new Worker(_.filename);
	
				worker.onmessage = function(evt) {
					env.highlightedCode = evt.data;
	
					_.hooks.run('before-insert', env);
	
					env.element.innerHTML = env.highlightedCode;
	
					callback && callback.call(env.element);
					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				};
	
				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			}
			else {
				env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
	
				_.hooks.run('before-insert', env);
	
				env.element.innerHTML = env.highlightedCode;
	
				callback && callback.call(element);
	
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			}
		},
	
		highlight: function (text, grammar, language) {
			var tokens = _.tokenize(text, grammar);
			return Token.stringify(_.util.encode(tokens), language);
		},
	
		tokenize: function(text, grammar, language) {
			var Token = _.Token;
	
			var strarr = [text];
	
			var rest = grammar.rest;
	
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}
	
				delete grammar.rest;
			}
	
			tokenloop: for (var token in grammar) {
				if(!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}
	
				var patterns = grammar[token];
				patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];
	
				for (var j = 0; j < patterns.length; ++j) {
					var pattern = patterns[j],
						inside = pattern.inside,
						lookbehind = !!pattern.lookbehind,
						greedy = !!pattern.greedy,
						lookbehindLength = 0,
						alias = pattern.alias;
	
					if (greedy && !pattern.pattern.global) {
						// Without the global flag, lastIndex won't work
						var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
						pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
					}
	
					pattern = pattern.pattern || pattern;
	
					// Don’t cache length as it changes during the loop
					for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {
	
						var str = strarr[i];
	
						if (strarr.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							break tokenloop;
						}
	
						if (str instanceof Token) {
							continue;
						}
	
						pattern.lastIndex = 0;
	
						var match = pattern.exec(str),
						    delNum = 1;
	
						// Greedy patterns can override/remove up to two previously matched tokens
						if (!match && greedy && i != strarr.length - 1) {
							pattern.lastIndex = pos;
							match = pattern.exec(text);
							if (!match) {
								break;
							}
	
							var from = match.index + (lookbehind ? match[1].length : 0),
							    to = match.index + match[0].length,
							    k = i,
							    p = pos;
	
							for (var len = strarr.length; k < len && p < to; ++k) {
								p += strarr[k].length;
								// Move the index i to the element in strarr that is closest to from
								if (from >= p) {
									++i;
									pos = p;
								}
							}
	
							/*
							 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
							 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
							 */
							if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
								continue;
							}
	
							// Number of tokens to delete and replace with the new match
							delNum = k - i;
							str = text.slice(pos, p);
							match.index -= pos;
						}
	
						if (!match) {
							continue;
						}
	
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}
	
						var from = match.index + lookbehindLength,
						    match = match[0].slice(lookbehindLength),
						    to = from + match.length,
						    before = str.slice(0, from),
						    after = str.slice(to);
	
						var args = [i, delNum];
	
						if (before) {
							args.push(before);
						}
	
						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);
	
						args.push(wrapped);
	
						if (after) {
							args.push(after);
						}
	
						Array.prototype.splice.apply(strarr, args);
					}
				}
			}
	
			return strarr;
		},
	
		hooks: {
			all: {},
	
			add: function (name, callback) {
				var hooks = _.hooks.all;
	
				hooks[name] = hooks[name] || [];
	
				hooks[name].push(callback);
			},
	
			run: function (name, env) {
				var callbacks = _.hooks.all[name];
	
				if (!callbacks || !callbacks.length) {
					return;
				}
	
				for (var i=0, callback; callback = callbacks[i++];) {
					callback(env);
				}
			}
		}
	};
	
	var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
		this.type = type;
		this.content = content;
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || "").length|0;
		this.greedy = !!greedy;
	};
	
	Token.stringify = function(o, language, parent) {
		if (typeof o == 'string') {
			return o;
		}
	
		if (_.util.type(o) === 'Array') {
			return o.map(function(element) {
				return Token.stringify(element, language, o);
			}).join('');
		}
	
		var env = {
			type: o.type,
			content: Token.stringify(o.content, language, parent),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language,
			parent: parent
		};
	
		if (env.type == 'comment') {
			env.attributes['spellcheck'] = 'true';
		}
	
		if (o.alias) {
			var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
			Array.prototype.push.apply(env.classes, aliases);
		}
	
		_.hooks.run('wrap', env);
	
		var attributes = Object.keys(env.attributes).map(function(name) {
			return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}).join(' ');
	
		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
	
	};
	
	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _self.Prism;
		}
	 	// In worker
		_self.addEventListener('message', function(evt) {
			var message = JSON.parse(evt.data),
			    lang = message.language,
			    code = message.code,
			    immediateClose = message.immediateClose;
	
			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);
	
		return _self.Prism;
	}
	
	//Get current script and highlight
	var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
	
	if (script) {
		_.filename = script.src;
	
		if (document.addEventListener && !script.hasAttribute('data-manual')) {
			if(document.readyState !== "loading") {
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(_.highlightAll);
				} else {
					window.setTimeout(_.highlightAll, 16);
				}
			}
			else {
				document.addEventListener('DOMContentLoaded', _.highlightAll);
			}
		}
	}
	
	return _self.Prism;
	
	})();
	
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Prism;
	}
	
	// hack for components to work correctly in node.js
	if (typeof global !== 'undefined') {
		global.Prism = Prism;
	}
	
	
	/* **********************************************
	     Begin prism-markup.js
	********************************************** */
	
	Prism.languages.markup = {
		'comment': /<!--[\w\W]*?-->/,
		'prolog': /<\?[\w\W]+?\?>/,
		'doctype': /<!DOCTYPE[\w\W]+?>/i,
		'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
		'tag': {
			pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
			inside: {
				'tag': {
					pattern: /^<\/?[^\s>\/]+/i,
					inside: {
						'punctuation': /^<\/?/,
						'namespace': /^[^\s>\/:]+:/
					}
				},
				'attr-value': {
					pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
					inside: {
						'punctuation': /[=>"']/
					}
				},
				'punctuation': /\/?>/,
				'attr-name': {
					pattern: /[^\s>\/]+/,
					inside: {
						'namespace': /^[^\s>\/:]+:/
					}
				}
	
			}
		},
		'entity': /&#?[\da-z]{1,8};/i
	};
	
	// Plugin to make entity title show the real entity, idea by Roman Komarov
	Prism.hooks.add('wrap', function(env) {
	
		if (env.type === 'entity') {
			env.attributes['title'] = env.content.replace(/&amp;/, '&');
		}
	});
	
	Prism.languages.xml = Prism.languages.markup;
	Prism.languages.html = Prism.languages.markup;
	Prism.languages.mathml = Prism.languages.markup;
	Prism.languages.svg = Prism.languages.markup;
	
	
	/* **********************************************
	     Begin prism-css.js
	********************************************** */
	
	Prism.languages.css = {
		'comment': /\/\*[\w\W]*?\*\//,
		'atrule': {
			pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
		'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
		'string': {
			pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		'property': /(\b|\B)[\w-]+(?=\s*:)/i,
		'important': /\B!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:]/
	};
	
	Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'style': {
				pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
				lookbehind: true,
				inside: Prism.languages.css,
				alias: 'language-css'
			}
		});
		
		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /\s*style=("|').*?\1/i,
				inside: {
					'attr-name': {
						pattern: /^\s*style/i,
						inside: Prism.languages.markup.tag.inside
					},
					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
					'attr-value': {
						pattern: /.+/i,
						inside: Prism.languages.css
					}
				},
				alias: 'language-css'
			}
		}, Prism.languages.markup.tag);
	}
	
	/* **********************************************
	     Begin prism-clike.js
	********************************************** */
	
	Prism.languages.clike = {
		'comment': [
			{
				pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
				lookbehind: true
			},
			{
				pattern: /(^|[^\\:])\/\/.*/,
				lookbehind: true
			}
		],
		'string': {
			pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
			greedy: true
		},
		'class-name': {
			pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
			lookbehind: true,
			inside: {
				punctuation: /(\.|\\)/
			}
		},
		'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
		'boolean': /\b(true|false)\b/,
		'function': /[a-z0-9_]+(?=\()/i,
		'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
		'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
		'punctuation': /[{}[\];(),.:]/
	};
	
	
	/* **********************************************
	     Begin prism-javascript.js
	********************************************** */
	
	Prism.languages.javascript = Prism.languages.extend('clike', {
		'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
		'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
		'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
		'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
	});
	
	Prism.languages.insertBefore('javascript', 'keyword', {
		'regex': {
			pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
			lookbehind: true,
			greedy: true
		}
	});
	
	Prism.languages.insertBefore('javascript', 'string', {
		'template-string': {
			pattern: /`(?:\\\\|\\?[^\\])*?`/,
			greedy: true,
			inside: {
				'interpolation': {
					pattern: /\$\{[^}]+\}/,
					inside: {
						'interpolation-punctuation': {
							pattern: /^\$\{|\}$/,
							alias: 'punctuation'
						},
						rest: Prism.languages.javascript
					}
				},
				'string': /[\s\S]+/
			}
		}
	});
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'script': {
				pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
				lookbehind: true,
				inside: Prism.languages.javascript,
				alias: 'language-javascript'
			}
		});
	}
	
	Prism.languages.js = Prism.languages.javascript;
	
	/* **********************************************
	     Begin prism-file-highlight.js
	********************************************** */
	
	(function () {
		if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
			return;
		}
	
		self.Prism.fileHighlight = function() {
	
			var Extensions = {
				'js': 'javascript',
				'py': 'python',
				'rb': 'ruby',
				'ps1': 'powershell',
				'psm1': 'powershell',
				'sh': 'bash',
				'bat': 'batch',
				'h': 'c',
				'tex': 'latex'
			};
	
			if(Array.prototype.forEach) { // Check to prevent error in IE8
				Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
					var src = pre.getAttribute('data-src');
	
					var language, parent = pre;
					var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
					while (parent && !lang.test(parent.className)) {
						parent = parent.parentNode;
					}
	
					if (parent) {
						language = (pre.className.match(lang) || [, ''])[1];
					}
	
					if (!language) {
						var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
						language = Extensions[extension] || extension;
					}
	
					var code = document.createElement('code');
					code.className = 'language-' + language;
	
					pre.textContent = '';
	
					code.textContent = 'Loading…';
	
					pre.appendChild(code);
	
					var xhr = new XMLHttpRequest();
	
					xhr.open('GET', src, true);
	
					xhr.onreadystatechange = function () {
						if (xhr.readyState == 4) {
	
							if (xhr.status < 400 && xhr.responseText) {
								code.textContent = xhr.responseText;
	
								Prism.highlightElement(code);
							}
							else if (xhr.status >= 400) {
								code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
							}
							else {
								code.textContent = '✖ Error: File does not exist or is empty';
							}
						}
					};
	
					xhr.send(null);
				});
			}
	
		};
	
		document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);
	
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))
	
	/***/ }),
	/* 24 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_24__;
	
	/***/ }),
	/* 25 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_25__;
	
	/***/ }),
	/* 26 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_26__;
	
	/***/ }),
	/* 27 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_27__;
	
	/***/ }),
	/* 28 */
	/***/ (function(module, exports) {
	
	module.exports = __WEBPACK_EXTERNAL_MODULE_28__;
	
	/***/ }),
	/* 29 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
	/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__markdown__ = __webpack_require__(6);
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownComponent", function() { return __WEBPACK_IMPORTED_MODULE_0__markdown__["a"]; });
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownConfig", function() { return __WEBPACK_IMPORTED_MODULE_0__markdown__["b"]; });
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownModule", function() { return __WEBPACK_IMPORTED_MODULE_0__markdown__["c"]; });
	/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MarkdownService", function() { return __WEBPACK_IMPORTED_MODULE_0__markdown__["d"]; });
	/* tslint:disable: max-classes-per-file */
	
	
	
	/***/ })
	/******/ ]);
	});
	//# sourceMappingURL=angular2-markdown.umd.js.map

/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var OutletComponent = (function () {
	    function OutletComponent() {
	    }
	    OutletComponent = __decorate([
	        core_1.Component({
	            selector: "nuricks-app",
	            template: "<router-outlet></router-outlet>"
	        }), 
	        __metadata('design:paramtypes', [])
	    ], OutletComponent);
	    return OutletComponent;
	}());
	exports.OutletComponent = OutletComponent;


/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var EventViewerService = (function () {
	    function EventViewerService() {
	        this.event = {
	            eventName: "",
	            doorsOpen: "",
	            ShowStarts: "",
	            image_url: "",
	            eventDate: "",
	            street_name: "",
	            zip_code: 0,
	            city: "",
	            state: "",
	            ageRequirement: "",
	            cost: 0
	        };
	    }
	    return EventViewerService;
	}());
	exports.EventViewerService = EventViewerService;
	var MusicianComponent = (function () {
	    function MusicianComponent(backendService, ps, evs, router) {
	        this.backendService = backendService;
	        this.ps = ps;
	        this.evs = evs;
	        this.router = router;
	        this.bioFallback = "Edit your page to add a bio";
	        this.editing = false;
	        this.braintree = __webpack_require__(376);
	        this.clientKey = "";
	        $(document).ready(function () {
	            var $bio = $(".bio");
	            /* Profile info save
	             */
	            $(".edit").click(function () {
	                $(".edit").fadeOut(200);
	                $(".submit").fadeIn(200);
	                $(".bioLinks").delay(200).fadeOut(200);
	                $(".bioEditLinks").delay(400).fadeIn(200);
	                $bio.find(".title, div").attr("contenteditable", "true");
	            });
	            $(".submit").click(function () {
	                $(".submit").fadeOut(200);
	                $(".edit").fadeIn(250);
	                $(".bioEditLinks").delay(200).fadeOut(200);
	                $(".bioLinks").delay(400).fadeIn(200);
	                $bio.find(".title, div").attr("contenteditable", "false");
	            });
	            /* Available/My Show logic
	             */
	            $('.showTabs').children('span').click(function (e) {
	                var that = $(e.currentTarget);
	                if (!$(that).hasClass('activeTab')) {
	                    $(that).toggleClass('activeTab');
	                    $(that).siblings().toggleClass('activeTab');
	                }
	            });
	            $('.myShows').click(function (e) {
	                if ($(e.currentTarget).hasClass('activeTab')) {
	                    $('.availableShowsList').fadeOut(150);
	                    $('.myShowsList').delay(150).fadeIn(150);
	                }
	            });
	            $('.availableShows').click(function (e) {
	                if ($(e.currentTarget).hasClass('activeTab')) {
	                    $('.myShowsList').fadeOut(150);
	                    $('.availableShowsList').delay(150).fadeIn(150);
	                }
	            });
	        });
	    }
	    MusicianComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.backendService.getPossibleEvents()
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                // push is nasty
	                _this.ps.musicianObject.events = [];
	                _this.ps.musicianObject.possibleEvents = response.events;
	                _this.backendService.getMusicianTickets(_this.ps.musicianObject.fbid)
	                    .subscribe(function (response) {
	                    if (response.status == "1") {
	                        var tickets = response.tickets;
	                        var _loop_1 = function() {
	                            var numberSold = tickets[i].numberSold;
	                            _this.backendService.getEventInfoFromID(tickets[i].EventId)
	                                .subscribe(function (response) {
	                                if (response.event_info) {
	                                    response.event_info._ticketsSold = numberSold;
	                                    _this.ps.musicianObject.events.push(response.event_info);
	                                    // remove from possible events
	                                    var pred = function (x) {
	                                        return x.id;
	                                    };
	                                    var remIndex = _this.ps.musicianObject.possibleEvents.map(pred).indexOf(response.event_info.id);
	                                    _this.ps.musicianObject.possibleEvents.splice(remIndex, 1);
	                                }
	                            });
	                        };
	                        for (var i = 0; i < tickets.length; ++i) {
	                            _loop_1();
	                        }
	                    }
	                });
	            }
	        });
	    };
	    MusicianComponent.prototype.ngAfterViewChecked = function () {
	        /* Join show modal
	         */
	        var $joinModal = $('.joinShowModal');
	        $('.availableShowsList').find('.btn').click(function (e) {
	            $joinModal.fadeIn(250);
	        });
	        $joinModal.find('.exit').click(function (e) {
	            $(e.currentTarget).parent().fadeOut(250);
	        });
	    };
	    MusicianComponent.prototype.ngOnDestroy = function () {
	        if (this.integration) {
	            this.integration.teardown();
	        }
	    };
	    MusicianComponent.prototype.cardNewWindow = function (idex, initial) {
	        var t = (screen.height / 2) - (250);
	        var l = (screen.width / 2) - (300);
	        this.popup = window.open('', '_blank', 'location=0,toolbar=0,resizable=0,top=' + t + ',left=' + l + ',menubar=0,height=325,width=600');
	        this.popup.document.open();
	        this.popup.document.write("<script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script><style>*,*:before,*:after{box-sizing:inherit}html{box-sizing:border-box;height:100%;overflow:hidden}body{background:#f2f2f2;font-family:'Roboto',verdana,sans-serif;height:100%}h1{font-size:1.5em;font-weight:100}#cardForm{height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.panel{background:#FFF;width:80%;box-shadow:0 2px 2px 0 rgba(0,0,0,.16),0 0 2px 0 rgba(0,0,0,.12)}.panel__header{background:#3F51B5;color:#FFF}.panel__header,.panel__footer{padding:1em 2em}.panel__footer{background:#f3f3f3}.panel__content{padding:1em 2em;overflow:hidden}.textfield--float-label{width:50%;float:left;display:inline-block}.hosted-field--label{-webkit-transform:translateY(.4em);transform:translateY(.4em);font-size:1.125em;line-height:32px;-webkit-transition:all .15s ease-out;transition:all .15s ease-out;display:block;width:100%;font-weight:400;overflow:hidden;margin-bottom:.5em}.hosted-field--label.label-float,.hosted-field--label.filled,.hosted-field--label.invalid{height:33px;margin-bottom:-1px;-webkit-transform:translate(0,0);transform:translate(0,0);font-size:12px;line-height:15px;text-overflow:ellipsis;color:#2196F3;-webkit-transition:all 0.15s ease-out;transition:all 0.15s ease-out}.hosted-field--label.filled{color:rgba(0,0,0,.54)}.hosted-field--label.invalid{color:#F44336}span.icon{position:relative;top:.2em;margin-right:.2em}svg{fill:#333}.hosted-field{height:32px;margin-bottom:1em;display:block;background-color:transparent;color:rgba(0,0,0,.87);border:none;border-bottom:1px solid rgba(0,0,0,.26);outline:0;width:100%;font-size:16px;padding:0;box-shadow:none;border-radius:0;position:relative}.pay-button{background:#E91E63;color:#fff;margin:0 auto;border:0;border-radius:3px;padding:1em 3em;font-size:1em;text-transform:uppercase;box-shadow:0 0 2px rgba(0,0,0,.12),0 2px 2px rgba(0,0,0,.2)}.braintree-hosted-fields-focused{border-bottom:2px solid #3F51B5;-webkit-transition:all 200ms ease;transition:all 200ms ease}.braintree-hosted-fields-invalid{border-bottom:2px solid #E91E63;-webkit-transition:all 200ms ease;transition:all 200ms ease}@media (max-width:600px){html{overflow:auto}#cardForm{height:auto;margin:2em;font-size:13px}.panel{width:100%}.textfield--float-label{width:100%;float:none;display:inline-block}.pay-button{width:100%}}</style><form action=\"javascript:formcallback();\" id=\"cardForm\"><div class=\"panel\"><header class=\"panel__header\"><h1>Card Payment</h1></header><div class=\"panel__content\"><div class=\"textfield--float-label\"><label class=\"hosted-field--label\" for=\"card-number\"><span class=\"icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z\"/></svg></span>Number of Tickets </label><input type=\"number\" max=\"100\" min=\"0\" id=\"card-number\" class=\"hosted-field\" value=\"" + initial + "\" required></input></div></div><footer class=\"panel__footer\"><button class=\"pay-button\">Pay</button></footer></div></form><script src=\"https://js.braintreegateway.com/web/3.14.0/js/client.min.js\"></script><script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script>");
	        this.popup.document.close();
	        this.popup_doc = this.popup.document;
	        var c = this;
	        var party = c.ps.musicianObject;
	        var musc = this.ps.musicianObject.stageName;
	        var event = this.ps.musicianObject.events[idex];
	        var eventId = this.ps.musicianObject.events[idex].id;
	        var eventCost = this.ps.musicianObject.events[idex].cost;
	        this.popup["formcallback"] = function () {
	            console.log(c.popup.document);
	            var val = c.popup.document.forms["cardForm"][0].value;
	            console.log(val);
	            c.backendService.getTicketFromEventID(eventId)
	                .subscribe(function (result) {
	                var ticketId = -1;
	                var ticket;
	                for (var i = 0; i < result.length; ++i) {
	                    if (result.tickets[i].MusicianFbid == c.ps.musicianObject.fbid) {
	                        ticketId = result.tickets[i].id;
	                        ticket = result.tickets[i];
	                        break;
	                    }
	                }
	                c.backendService.initiateTransaction(val, eventCost, c.ps.musicianObject.customer_id, !!c.ps.userObject.customer_id, ticketId)
	                    .subscribe(function (response) {
	                    console.log(response);
	                    c.backendService.sendEmail(event, party, musc, val, response.transaction_id)
	                        .subscribe(function (response) {
	                        if (status == "1") {
	                            console.log("Email Sent");
	                        }
	                    });
	                    c.popup.close();
	                });
	            });
	        };
	    };
	    MusicianComponent.prototype.linkToPayment = function () {
	        this.router.navigate(['/musicianuser']);
	    };
	    MusicianComponent.prototype.viewShow = function (event) {
	        var index = $(event.currentTarget).parent().parent().index();
	        this.evs.event = this.ps.musicianObject.possibleEvents[index];
	    };
	    MusicianComponent.prototype.submitCreateTicket = function () {
	        this.backendService.createTicket(this.ps.musicianObject.fbid, this.evs.event.id)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                window.location.href = '/';
	            }
	        });
	    };
	    MusicianComponent.prototype.editSys = function () {
	        $("#instagram-url").val(this.ps.musicianObject.instagramLink);
	        $("#facebook-url").val(this.ps.musicianObject.facebookLink);
	        $("#youtube-url").val(this.ps.musicianObject.youtubeLink);
	        $("#soundcloud-url").val(this.ps.musicianObject.soundcloudLink);
	        $("#profile-url").val(this.ps.musicianObject.picture_url);
	    };
	    MusicianComponent.prototype.saveMusicianData = function () {
	        this.ps.musicianObject.instagramLink = $("#instagram-url").val();
	        this.ps.musicianObject.facebookLink = $("#facebook-url").val();
	        this.ps.musicianObject.youtubeLink = $("#youtube-url").val();
	        this.ps.musicianObject.soundcloudLink = $("#soundcloud-url").val();
	        this.ps.musicianObject.picture_url = $("#profile-url").val();
	        this.ps.musicianObject.email = $("#artistEmail").text();
	        this.ps.musicianObject.phoneNumber = $("#artistPhone").text();
	        this.ps.musicianObject.stageName = $("#stage-name").text();
	        this.ps.musicianObject.bio = $("#bio").text();
	        this.backendService.musicianSaveDashboard(this.ps.musicianObject)
	            .subscribe(function (response) {
	        });
	    };
	    MusicianComponent = __decorate([
	        core_1.Component({
	            selector: "musician",
	            template: __webpack_require__(555)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _b) || Object, EventViewerService, (typeof (_c = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _c) || Object])
	    ], MusicianComponent);
	    return MusicianComponent;
	    var _a, _b, _c;
	}());
	exports.MusicianComponent = MusicianComponent;


/***/ },
/* 555 */
/***/ function(module, exports) {

	module.exports = "<div class=\"mainWrapper\">\n\t<div class=\"musicianWrapper\">\n\t\t<h1 class=\"musicianTitle\">Musician Dashboard</h1>\n\t\t<div class=\"bioBanner\" [style.background-image]=\"'url(res/banner.jpg)'\">\n\t\t\t<div class=\"bioPic\" [style.background-image]=\"'url('+ ps.musicianObject.picture_url +')'\"></div>\n\t\t\t<span class=\"submit\" (click)=\"saveMusicianData()\" style=\"display: none\">SAVE <i class=\"fa fa-lock\" aria-hidden=\"true\"></i></span>\n\t\t\t<ul class=\"bioLinks\">\n\t\t\t\t<li *ngIf=\"ps.musicianObject.instagramLink != null && ps.musicianObject.instagramLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"ps.musicianObject.instagramLink\" target=\"_blank\" [attr.data-url]=\"ps.musicianObject.instagramLink\">\n\t\t\t\t\t\t<i class=\"fa fa-instagram\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"ps.musicianObject.facebookLink != null && ps.musicianObject.facebookLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"ps.musicianObject.facebookLink\" target=\"_blank\" [attr.data-url]=\"ps.musicianObject.facebookLink\">\n\t\t\t\t\t\t<i class=\"fa fa-facebook\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"ps.musicianObject.youtubeLink != null && ps.musicianObject.youtubeLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"ps.musicianObject.youtubeLink\" target=\"_blank\" [attr.data-url]=\"ps.musicianObject.youtubeLink\">\n\t\t\t\t\t\t<i class=\"fa fa-youtube-play\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"ps.musicianObject.soundcloudLink != null && ps.musicianObject.soundcloudLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"ps.musicianObject.soundcloudLink\" target=\"_blank\" [attr.data-url]=\"ps.musicianObject.soundcloudLink\">\n\t\t\t\t\t\t<i class=\"fa fa-soundcloud\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t\t<ul style=\"display: none\" class=\"bioEditLinks\">\n\t\t\t\t<input type=\"text\" id=\"instagram-url\" placeholder=\"Instagram\">\n\t\t\t\t<input type=\"text\" id=\"facebook-url\" placeholder=\"Facebook\">\n\t\t\t\t<input type=\"text\" id=\"youtube-url\" placeholder=\"Youtube\">\n\t\t\t\t<input type=\"text\" id=\"soundcloud-url\" placeholder=\"Soundcloud\">\n\t\t\t\t<input type=\"text\" id=\"profile-url\" placeholder=\"Profile Picture URL\">\n\t\t\t</ul>\n\t\t\t<span class=\"uploadBanner\" style=\"display: none\">UPLOAD BANNER <i class=\"fa fa-camera\" aria-hidden=\"true\"></i></span>\n\t\t\t<span class=\"edit\" (click)=\"editSys()\">EDIT <i class=\"fa fa-edit\" aria-hidden=\"true\"></i></span>\n\t\t</div>\n\t\t<div class=\"row\">\n\t\t\t<div class=\"container half bio\">\n\t\t\t\t<h2>Share your profile with fans:</h2>\n\t\t\t\t<a [routerLink]=\"'/musician/' + ps.musicianObject.urlValue\" target=\"_blank\">http://www.nrshows.com/musician/{{ps.musicianObject.urlValue}}</a>\n\t\t\t\t<label>Email: </label>\n\t\t\t\t<div id=\"artistEmail\" [innerHTML]=\"ps.musicianObject.email\"></div>\n\t\t        <label>Phone Number: </label>\n\t\t\t\t<div id=\"artistPhone\" [innerHTML]=\"ps.musicianObject.phoneNumber\"></div>\n\t\t\t\t<h1 id=\"stage-name\" class=\"title\">{{ps.musicianObject.stageName || ps.musicianObject.firstName + \" \" + ps.musicianObject.lastName}}</h1>\n\t\t\t\t<div id=\"bio\" style=\"white-space: pre-wrap\" [innerHTML]=\"ps.musicianObject.bio | embed | async\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"container half shows\">\n\t\t\t\t<span class=\"showTabs\">\n\t\t\t\t\t<span class=\"tab myShows activeTab\">My Shows</span>\n\t\t\t\t\t<span class=\"tab availableShows\">Available Shows</span>\n\t\t\t\t</span>\n\t\t\t\t<div class=\"showList myShowsList\">\n\t\t\t\t\t<div *ngIf=\"ps.musicianObject.events.length <= 0\">You are currently not apart of any shows.</div>\n\t\t\t\t\t<div *ngFor=\"let event of ps.musicianObject.events; let idex = index\" class=\"showBlock\">\n\t\t\t\t\t\t<a class=\"showImg\" [style.background-image]=\"'url('+ event.image_url +')'\"></a>\n\t\t\t\t\t\t<div class=\"showDetails\">\n\t\t\t\t\t\t\t<h1>{{event.eventName}}</h1>\n\t\t                    <h2>Headliner: {{event.headliner}}</h2>\n\t\t                    <h3>Address: {{event.street_name}}, {{event.city}}, {{event.state}} {{event.zip_code}}</h3>\n\t\t                    <h3>Venue: {{event.venue}}</h3>\n\t\t\t\t\t\t\t<h3>{{event.eventDate | date: \"yMMMMd\"}} &mdash; <span>${{event.cost}} + ${{event.extraAtDoor}} at door</span></h3>\n\t\t\t\t\t\t\t<a (click)=\"ps.musicianObject.customer_id ? cardNewWindow(idex, 0) : linkToPayment()\" class=\"btn\">{{ps.musicianObject.customer_id ? \"Buy Tickets\" : \"Enter a Payment Option\"}}</a>\n\t\t\t\t\t\t\t<a (click)=\"ps.musicianObject.customer_id ? cardNewWindow(idex, event.numberNeededToSell - event._ticketsSold) : linkToPayment()\" *ngIf=\"ps.musicianObject.customer_id\" class=\"btn\">Buyout Tickets</a>\n\t\t\t\t\t\t\t<h3 class=\"progress\">Sold:\n\t\t\t\t\t\t\t\t<span class=\"sold\">{{event._ticketsSold}}</span>/<span class=\"needed\">{{event.numberNeededToSell}}</span>\n\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"showList availableShowsList\" style=\"display: none\">\n\t\t\t\t\t<div *ngIf=\"!ps.musicianObject.phoneNumber || !ps.musicianObject.email\">You must enter your email and phone number to be eligible for shows.</div>\n\t\t\t\t\t<div *ngIf=\"ps.musicianObject.events.length\">You can only be a part of one show at a time.</div>\n\t\t\t\t\t<div *ngIf=\"ps.musicianObject.possibleEvents.length <= 0 && ps.musicianObject.phoneNumber && ps.musicianObject.email\">There are currently no possible shows.</div>\n\t\t\t\t\t<ng-container *ngIf=\"ps.musicianObject.phoneNumber && ps.musicianObject.email && !ps.musicianObject.events.length\">\n\t\t\t\t\t\t<div *ngFor=\"let event of ps.musicianObject.possibleEvents\" class=\"showBlock\">\n\t\t\t\t\t\t\t<a class=\"showImg\" [style.background-image]=\"'url('+ event.image_url +')'\"></a>\n\t\t\t\t\t\t\t<div class=\"showDetails\">\n\t\t\t\t\t\t\t\t<h1>{{event.eventName}}</h1>\n\t\t\t                    <h2>Headliner: {{event.headliner}}</h2>\n\t\t\t                    <h3>Address: {{event.street_name}}, {{event.city}}, {{event.state}} {{event.zip_code}}</h3>\n\t\t\t                    <h3>Venue: {{event.venue}}</h3>\n\t\t\t\t\t\t\t\t<h3>{{event.eventDate | date: \"yMMMMd\"}} &mdash; <span>${{event.cost}} + ${{event.extraAtDoor}} at door</span></h3>\n\t\t\t\t\t\t\t\t<a class=\"btn\" (click)=\"viewShow($event)\">Join Show</a>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-container>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n<div class=\"modal joinShowModal\" style=\"display: none\">\n\t<i class=\"fa fa-times exit\"></i>\n\t<h1><i class=\"fa fa-chevron-down rotate\"></i> Terms and Conditions</h1>\n\t<p>By joining this event you are agreeing to the Nu-Ricks terms of service. <a href=\"\">Read TOS.</a></p>\n\t<hr>\n\t<h1><i class=\"fa fa-chevron-down\"></i> Event Details</h1>\n\t<h3 *ngIf=\"evs.event.ageRequirement\">Must be over {{evs.event.ageRequirement}}</h3>\n\t<h3>Need to sell {{evs.event.numberNeededToSell}} tickets</h3>\n\t<h3>Located {{evs.event.street_name}} {{evs.event.city}}, {{evs.event.state}} {{evs.event.zip_code}}</h3>\n\t<h3>Sound check at {{evs.event.doorsOpen}}</h3>\n\t<h3>Show starts at {{evs.event.ShowStarts}}</h3>\n\t<p></p>\n\t<hr>\n\t<button (click)=\"submitCreateTicket()\">Join Event</button>\n</div>\n";

/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var MusicianUserComponent = (function () {
	    function MusicianUserComponent(ps, backendService, zone) {
	        this.ps = ps;
	        this.backendService = backendService;
	        this.zone = zone;
	        this.transactions = [];
	        this.braintree = __webpack_require__(376);
	        this.clientKey = "";
	    }
	    MusicianUserComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        $(document).ready(function () {
	            $('.userTabs').children().click(function (e) {
	                var toShow = "." + $(e.currentTarget).attr('data-show');
	                $('.userTabs').children().removeClass('activeTab');
	                $(e.currentTarget).addClass('activeTab');
	                $('._userpanel').hide(150);
	                $(toShow).delay(150).show();
	            });
	        });
	        if (this.ps.musicianObject.customer_id) {
	            this.backendService.getTransactionHistory(this.ps.musicianObject.customer_id)
	                .subscribe(function (response) {
	                _this.transactions = response.transactions;
	                console.log(response.transactions);
	            });
	        }
	    };
	    MusicianUserComponent.prototype.updateCID = function (id) {
	        var _this = this;
	        this.zone.run(function () { return _this.ps.musicianObject.customer_id = id; });
	        this.ngOnInit();
	    };
	    MusicianUserComponent.prototype.updateCC = function (payload) {
	        var _this = this;
	        this.backendService.musicianUpdateCC(this.ps.musicianObject.fbid, payload.details.lastTwo)
	            .subscribe(function (response) {
	            console.log(response);
	            _this.zone.run(function () { return _this.ps.musicianObject.card_digits = response.musician.card_digits; });
	        });
	    };
	    MusicianUserComponent.prototype.cardNewWindow = function () {
	        var _this = this;
	        var t = (screen.height / 2) - (250);
	        var l = (screen.width / 2) - (300);
	        this.popup = window.open('', '_blank', 'toolbar=0,resizable=0,top=' + t + ',left=' + l + ',menubar=0,height=500,width=600');
	        this.popup.document.open();
	        this.popup.document.write("<script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script><style id=_card_styling>*,:after,:before{box-sizing:inherit}html{box-sizing:border-box;height:100%;overflow:hidden}body{background:#f2f2f2;font-family:Roboto,verdana,sans-serif;height:100%}h1{font-size:1.5em;font-weight:100}#cardForm{height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.panel{background:#fff;width:80%;box-shadow:0 2px 2px 0 rgba(0,0,0,.16),0 0 2px 0 rgba(0,0,0,.12)}.panel__header{background:#3f51b5;color:#fff}.panel__footer,.panel__header{padding:1em 2em}.panel__footer{background:#f3f3f3}.panel__content{padding:1em 2em;overflow:hidden}.textfield--float-label{width:50%;float:left;display:inline-block}.hosted-field--label{-webkit-transform:translateY(.4em);transform:translateY(.4em);font-size:1.125em;line-height:32px;-webkit-transition:all .15s ease-out;transition:all .15s ease-out;display:block;width:100%;font-weight:400;overflow:hidden;margin-bottom:.5em}.hosted-field--label.filled,.hosted-field--label.invalid,.hosted-field--label.label-float{height:33px;margin-bottom:-1px;-webkit-transform:translate(0,0);transform:translate(0,0);font-size:12px;line-height:15px;text-overflow:ellipsis;color:#2196f3;-webkit-transition:all .15s ease-out;transition:all .15s ease-out}.hosted-field--label.filled{color:rgba(0,0,0,.54)}.hosted-field--label.invalid{color:#f44336}span.icon{position:relative;top:.2em;margin-right:.2em}svg{fill:#333}.hosted-field{height:32px;margin-bottom:1em;display:block;background-color:transparent;color:rgba(0,0,0,.87);border:none;border-bottom:1px solid rgba(0,0,0,.26);outline:0;width:100%;font-size:16px;padding:0;box-shadow:none;border-radius:0;position:relative}.pay-button{background:#e91e63;color:#fff;margin:0 auto;border:0;border-radius:3px;padding:1em 3em;font-size:1em;text-transform:uppercase;box-shadow:0 0 2px rgba(0,0,0,.12),0 2px 2px rgba(0,0,0,.2)}.braintree-hosted-fields-focused{border-bottom:2px solid #3f51b5;-webkit-transition:all .2s ease;transition:all .2s ease}.braintree-hosted-fields-invalid{border-bottom:2px solid #e91e63;-webkit-transition:all .2s ease;transition:all .2s ease}@media (max-width:600px){html{overflow:auto}#cardForm{height:auto;margin:2em;font-size:13px}.panel{width:100%}.textfield--float-label{width:100%;float:none;display:inline-block}.pay-button{width:100%}}</style><form action=\"\" id=cardForm method=post><div class=panel><header class=panel__header><h1>Card Payment</h1></header><div id=error-message></div><div class=panel__content><div class=textfield--float-label><label class=hosted-field--label for=card-number><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M0 0h24v24H0z\"fill=none /><path d=\"M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z\"/></svg> </span>Card Number</label><div class=hosted-field id=card-number name=card-number></div></div><div class=textfield--float-label><label class=hosted-field--label for=cvv><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z\"/></svg> </span>CVV</label><div class=hosted-field id=cvv name=cvv></div></div><div class=textfield--float-label><label class=hosted-field--label for=expiration-date><span class=icon><svg height=20 viewBox=\"0 0 24 24\"width=20 xmlns=http://www.w3.org/2000/svg><path d=\"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z\"/></svg> </span>Expiration Date</label><div class=hosted-field id=expiration-date name=expiration-date></div></div></div><input name=payment_method_nonce type=hidden><footer class=panel__footer><button class=pay-button type=\"submit\">Add Card</button></footer></div></form>");
	        this.popup_doc = this.popup.document;
	        this.submit = this.popup_doc.querySelector('.pay-button');
	        this.form = this.popup_doc.querySelector('#cardForm');
	        var c = this;
	        this.backendService.getClientToken()
	            .subscribe(function (response) {
	            _this.clientKey = response.tok;
	            _this.braintree.client.create({
	                authorization: _this.clientKey
	            }, function (clientErr, clientInstance) {
	                if (clientErr) {
	                    return;
	                }
	                $(c.popup_doc).ready(function () {
	                    c.popup["braintree"].hostedFields.create({
	                        client: clientInstance,
	                        styles: {
	                            'input': {
	                                'font-size': '14pt'
	                            },
	                            'input.invalid': {
	                                'color': 'red'
	                            },
	                            'input.valid': {
	                                'color': 'green'
	                            }
	                        },
	                        fields: {
	                            number: {
	                                selector: '#card-number',
	                                placeholder: '4111 1111 1111 1111'
	                            },
	                            cvv: {
	                                selector: '#cvv',
	                                placeholder: '123'
	                            },
	                            expirationDate: {
	                                selector: '#expiration-date',
	                                placeholder: '10/2019'
	                            }
	                        }
	                    }, function (hostedFieldsErr, hostedFieldsInstance) {
	                        var form = c.popup_doc.querySelector("#cardForm");
	                        if (hostedFieldsErr) {
	                            // Handle error in Hosted Fields creation
	                            return;
	                        }
	                        // c.submit.removeAttribute('disabled');
	                        form.addEventListener('submit', function (event) {
	                            event.preventDefault();
	                            hostedFieldsInstance.tokenize(function (tokenizeErr, payload) {
	                                var payState = payload;
	                                console.log(payload);
	                                if (tokenizeErr) {
	                                    // Handle error in Hosted Fields tokenization
	                                    return;
	                                }
	                                var u = {
	                                    payment_method_nonce: payload.nonce
	                                };
	                                c.backendService.musicianCreatePaymentInformation(c.ps.musicianObject.fbid, u)
	                                    .subscribe(function (response) {
	                                    console.log(response);
	                                    c.popup.close();
	                                    c.updateCID(response.user.customer_id);
	                                    c.updateCC(payState);
	                                });
	                            });
	                        }, false);
	                    });
	                });
	            });
	        });
	    };
	    MusicianUserComponent.prototype.deletePaymentMethod = function () {
	        var _this = this;
	        this.backendService.musicianDeleteCustomerPaymentInfo(this.ps.musicianObject.fbid)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.updateCID(null);
	            }
	        });
	    };
	    MusicianUserComponent = __decorate([
	        core_1.Component({
	            selector: "musicianuser",
	            template: __webpack_require__(557)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _a) || Object, (typeof (_b = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _b) || Object, (typeof (_c = typeof core_1.NgZone !== 'undefined' && core_1.NgZone) === 'function' && _c) || Object])
	    ], MusicianUserComponent);
	    return MusicianUserComponent;
	    var _a, _b, _c;
	}());
	exports.MusicianUserComponent = MusicianUserComponent;


/***/ },
/* 557 */
/***/ function(module, exports) {

	module.exports = "<div class=\"userWrapper\">\n    <h1 class=\"title\">Account</h1>\n    <div class=\"userTabs\" *ngIf=\"ps.musicianObject.customer_id\">\n        <span data-show=\"_payment\" class=\"tab activeTab\">Payment</span>\n        <span data-show=\"_transactionhistory\" class=\"tab\">Transaction History</span>\n    </div>\n    <div class=\"userSettings\" *ngIf=\"!ps.musicianObject?.customer_id && !ps.musicianObject?.email\">\n        <form id=\"nonceForm\" action=\"\" class=\"emailConfirm\">\n            <h2>Please confirm your email before you can purchase tickets</h2>\n        </form>\n    </div>\n    <div class=\"paymentOptions _payment _userpanel\">\n        <div class=\"paymentOption\" *ngIf=\"ps.musicianObject.customer_id\">\n            <span class=\"deletePO\" (click)=\"deletePaymentMethod()\">DELETE</span>\n            <h1><i class=\"fa fa-cc-visa\"></i> Card ending in {{ps.musicianObject.card_digits}}</h1>\n        </div>\n        <div (click)=\"cardNewWindow()\" *ngIf=\"!ps.musicianObject?.customer_id && ps.musicianObject?.email\" class=\"paymentOption newPO\">\n            <i class=\"fa fa-plus\"></i>\n            <h2>Add Payment Option</h2>\n        </div>\n    </div>\n    <ng-container *ngIf=\"ps.musicianObject.customer_id\">\n        <table class=\"transactionHistory _transactionhistory _userpanel\" style=\"display: none;\">\n            <tr>\n                <th>Event</th>\n                <th>Total</th>\n                <th>Order Placed</th>\n            </tr>\n            <tr *ngFor=\"let t of transactions\">\n                <td>Event #1</td>\n                <td>{{t.amount}} + {{t.serviceFeeAmount ? t.serviceFeeAmount : 0}} Service Fee</td>\n                <td>April 23, 2017 8:37PM</td>\n            </tr>\n        </table>\n    </ng-container>\n    <button class=\"deleteProfile\"><i class=\"fa fa-times-circle\"></i> Delete Profile</button>\n</div>\n";

/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	// Angular imports
	var core_1 = __webpack_require__(4);
	var router_1 = __webpack_require__(30);
	// Custom imports
	var backend_service_1 = __webpack_require__(74);
	var main_global_1 = __webpack_require__(369);
	var PublicMusicianService = (function () {
	    function PublicMusicianService(backendService, ps, router) {
	        this.backendService = backendService;
	        this.ps = ps;
	        this.router = router;
	        this.p_musicianObject = {
	            fbid: "",
	            stageName: "",
	            firstName: "",
	            lastName: "",
	            soundcloudLink: "",
	            bio: "",
	            instagramLink: "",
	            youtubeLink: "",
	            facebookLink: "",
	            picture_url: "",
	            verified: false
	        };
	        this.p_events = [];
	    }
	    PublicMusicianService.prototype.resolve = function (route, state) {
	        var _this = this;
	        return this.backendService.getMusician(this.urlid = route.params["id"])
	            .map(function (response) {
	            if (response.status == "1" && response.musician_info) {
	                var a = response.musician_info;
	                _this.p_musicianObject.fbid = a.fbid;
	                _this.p_musicianObject.stageName = a.stageName;
	                _this.p_musicianObject.firstName = a.firstName;
	                _this.p_musicianObject.lastName = a.lastName;
	                _this.p_musicianObject.soundcloudLink = a.soundcloudLink;
	                _this.p_musicianObject.bio = a.bio;
	                _this.p_musicianObject.instagramLink = a.instagramLink;
	                _this.p_musicianObject.youtubeLink = a.youtubeLink;
	                _this.p_musicianObject.facebookLink = a.facebookLink;
	                _this.p_musicianObject.picture_url = a.picture_url;
	                _this.p_musicianObject.verified = a.verified;
	            }
	            else {
	                _this.router.navigate(['/']);
	            }
	        });
	    };
	    PublicMusicianService = __decorate([
	        core_1.Injectable(), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _b) || Object, (typeof (_c = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _c) || Object])
	    ], PublicMusicianService);
	    return PublicMusicianService;
	    var _a, _b, _c;
	}());
	exports.PublicMusicianService = PublicMusicianService;
	var PublicMusicianComponent = (function () {
	    function PublicMusicianComponent(backendService, ps, pm, router) {
	        this.backendService = backendService;
	        this.ps = ps;
	        this.pm = pm;
	        this.router = router;
	        this.bioFallback = "This musician doesn't have a bio";
	        this.braintree = __webpack_require__(376);
	        this.clientKey = "";
	    }
	    PublicMusicianComponent.prototype.linkToPayment = function () {
	        if (this.ps.musicianObject.fbid) {
	            this.router.navigate(['/musicianuser']);
	        }
	        else if (this.ps.userObject.fbid) {
	            this.router.navigate(['/user']);
	        }
	        else {
	            if (!$("body").hasClass("drop")) {
	                $("body").addClass("drop");
	                $(".loginOverlay").delay(250).fadeIn();
	            }
	            else {
	                $(".loginOverlay").fadeOut().queue(function (next) {
	                    $("body").removeClass("drop");
	                    next();
	                });
	            }
	        }
	    };
	    PublicMusicianComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        this.backendService.getMusicianTickets(this.pm.p_musicianObject.fbid)
	            .subscribe(function (response) {
	            if (response.status == "1") {
	                _this.pm.p_events = [];
	                var tickets = response.tickets;
	                for (var i = 0; i < tickets.length; ++i) {
	                    _this.backendService.getEventInfoFromID(tickets[i].EventId)
	                        .subscribe(function (response) {
	                        if (response.status == "1") {
	                            _this.pm.p_events.push(response.event_info);
	                        }
	                    });
	                }
	            }
	        });
	    };
	    PublicMusicianComponent.prototype.cardNewWindow = function (idex) {
	        var t = (screen.height / 2) - (250);
	        var l = (screen.width / 2) - (300);
	        this.popup = window.open('', '_blank', 'location=0,toolbar=0,resizable=0,top=' + t + ',left=' + l + ',menubar=0,height=325,width=600');
	        this.popup.document.open();
	        this.popup.document.write("<script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script><style>*,*:before,*:after{box-sizing:inherit}html{box-sizing:border-box;height:100%;overflow:hidden}body{background:#f2f2f2;font-family:'Roboto',verdana,sans-serif;height:100%}h1{font-size:1.5em;font-weight:100}#cardForm{height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.panel{background:#FFF;width:80%;box-shadow:0 2px 2px 0 rgba(0,0,0,.16),0 0 2px 0 rgba(0,0,0,.12)}.panel__header{background:#3F51B5;color:#FFF}.panel__header,.panel__footer{padding:1em 2em}.panel__footer{background:#f3f3f3}.panel__content{padding:1em 2em;overflow:hidden}.textfield--float-label{width:50%;float:left;display:inline-block}.hosted-field--label{-webkit-transform:translateY(.4em);transform:translateY(.4em);font-size:1.125em;line-height:32px;-webkit-transition:all .15s ease-out;transition:all .15s ease-out;display:block;width:100%;font-weight:400;overflow:hidden;margin-bottom:.5em}.hosted-field--label.label-float,.hosted-field--label.filled,.hosted-field--label.invalid{height:33px;margin-bottom:-1px;-webkit-transform:translate(0,0);transform:translate(0,0);font-size:12px;line-height:15px;text-overflow:ellipsis;color:#2196F3;-webkit-transition:all 0.15s ease-out;transition:all 0.15s ease-out}.hosted-field--label.filled{color:rgba(0,0,0,.54)}.hosted-field--label.invalid{color:#F44336}span.icon{position:relative;top:.2em;margin-right:.2em}svg{fill:#333}.hosted-field{height:32px;margin-bottom:1em;display:block;background-color:transparent;color:rgba(0,0,0,.87);border:none;border-bottom:1px solid rgba(0,0,0,.26);outline:0;width:100%;font-size:16px;padding:0;box-shadow:none;border-radius:0;position:relative}.pay-button{background:#E91E63;color:#fff;margin:0 auto;border:0;border-radius:3px;padding:1em 3em;font-size:1em;text-transform:uppercase;box-shadow:0 0 2px rgba(0,0,0,.12),0 2px 2px rgba(0,0,0,.2)}.braintree-hosted-fields-focused{border-bottom:2px solid #3F51B5;-webkit-transition:all 200ms ease;transition:all 200ms ease}.braintree-hosted-fields-invalid{border-bottom:2px solid #E91E63;-webkit-transition:all 200ms ease;transition:all 200ms ease}@media (max-width:600px){html{overflow:auto}#cardForm{height:auto;margin:2em;font-size:13px}.panel{width:100%}.textfield--float-label{width:100%;float:none;display:inline-block}.pay-button{width:100%}}</style><form action=\"javascript:formcallback();\" id=\"cardForm\"><div class=\"panel\"><header class=\"panel__header\"><h1>Card Payment</h1></header><div class=\"panel__content\"><div class=\"textfield--float-label\"><label class=\"hosted-field--label\" for=\"card-number\"><span class=\"icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 24 24\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z\"/></svg></span>Number of Tickets </label><input type=\"number\" max=\"100\" min=\"0\" id=\"card-number\" class=\"hosted-field\" required></input></div></div><footer class=\"panel__footer\"><button class=\"pay-button\">Pay</button></footer></div></form><script src=\"https://js.braintreegateway.com/web/3.14.0/js/client.min.js\"></script><script src=\"https://js.braintreegateway.com/web/3.14.0/js/hosted-fields.min.js\"></script>");
	        this.popup.document.close();
	        this.popup_doc = this.popup.document;
	        var c = this;
	        var party = c.ps.userObject || c.ps.musicianObject;
	        var event = this.pm.p_events[idex];
	        var musc = this.pm.p_musicianObject.stageName;
	        var eventId = this.pm.p_events[idex].id;
	        var eventCost = this.pm.p_events[idex].cost;
	        this.popup["formcallback"] = function () {
	            console.log(c.popup.document);
	            var val = c.popup.document.forms["cardForm"][0].value;
	            console.log(val);
	            c.backendService.getTicketFromEventID(eventId)
	                .subscribe(function (result) {
	                console.log(result);
	                var ticketId = -1;
	                var ticket;
	                for (var i = 0; i < result.tickets.length; ++i) {
	                    if (result.tickets[String(i)].MusicianFbid == c.pm.p_musicianObject.fbid) {
	                        ticketId = result.tickets[String(i)].id;
	                        ticket = result.tickets[String(i)];
	                        break;
	                    }
	                }
	                c.backendService.initiateTransaction(val, eventCost, party.customer_id, !!c.ps.userObject.customer_id, ticketId)
	                    .subscribe(function (response) {
	                    console.log(response);
	                    c.backendService.sendEmail(event, party, musc, val, response.transaction_id)
	                        .subscribe(function (response) {
	                        if (status == "1") {
	                            console.log("Email Sent");
	                        }
	                    });
	                    c.popup.close();
	                });
	            });
	        };
	    };
	    PublicMusicianComponent = __decorate([
	        core_1.Component({
	            selector: "publicmusician",
	            template: __webpack_require__(559)
	        }), 
	        __metadata('design:paramtypes', [(typeof (_a = typeof backend_service_1.BackendService !== 'undefined' && backend_service_1.BackendService) === 'function' && _a) || Object, (typeof (_b = typeof main_global_1.PersistentService !== 'undefined' && main_global_1.PersistentService) === 'function' && _b) || Object, PublicMusicianService, (typeof (_c = typeof router_1.Router !== 'undefined' && router_1.Router) === 'function' && _c) || Object])
	    ], PublicMusicianComponent);
	    return PublicMusicianComponent;
	    var _a, _b, _c;
	}());
	exports.PublicMusicianComponent = PublicMusicianComponent;


/***/ },
/* 559 */
/***/ function(module, exports) {

	module.exports = "<div class=\"mainWrapper\">\n\t<div class=\"musicianWrapper\">\n\t\t<div class=\"bioBanner\" [style.background-image]=\"'url(res/banner.jpg)'\">\n\t\t\t<ul class=\"bioLinks\">\n\t\t\t\t<div class=\"bioPic\" [style.background-image]=\"'url('+ pm.p_musicianObject.picture_url +')'\"></div>\n\t\t\t\t<li *ngIf=\"pm.p_musicianObject.instagramLink != null && pm.p_musicianObject.instagramLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"pm.p_musicianObject.instagramLink\" target=\"_blank\" [attr.data-url]=\"pm.p_musicianObject.instagramLink\">\n\t\t\t\t\t\t<i class=\"fa fa-instagram\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"pm.p_musicianObject.facebookLink != null && pm.p_musicianObject.facebookLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"pm.p_musicianObject.facebookLink\" target=\"_blank\" [attr.data-url]=\"pm.p_musicianObject.facebookLink\">\n\t\t\t\t\t\t<i class=\"fa fa-facebook\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"pm.p_musicianObject.youtubeLink != null && pm.p_musicianObject.youtubeLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"pm.p_musicianObject.youtubeLink\" target=\"_blank\" [attr.data-url]=\"pm.p_musicianObject.youtubeLink\">\n\t\t\t\t\t\t<i class=\"fa fa-youtube-play\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t\t<li *ngIf=\"pm.p_musicianObject.soundcloudLink != null && pm.p_musicianObject.soundcloudLink != ''\">\n\t\t\t\t\t<a [attr.href]=\"pm.p_musicianObject.soundcloudLink\" target=\"_blank\" [attr.data-url]=\"pm.p_musicianObject.soundcloudLink\">\n\t\t\t\t\t\t<i class=\"fa fa-soundcloud\"></i>\n\t\t\t\t\t</a>\n\t\t\t\t</li>\n\t\t\t</ul>\n\t\t</div>\n\t\t<div class=\"row\">\n\t\t\t<div class=\"container half bio\">\n\t\t\t\t<h1 id=\"stage-name\" class=\"title\">{{pm.p_musicianObject.stageName || pm.p_musicianObject.firstName + \" \" + pm.p_musicianObject.lastName}}</h1>\n\t\t\t\t<div id=\"bio\" style=\"white-space: pre-wrap\" [innerHTML]=\"pm.p_musicianObject.bio | embed | async\"></div>.\n\t\t\t</div>\n\t\t\t<div class=\"container half myShows\">\n\t\t\t\t<h1 class=\"title\">Upcoming Shows</h1>\n\t\t\t\t<div class=\"showList myShowsList\">\n\t\t\t\t\t<div *ngIf=\"pm.p_events.length <= 0\">This musician currently does not have any shows.</div>\n\t\t\t\t\t<div *ngFor=\"let event of pm.p_events; let idex = index\" class=\"showBlock\">\n\t\t\t\t\t\t<a class=\"showImg\" [style.background-image]=\"'url('+ event.image_url +')'\"></a>\n\t\t\t\t\t\t<div class=\"showDetails\">\n\t\t\t\t\t\t\t<h1>{{event.eventName}}</h1>\n\t\t                    <h2>Headliner: {{event.headliner}}</h2>\n\t\t                    <h3>Address: {{event.street_name}}, {{event.city}}, {{event.state}} {{event.zip_code}}</h3>\n\t\t                    <h3>Venue: {{event.venue}}</h3>\n\t\t\t\t\t\t\t<h3>{{event.eventDate | date: \"yMMMMd\"}} &mdash; <span>${{event.cost}} + ${{event.extraAtDoor}} at door</span></h3>\n\t\t\t\t\t\t\t<a (click)=\"ps.userObject.customer_id || ps.musicianObject.customer_id ? cardNewWindow(idex) : linkToPayment()\" class=\"btn\">{{ps.userObject.customer_id || ps.musicianObject.customer_id ? \"Buy Tickets\" : \"Enter a Payment Option\"}}</a>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";

/***/ }
]);
//# sourceMappingURL=app.min.js.map